<?xml-stylesheet type="text/xml" href="page.xsl"?>
<!--
Copyright (c) 2005-2024 Broadcom. All Rights Reserved. The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.

All rights reserved. This program and the accompanying materials
are made available under the terms of the under the Apache License,
Version 2.0 (the "Licenseâ€); you may not use this file except in compliance
with the License. You may obtain a copy of the License at

https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:doc="https://www.rabbitmq.com/namespaces/ad-hoc/doc"
      xmlns:x="https://www.rabbitmq.com/2011/extensions"
      xmlns:xi="http://www.w3.org/2003/XInclude">
  <head>
    <title>Compatibility and Conformance</title>
  </head>
  <body show-in-this-page="true">
      <doc:section name="spec">
  <p>
  RabbitMQ implements version 0-9-1 of the AMQP specification in the core,
  with a number of <a href="extensions.html">extensions</a> to the
  specification.
  </p>
  <p>
    RabbitMQ implements AMQP 1.0 via a <a
    href="plugins.html">plugin</a>. However, AMQP 1.0 is a completely
    different protocol than AMQP 0-9-1 and hence not a suitable
    replacement for the latter. RabbitMQ will therefore continue to
    support AMQP 0-9-1 indefinitely.
  </p>
        <p>
          The 0-9-1 (with and without extensions) specifications are linked to below for
          your convenience.  We recommend reading them if you want to
          learn more about AMQP 0-9-1. Please see our <a href="./tutorials/amqp-concepts.html">AMQP 0-9-1 Overview guide</a>,
           <a href="amqp-0-9-1-reference.html">AMQP 0-9-1 Reference guide</a>, and the rest of
          <a href="documentation.html">documentation</a> for more information.
	</p>
      </doc:section>

    <doc:section name="release-version-mapping">

    <xi:include href="amqp-proto-download-table.xml.inc"/>

	<doc:heading>Specification Versions Supported</doc:heading>
	<p>
	  The following table describes the version of the AMQP
	  protocol specification implemented by RabbitMQ release 2.0.0 and later:
	</p>

	<table class="styled-table">
	  <tr>
        <th>Component</th>
	    <th>Implements AMQP protocol version</th>
	  </tr>
	  <tr>
        <td>Server</td>
	    <td> 0-9-1</td>
	  </tr>
	  <tr>
        <td>Java client</td>
	    <td> 0-9-1</td>
	  </tr>
	  <tr>
        <td>.NET/C# client</td>
	    <td> 0-9-1</td>
	  </tr>
	  <tr>
	    <td>Erlang client</td>
	    <td> 0-9-1</td>
	  </tr>
	</table>
      </doc:section>

      <doc:section name="ver-diffs">
    	  <doc:heading>Differences between versions</doc:heading>
        <p>
          Please see the <a href="amqp-0-8-to-0-9-1.html">0-8 to 0-9-1 page</a>.
        </p>
        <p>
          AMQP 1.0 introduced significant changes to the spec compared to 0-9-1,
          and at least in RabbitMQ, considered to be a separate protocol, support for
          which is provided using a plugin.
        </p>
      </doc:section>

      <doc:section name="interop">
	<doc:heading>Interoperability</doc:heading>
	<p>
	  Please see the <a href="interoperability.html">interoperability page</a>.
	</p>
      </doc:section>

      <doc:section name="deprecated-classes">
	<doc:heading>Deprecated classes</doc:heading>
    <p>
      The following classes were deprecated in version 0-9-1.
      RabbitMQ does not implement these classes at all, including
      when the broker is connected to a version 0-8 client, or
      when the .NET client is configured to use 0-8.
       <ul>
        <li>access</li>
        <li>dtx</li>
        <li>file</li>
        <li>stream</li>
        <li>test</li>
        <li>tunnel</li>
       </ul>
      </p>
	<p>
	  See also the detailed specification compatibility tables
	  below.
	</p>
      </doc:section>

      <doc:section name="classes">
	<doc:heading>Classes from the AMQP specification, version 0-9-1</doc:heading>
	<p>
	  The following table describes the current implementation status
	  of the various AMQP protocol message classes.
	</p>
	<classes xmlns="https://www.rabbitmq.com/namespaces/ad-hoc/conformance">
	  <class name="connection" handler="connection" index="10"><status value="ok"/></class>
	  <class name="channel" handler="channel" index="20"><status value="ok"/></class>
	  <class name="exchange" handler="channel" index="40"><status value="ok"/></class>
	  <class name="queue" handler="channel" index="50"><status value="ok"/></class>
	  <class name="basic" handler="channel" index="60"><status value="ok"/></class>
	  <class name="tx" handler="channel" index="90"><status value="partial"/><notes>See <a href="semantics.html#tx">notes on tx support</a></notes></class>
	</classes>
      </doc:section>

      <doc:section name="methods">
	<doc:heading>Methods from the AMQP specification, version 0-9-1</doc:heading>
	<p>
	  The following table describes the current implementation status
	  of the various AMQP protocol methods in each class.
	</p>
	<methods xmlns="https://www.rabbitmq.com/namespaces/ad-hoc/conformance">
	  <method name="connection.start"><status value="ok"/></method>
	  <method name="connection.start-ok"><status value="ok"/></method>
	  <method name="connection.secure"><status value="ok"/></method>
	  <method name="connection.secure-ok"><status value="ok"/></method>
	  <method name="connection.tune"><status value="ok"/></method>
	  <method name="connection.tune-ok"><status value="ok"/></method>
	  <method name="connection.open"><status value="ok"/></method>
	  <method name="connection.open-ok"><status value="ok"/></method>
	  <method name="connection.close"><status value="ok"/></method>
	  <method name="connection.close-ok"><status value="ok"/></method>
	  <method name="channel.open"><status value="ok"/></method>
	  <method name="channel.open-ok"><status value="ok"/></method>
	  <method name="channel.flow"><status value="partial"/>
            <notes>active=false is not supported by the server. Limiting prefetch with <code>basic.qos</code> provides much better control.</notes>
          </method>
	  <method name="channel.flow-ok"><status value="ok"/></method>
	  <method name="channel.close"><status value="ok"/></method>
	  <method name="channel.close-ok"><status value="ok"/></method>
	  <method name="exchange.declare"><status value="ok"/></method>
	  <method name="exchange.declare-ok"><status value="ok"/></method>
	  <method name="exchange.delete">
            <status value="partial"/>
            <notes>
              We have made exchange.delete into an idempotent assertion that
              the exchange must not exist, in the same way that
              exchange.declare asserts that it must.
            </notes>
          </method>
	  <method name="exchange.delete-ok"><status value="ok"/></method>
	  <method name="queue.declare"><status value="ok"/></method>
	  <method name="queue.declare-ok">
            <status value="ok"/>
              <notes>The consumer-count parameter is the count of all
              consumers, rather than only active consumers, as
              mandated by the specification. The former is more useful
              to applications.</notes>
          </method>
	  <method name="queue.bind"><status value="ok"/></method>
	  <method name="queue.bind-ok"><status value="ok"/></method>
	  <method name="queue.unbind">
            <status value="partial"/>
            <notes>
              We have made queue.unbind into an idempotent assertion that the
              binding must not exist, in the same way that queue.bind asserts
              that it must.
            </notes>
          </method>
	  <method name="queue.unbind-ok"><status value="ok"/></method>
	  <method name="queue.purge"><status value="ok"/></method>
	  <method name="queue.purge-ok"><status value="ok"/></method>
	  <method name="queue.delete">
            <status value="partial"/>
            <notes>
              We have made queue.delete into an idempotent assertion that the
              queue must not exist, in the same way that queue.declare asserts
              that it must.
            </notes>
          </method>
	  <method name="queue.delete-ok"><status value="ok"/></method>
	  <method name="basic.qos">
            <status value="partial"/>
            <notes>The server supports per-consumer and per-channel
            limits. The <code>global</code> flag is given different
            semantics from those in the specification. See <a
            href="consumer-prefetch.html">consumer prefetch</a> for
            more information. Prefetch size limits are not
            implemented.</notes>
          </method>
	  <method name="basic.qos-ok"><status value="ok"/></method>
	  <method name="basic.consume"><status value="partial"/>
            <notes>The no-local parameter is not implemented. The
            value of this parameter is ignored and no attempt is
            made to prevent a consumer from receiving messages that
            were published on the same connection.</notes>
          </method>
	  <method name="basic.consume-ok"><status value="ok"/></method>
	  <method name="basic.cancel"><status value="ok"/></method>
	  <method name="basic.cancel-ok"><status value="ok"/></method>
	  <method name="basic.publish"><status value="ok"/></method>
	  <method name="basic.return"><status value="ok"/></method>
	  <method name="basic.deliver"><status value="ok"/></method>
	  <method name="basic.get"><status value="ok"/></method>
	  <method name="basic.get-ok"><status value="ok"/></method>
	  <method name="basic.get-empty"><status value="ok"/></method>
	  <method name="basic.ack"><status value="ok"/></method>
	  <method name="basic.reject"><status value="partial"/>
            <notes>The server discards the message when requeue=false,
            and requeues it when requeue=true. No attempt is made to
            prevent redelivery to the same client. The server does not
            interrupt the sending of message content of a rejected
            message, i.e. the message is always delivered in full to
            the client.</notes>
          </method>
	  <method name="basic.recover"><status value="partial"/>
            <notes>Recovery with requeue=false is not supported.</notes>
          </method>
	  <method name="tx.select"><status value="ok"/></method>
	  <method name="tx.select-ok"><status value="ok"/></method>
	  <method name="tx.commit"><status value="ok"/></method>
	  <method name="tx.commit-ok"><status value="ok"/></method>
	  <method name="tx.rollback"><status value="ok"/></method>
	  <method name="tx.rollback-ok"><status value="ok"/></method>
	</methods>
      </doc:section>

      <doc:section name="rules">
	<doc:heading>Rules from the AMQP specification, version 0-9-1</doc:heading>
	<p>
	  The Reference column contains the class or domain, method, field and
      rule name where present.
    </p>
	<rules xmlns="https://www.rabbitmq.com/namespaces/ad-hoc/conformance">
          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>delivery-tag / channel-local</xref>
            <type/>
            <actor/>
            <text>
                The delivery tag is valid only within the channel from which the message was
                received. I.e. a client MUST NOT receive a message on one channel and then
                acknowledge it on another.
              </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>delivery-tag / non-zero</xref>
            <type/>
            <actor/>
            <text>
                The server MUST NOT use a zero value for delivery tags. Zero is reserved
                for client use, meaning "all messages so far received".
              </text>
          </rule>

          <rule>
            <status value="ok">does</status>
            <type>SHOULD</type>
            <xref>redelivered / implementation</xref>
            <type/>
            <actor/>
            <text>
                The server SHOULD try to signal redelivered messages when it can. When
                redelivering a message that was not successfully acknowledged, the server
                SHOULD deliver it to the original client if possible.
              </text>
          </rule>

          <rule>
            <status value="planned"/>
            <notes>
                The client already conforms, in that it does not rely on the
                redelivered field, and we plan on adding duplicate tracking in a future
                release.
            </notes>
            <type>MUST NOT</type>
            <xref>redelivered / hinting</xref>
            <type/>
            <actor/>
            <text>
                The client MUST NOT rely on the redelivered field but should take it as a
                hint that the message may already have been processed. A fully robust
                client must be able to track duplicate received messages on non-transacted,
                and locally-transacted channels.
              </text>
          </rule>
          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>connection / start / protocol-name</xref>
            <type/>
            <actor>client</actor>
            <text>
                  If the server cannot support the protocol specified in the protocol header,
                  it MUST respond with a valid protocol header and then close the socket
                  connection.
                </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>connection / start / server-support</xref>
            <type/>
            <actor>client</actor>
            <text>
                  The server MUST provide a protocol version that is lower than or equal to
                  that requested by the client in the protocol header.
                </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>connection / start / client-support</xref>
            <type/>
            <actor>client</actor>
            <text>
                  If the client cannot handle the protocol version suggested by the server
                  it MUST close the socket connection without sending any further data.
                </text>
          </rule>

          <rule>
            <status value="ok">does</status>
            <type>SHOULD</type>
            <xref>connection / start / server-properties / required-fields</xref>
            <type/>
            <actor>client</actor>
            <text>
                    The properties SHOULD contain at least these fields: "host", specifying the
                    server host name or address, "product", giving the name of the server product,
                    "version", giving the name of the server version, "platform", giving the name
                    of the operating system, "copyright", if appropriate, and "information", giving
                    other general information.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>connection / start / locales / required-support</xref>
            <type/>
            <actor>client</actor>
            <text>
                    The server MUST support at least the en_US locale.
                  </text>
          </rule>

          <rule>
            <status value="ok">does</status>
            <type>SHOULD</type>
            <xref>connection / start-ok / client-properties / required-fields</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The properties SHOULD contain at least these fields: "product", giving the name
                    of the client product, "version", giving the name of the client version, "platform",
                    giving the name of the operating system, "copyright", if appropriate, and
                    "information", giving other general information.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>SHOULD</type>
            <xref>connection / start-ok / mechanism / security</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The client SHOULD authenticate using the highest-level security profile it
                    can handle from the list provided by the server.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>connection / start-ok / mechanism / validity</xref>
            <type/>
            <actor>server</actor>
            <text>
                    If the mechanism field does not contain one of the security mechanisms
                    proposed by the server in the Start method, the server MUST close the
                    connection without sending any further data.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>connection / tune / frame-max / minimum</xref>
            <type/>
            <actor>client</actor>
            <text>
                    Until the frame-max has been negotiated, both peers MUST accept frames of up
                    to frame-min-size octets large, and the minimum negotiated value for frame-max
                    is also frame-min-size.
                  </text>
          </rule>

          <rule>
            <status value="planned"/>
            <type>MUST</type>
            <xref>connection / tune-ok / channel-max / upper-limit</xref>
            <type/>
            <actor>server</actor>
            <text>
                    If the client specifies a channel max that is higher than the value provided
                    by the server, the server MUST close the connection without attempting a
                    negotiated close.  The server may report the error in some fashion to assist
                    implementors.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <notes>frame-min-size is 4Kb.</notes>
            <type>MUST</type>
            <xref>connection / tune-ok / frame-max / minimum</xref>
            <type/>
            <actor>server</actor>
            <text>
                    Until the frame-max has been negotiated, both peers MUST accept frames of up
                    to frame-min-size octets large, and the minimum negotiated value for frame-max
                    is also frame-min-size.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>connection / tune-ok / frame-max / upper-limit</xref>
            <type/>
            <actor>server</actor>
            <text>
                    If the client specifies a frame max that is higher than the value provided
                    by the server, the server MUST close the connection without attempting a
                    negotiated close. The server may report the error in some fashion to assist
                    implementors.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>connection / open / virtual-host / separation</xref>
            <type/>
            <actor>server</actor>
            <text>
                    If the server supports multiple virtual hosts, it MUST enforce a full
                    separation of exchanges, queues, and all associated entities per virtual
                    host. An application, connected to a specific virtual host, MUST NOT be able
                    to access resources of another virtual host.
                  </text>
          </rule>

          <rule>
            <status value="ok">does</status>
            <type>SHOULD</type>
            <xref>connection / open / virtual-host / security</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The server SHOULD verify that the client has permission to access the
                    specified virtual host.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>connection / close / stability</xref>
            <type/>
            <actor>client</actor>
            <text>
                  After sending this method, any received methods except Close and Close-OK MUST
                  be discarded.  The response to receiving a Close after sending Close must be to
                  send Close-Ok.
                </text>
          </rule>

          <rule>
            <status value="ok">does</status>
            <notes>Only the server maintains an error log.</notes>
            <type>SHOULD</type>
            <xref>connection / close-ok / reporting</xref>
            <type/>
            <actor>client</actor>
            <text>
                  A peer that detects a socket closure without having received a Close-Ok
                  handshake method SHOULD log the error.
                </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>channel / open / state</xref>
            <type/>
            <actor>server</actor>
            <text>
                  The client MUST NOT use this method on an already-opened channel.
                </text>
          </rule>

          <rule>
            <status value="ok">doesn't</status>
            <type>MAY</type>
            <xref>channel / flow / initial-state</xref>
            <type/>
            <actor>server</actor>
            <text>
                  When a new channel is opened, it is active (flow is active). Some applications
                  assume that channels are inactive until started. To emulate this behaviour a
                  client MAY open the channel, then pause it.
                </text>
          </rule>

          <rule>
	    <status value="failing">doesn't</status>
            <notes>The server does not support blocking flow with active=true. Limiting prefetch with <code>basic.qos</code> provides much better control.</notes>
            <type>SHOULD</type> <xref>channel / flow / bidirectional</xref>
            <type/>
            <actor>server</actor>
            <text>
                  When sending content frames, a peer SHOULD monitor the channel for incoming
                  methods and respond to a Channel.Flow as rapidly as possible.
                </text>
          </rule>

          <rule>
            <status value="ok"/>
            <notes>
              Neither the server or the clients automatically issue a Channel.Flow.
            </notes>
            <type>MAY</type>
            <xref>channel / flow / throttling</xref>
            <type/>
            <actor>server</actor>
            <text>
                  A peer MAY use the Channel.Flow method to throttle incoming content data for
                  internal reasons, for example, when exchanging data over a slower connection.
                </text>
          </rule>

          <rule>
            <status value="ok">doesn't</status>
            <type>MAY</type>
            <xref>channel / flow / expected-behaviour</xref>
            <type/>
            <actor>server</actor>
            <text>
                  The peer that requests a Channel.Flow method MAY disconnect and/or ban a peer
                  that does not respect the request.  This is to prevent badly-behaved clients
                  from overwhelming a server.
                </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>channel / close / stability</xref>
            <type/>
            <actor>client</actor>
            <text>
                  After sending this method, any received methods except Close and Close-OK MUST
                  be discarded.  The response to receiving a Close after sending Close must be to
                  send Close-Ok.
                </text>
          </rule>

          <rule>
            <status value="ok">does</status>
            <type>SHOULD</type>
            <notes>Only the server maintains an error log.</notes>
            <xref>channel / close-ok / reporting</xref>
            <type/>
            <actor>client</actor>
            <text>
                  A peer that detects a socket closure without having received a Channel.Close-Ok
                  handshake method SHOULD log the error.
                </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>exchange / required-types</xref>
            <type/>
            <actor/>
            <text>
                The server MUST implement these standard exchange types: fanout, direct.
              </text>
          </rule>

          <rule>
            <status value="ok">does</status>
            <type>SHOULD</type>
            <xref>exchange / recommended-types</xref>
            <type/>
            <actor/>
            <text>
                The server SHOULD implement these standard exchange types: topic, headers.
              </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>exchange / required-instances</xref>
            <type/>
            <actor/>
            <text>
                The server MUST, in each virtual host, pre-declare an exchange instance
                for each standard exchange type that it implements, where the name of the
                exchange instance, if defined, is "amq." followed by the exchange type name.
              </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>exchange / default-exchange</xref>
            <type/>
            <actor/>
            <text>
                The server MUST pre-declare a direct exchange with no public name to act as
                the default exchange for content Publish methods and for default queue bindings.
              </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>exchange / default-access</xref>
            <type/>
            <actor/>
            <text>
                The server MUST NOT allow clients to access the default exchange except
                by specifying an empty exchange name in the Queue.Bind and content Publish
                methods.
              </text>
          </rule>

          <rule>
            <status value="ok">does</status>
            <type>MAY</type>
            <xref>exchange / extensions</xref>
            <type/>
            <actor/>
            <text>
                The server MAY implement other exchange types as wanted.
              </text>
          </rule>

          <rule>
            <status value="ok">does</status>
            <type>SHOULD</type>
            <xref>exchange / declare / minimum</xref>
            <type/>
            <actor>server</actor>
            <text>
                  The server SHOULD support a minimum of 16 exchanges per virtual host and
                  ideally, impose no limit except as defined by available resources.
                </text>
          </rule>

          <rule>
            <status value="ok"/>
            <notes>
                   The server does not prevent exchange names starting with "amq." from
                   being declared. Clients may declare exchanges starting with "amq."
                   without the passive bit set.
            </notes>
            <type>MUST, MAY</type>
            <xref>exchange / declare / exchange / reserved</xref>
            <type/>
            <actor>server</actor>
            <text>
                    Exchange names starting with "amq." are reserved for pre-declared and
                    standardised exchanges. The client MAY declare an exchange starting with
                    "amq." if the passive option is set, or the exchange already exists.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <notes>
                   The lexicon is not enforced by the server.
            </notes>
            <type>MUST</type>
            <xref>exchange / declare / exchange / syntax</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The exchange name consists of a non-empty sequence of these characters:
                    letters, digits, hyphen, underscore, period, or colon.
                  </text>
          </rule>

          <rule>
            <status value="ok">ok</status>
            <type>MUST</type>
            <xref>exchange / declare / type / typed</xref>
            <type/>
            <actor>server</actor>
            <text>
                    Exchanges cannot be redeclared with different types.  The client MUST not
                    attempt to redeclare an existing exchange with a different type than used
                    in the original Exchange.Declare method.
                  </text>
          </rule>

          <rule>
            <status value="ok">ok</status>
            <type>MUST NOT</type>
            <xref>exchange / declare / type / support</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The client MUST NOT attempt to declare an exchange with a type that the
                    server does not support.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <notes>(refers to the passive flag)</notes>
            <type>MUST</type>
            <xref>exchange / declare / passive / not-found</xref>
            <type/>
            <actor>server</actor>
            <text>
                    If set, and the exchange does not already exist, the server MUST
                    raise a channel exception with reply code 404 (not found).
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <notes>(refers to the passive flag)</notes>
            <type>MUST</type>
            <xref>exchange / declare / passive / equivalent</xref>
            <type/>
            <actor>server</actor>
            <text>
                    If not set and the exchange exists, the server MUST check that the
                    existing exchange has the same values for type, durable, and arguments
                    fields.  The server MUST respond with Declare-Ok if the requested
                    exchange matches these fields, and MUST raise a channel exception if
                    not.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>exchange / declare / durable / support</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The server MUST support both durable and transient exchanges.
                  </text>
          </rule>

          <rule>
            <status value="failing"/>
            <notes>
              We have made exchange.delete into an idempotent assertion that
              the exchange must not exist, in the same way that
              exchange.declare asserts that it must.
            </notes>
            <type>MUST NOT</type>
            <xref>exchange / delete / exchange / exists</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The client MUST NOT attempt to delete an exchange that does not exist.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>exchange / delete / if-unused / in-use</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The server MUST NOT delete an exchange that has bindings on it, if the if-unused
                    field is true.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>queue / declare / default-binding</xref>
            <type/>
            <actor>server</actor>
            <text>
                  The server MUST create a default binding for a newly-declared queue to the
                  default exchange, which is an exchange of type 'direct' and use the queue
                  name as the routing key.
                </text>
          </rule>

          <rule>
            <status value="ok">does</status>
            <type>SHOULD</type>
            <xref>queue / declare / minimum-queues</xref>
            <type/>
            <actor>server</actor>
            <text>
                  The server SHOULD support a minimum of 256 queues per virtual host and ideally,
                  impose no limit except as defined by available resources.
                </text>
          </rule>

          <rule>
            <status value="ok">does</status>
            <type>MAY, MUST</type>
            <xref>queue / declare / queue / default-name</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The queue name MAY be empty, in which case the server MUST create a new
                    queue with a unique generated name and return this to the client in the
                    Declare-Ok method.
                  </text>
          </rule>

          <rule>
            <status value="ok">ok</status>
            <notes>
                   The server does not prevent queue names starting with "amq." from
                   being declared. Clients may declare queues starting with "amq."
                   without the passive bit set.
            </notes>
            <type>MUST</type>
            <xref>queue / declare / queue / reserved</xref>
            <type/>
            <actor>server</actor>
            <text>
                    Queue names starting with "amq." are reserved for pre-declared and
                    standardised queues. The client MAY declare a queue starting with
                    "amq." if the passive option is set, or the queue already exists.
                  </text>
          </rule>

          <rule>
            <status value="ok">does</status>
            <notes>
                   The lexicon is not enforced by the server.
            </notes>
            <type>MAY</type>
            <xref>queue / declare / queue / syntax</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The queue name can be empty, or a sequence of these characters:
                    letters, digits, hyphen, underscore, period, or colon.
                  </text>
          </rule>

          <rule>
            <status value="ok">does</status>
            <type>MAY</type>
            <xref>queue / declare / passive / passive</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The client MAY ask the server to assert that a queue exists without
                    creating the queue if not.  If the queue does not exist, the server
                    treats this as a failure.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <notes>(refers to the passive flag)</notes>
            <type>MUST</type>
            <xref>queue / declare / passive / equivalent</xref>
            <type/>
            <actor>server</actor>
            <text>
                    If not set and the queue exists, the server MUST check that the
                    existing queue has the same values for durable, exclusive, auto-delete,
                    and arguments fields.  The server MUST respond with Declare-Ok if the
                    requested queue matches these fields, and MUST raise a channel exception
                    if not.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>queue / declare / durable / persistence</xref>
            <type/>
            <actor>server</actor>
            <text>The server MUST recreate the durable queue after a restart.</text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>queue / declare / durable / types</xref>
            <type/>
            <actor>server</actor>
            <text>The server MUST support both durable and transient queues.</text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>queue / declare / exclusive / types</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The server MUST support both exclusive (private) and non-exclusive (shared)
                    queues.
                  </text>
          </rule>

          <rule>
            <status value="ok">doesn't</status>
            <type>MAY NOT</type>
            <xref>queue / declare / exclusive / exclusive</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The client MAY NOT attempt to use a queue that was declared as exclusive
                    by another still-open connection.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>queue / declare / auto-delete / pre-existence</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The server MUST ignore the auto-delete field if the queue already exists.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>queue / bind / duplicates</xref>
            <type/>
            <actor>server</actor>
            <text>
                  A server MUST allow ignore duplicate bindings - that is, two or more bind
                  methods for a specific queue, with identical arguments - without treating these
                  as an error.
                </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>queue / bind / unique</xref>
            <type/>
            <actor>server</actor>
            <text>
                  A server MUST not deliver the same message more than once to a queue, even if
                  the queue has multiple bindings that match the message.
                </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>queue / bind / transient-exchange</xref>
            <type/>
            <actor>server</actor>
            <text>
                  The server MUST allow a durable queue to bind to a transient exchange.
                </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>queue / bind / durable-exchange</xref>
            <type/>
            <actor>server</actor>
            <text>
                  Bindings of durable queues to durable exchanges are automatically durable
                  and the server MUST restore such bindings after a server restart.
                </text>
          </rule>

          <rule>
            <status value="ok">does</status>
            <type>SHOULD</type>
            <xref>queue / bind / binding-count</xref>
            <type/>
            <actor>server</actor>
            <text>
                  The server SHOULD support at least 4 bindings per queue, and ideally, impose no
                  limit except as defined by available resources.
                </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>queue / bind / queue / queue-known</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The client MUST either specify a queue name or have previously declared a
                    queue on the same channel
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>queue / bind / queue / must-exist</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The client MUST NOT attempt to bind a queue that does not exist.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>queue / bind / exchange / exchange-existence</xref>
            <type/>
            <actor>server</actor>
            <text>
                    A client MUST NOT be allowed to bind a queue to a non-existent exchange.
                  </text>
          </rule>

          <rule>
            <status value="doesn't"/>
            <type>MUST</type>
            <xref>queue / bind / exchange / default-exchange</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The server MUST accept a blank exchange name to mean the default exchange.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>queue / bind / routing-key / direct-exchange-key-matching</xref>
            <type/>
            <actor>server</actor>
            <text>
                    If a message queue binds to a direct exchange using routing key K and a
                    publisher sends the exchange a message with routing key R, then the message
                    MUST be passed to the message queue if K = R.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>queue / unbind / 01</xref>
            <type/>
            <actor>server</actor>
            <text>If a unbind fails, the server MUST raise a connection exception.</text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>queue / unbind / queue / queue-known</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The client MUST either specify a queue name or have previously declared a
                    queue on the same channel
                  </text>
          </rule>

          <rule>
            <status value="failing"/>
            <notes>
              We have made queue.unbind into an idempotent assertion that the
              binding must not exist, in the same way that queue.bind asserts
              that it must.
            </notes>
            <type>MUST NOT</type>
            <xref>queue / unbind / queue / must-exist</xref>
            <type/>
            <actor>server</actor>
            <text>
              The client MUST NOT attempt to unbind a queue that does not exist.
            </text>
          </rule>

          <rule>
            <status value="failing"/>
            <notes>
              We have made queue.unbind into an idempotent assertion that the
              binding must not exist, in the same way that queue.bind asserts
              that it must.
            </notes>
            <type>MUST NOT</type>
            <xref>queue / unbind / exchange / must-exist</xref>
            <type/>
            <actor>server</actor>
            <text>
              The client MUST NOT attempt to unbind a queue from an exchange that
              does not exist.
            </text>
          </rule>

          <rule>
            <status value="doesn't"/>
            <type>MUST</type>
            <xref>queue / unbind / exchange / default-exchange</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The server MUST accept a blank exchange name to mean the default exchange.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>queue / purge / 02</xref>
            <type/>
            <actor>server</actor>
            <text>
                  The server MUST NOT purge messages that have already been sent to a client
                  but not yet acknowledged.
                </text>
          </rule>

          <rule>
            <status value="ok">doesn't</status>
            <type>MAY</type>
            <xref>queue / purge / 03</xref>
            <type/>
            <actor>server</actor>
            <text>
                  The server MAY implement a purge queue or log that allows system administrators
                  to recover accidentally-purged messages. The server SHOULD NOT keep purged
                  messages in the same storage spaces as the live messages since the volumes of
                  purged messages may get very large.
                </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>queue / purge / queue / queue-known</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The client MUST either specify a queue name or have previously declared a
                    queue on the same channel
                  </text>
          </rule>

          <rule>
            <status value="ok">ok</status>
            <type>MUST NOT</type>
            <xref>queue / purge / queue / must-exist</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The client MUST NOT attempt to purge a queue that does not exist.
                  </text>
          </rule>

          <rule>
            <status value="planned">doesn't</status>
            <type>SHOULD</type>
            <xref>queue / delete / 01</xref>
            <type/>
            <actor>server</actor>
            <text>
                  The server SHOULD use a dead-letter queue to hold messages that were pending on
                  a deleted queue, and MAY provide facilities for a system administrator to move
                  these messages back to an active queue.
                </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>queue / delete / queue / queue-known</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The client MUST either specify a queue name or have previously declared a
                    queue on the same channel
                  </text>
          </rule>

          <rule>
            <status value="failing"/>
            <notes>
              We have made queue.delete into an idempotent assertion that the
              queue must not exist, in the same way that queue.declare asserts
              that it must.
            </notes>
            <type>MUST NOT</type>
            <xref>queue / delete / queue / must-exist</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The client MUST NOT attempt to delete a queue that does not exist.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>queue / delete / if-unused / in-use</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The server MUST NOT delete a queue that has consumers on it, if the if-unused
                    field is true.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>queue / delete / if-empty / not-empty</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The server MUST NOT delete a queue that has messages on it, if the
                    if-empty field is true.
                  </text>
          </rule>

          <rule>
            <status value="ok">does</status>
            <type>SHOULD</type>
            <xref>basic /
               01</xref>
            <type/>
            <actor/>
            <text>
                The server SHOULD respect the persistent property of basic messages and
                SHOULD make a best-effort to hold persistent basic messages on a reliable
                storage mechanism.
              </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>basic / 02</xref>
            <type/>
            <actor/>
            <text>
                The server MUST NOT discard a persistent basic message in case of a queue
                overflow.
              </text>
          </rule>

          <rule>
            <status value="ok">doesn't</status>
            <type>MAY</type>
            <xref>basic / 03</xref>
            <type/>
            <actor/>
            <text>
                The server MAY use the Channel.Flow method to slow or stop a basic message
                publisher when necessary.
              </text>
          </rule>

          <rule>
            <status value="ok">does</status>
            <type>MAY</type>
            <xref>basic / 04</xref>
            <type/>
            <actor/>
            <text>
                The server MAY overflow non-persistent basic messages to persistent
                storage.
              </text>
          </rule>

          <rule>
            <status value="ok">doesn't</status>
            <type>MAY</type>
            <xref>basic / 05</xref>
            <type/>
            <actor/>
            <text>
                The server MAY discard or dead-letter non-persistent basic messages on a
                priority basis if the queue size exceeds some configured limit.
              </text>
          </rule>

          <rule>
            <status value="planned"/>
            <type>MUST</type>
            <xref>basic / 06</xref>
            <type/>
            <actor/>
            <text>
                The server MUST implement at least 2 priority levels for basic messages,
                where priorities 0-4 and 5-9 are treated as two distinct levels.
              </text>
          </rule>

          <rule>
            <status value="ok">doesn't</status>
            <type>MAY</type>
            <xref>basic / 07</xref>
            <type/>
            <actor/>
            <text>
                The server MAY implement up to 10 priority levels.
              </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>basic / 08</xref>
            <type/>
            <actor/>
            <text>
                The server MUST deliver messages of the same priority in order irrespective of
                their individual persistence.
              </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>basic / 09</xref>
            <type/>
            <actor/>
            <text>
                The server MUST support un-acknowledged delivery of Basic content, i.e.
                consumers with the no-ack field set to TRUE.
              </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>basic / 10</xref>
            <type/>
            <actor/>
            <text>
                The server MUST support explicitly acknowledged delivery of Basic content,
                i.e. consumers with the no-ack field set to FALSE.
              </text>
          </rule>

          <rule>
            <status value="ok"/>
            <notes>(refers to prefetch-size)</notes>
            <type>MUST</type>
            <xref>basic / qos / prefetch-size / 01</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The server MUST ignore this setting when the client is not processing any
                    messages - i.e. the prefetch size does not limit the transfer of single
                    messages to a client, only the sending in advance of more messages while
                    the client still has one or more unacknowledged messages.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>basic / qos / prefetch-count / 01</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The server may send less data in advance than allowed by the client's
                    specified prefetch windows but it MUST NOT send more.
                  </text>
          </rule>

          <rule>
            <status value="ok">does</status>
            <type>SHOULD</type>
            <xref>basic / consume / 01</xref>
            <type/>
            <actor>server</actor>
            <text>
                  The server SHOULD support at least 16 consumers per queue, and ideally, impose
                  no limit except as defined by available resources.
                </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>basic / consume / consumer-tag / 01</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The client MUST NOT specify a tag that refers to an existing consumer.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>basic / consume / consumer-tag / 02</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The consumer tag is valid only within the channel from which the
                    consumer was created. I.e. a client MUST NOT create a consumer in one
                    channel and then use it in another.
                  </text>
          </rule>

          <rule>
            <status value="ok">doesn't</status>
            <type>MAY NOT</type>
            <xref>basic / consume / exclusive / 01</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The client MAY NOT gain exclusive access to a queue that already has
                    active consumers.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>basic / cancel / 01</xref>
            <type/>
            <actor>server</actor>
            <text>
                  If the queue does not exist the server MUST ignore the cancel method, so
                  long as the consumer tag is valid for that channel.
                </text>
          </rule>

          <rule>
            <status value="ok">ok</status>
            <type>MUST NOT</type>
            <xref>basic / publish / exchange / must-exist</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The client MUST NOT attempt to publish a content to an exchange that
                    does not exist.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>basic / publish / exchange / default-exchange</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The server MUST accept a blank exchange name to mean the default exchange.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>basic / publish / exchange / 02</xref>
            <type/>
            <actor>server</actor>
            <text>
                    If the exchange was declared as an internal exchange, the server MUST raise
                    a channel exception with a reply code 403 (access refused).
                  </text>
          </rule>

          <rule>
            <status value="ok">doesn't</status>
            <type>MAY</type>
            <xref>basic / publish / exchange / 03</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The exchange MAY refuse basic content in which case it MUST raise a channel
                    exception with reply code 540 (not implemented).
                  </text>
          </rule>

          <rule>
            <status value="ok">does</status>
            <type>SHOULD</type>
            <xref>basic / publish / mandatory / 01</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The server SHOULD implement the mandatory flag.
                  </text>
          </rule>

          <rule>
            <status value="failing">doesn't</status>
            <notes>The server does not support the immediate flag. <a href="ttl.html">message TTLs</a> of 0 offer an alternative.</notes>
            <type>SHOULD</type>
            <xref>basic / publish / immediate / 01</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The server SHOULD implement the immediate flag.
                  </text>
          </rule>

          <rule>
            <status value="planned"/>
            <type>SHOULD</type>
            <xref>basic / deliver / 01</xref>
            <type/>
            <actor>client</actor>
            <text>
                  The server SHOULD track the number of times a message has been delivered to
                  clients and when a message is redelivered a certain number of times - e.g. 5
                  times - without being acknowledged, the server SHOULD consider the message to be
                  unprocessable (possibly causing client applications to abort), and move the
                  message to a dead letter queue.
                </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>basic / ack / multiple / exists</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The server MUST validate that a non-zero delivery-tag refers to a delivered
                    message, and raise a channel exception if this is not the case.  On a transacted
                    channel, this check MUST be done immediately and not delayed until a Tx.Commit.
                    Specifically, a client MUST not acknowledge the same message more than once.
                  </text>
          </rule>

          <rule>
            <status value="planned"/>
            <type>SHOULD</type>
            <xref>basic / reject / 01</xref>
            <type/>
            <actor>server</actor>
            <text>
                  The server SHOULD be capable of accepting and process the Reject method while
                  sending message content with a Deliver or Get-Ok method. I.e. the server should
                  read and process incoming methods while sending output frames. To cancel a
                  partially-send content, the server sends a content body frame of size 1 (i.e.
                  with no data except the frame-end octet).
                </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>SHOULD</type>
            <xref>basic / reject / 02</xref>
            <type/>
            <actor>server</actor>
            <text>
                  The server SHOULD interpret this method as meaning that the client is unable to
                  process the message at this time.
                </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>basic / reject / 03</xref>
            <type/>
            <actor>server</actor>
            <text>
                  The client MUST NOT use this method as a means of selecting messages to process.
                </text>
          </rule>
          <rule>
            <status value="planned"/>
            <type>MUST NOT</type>
            <xref>basic / reject / requeue / 01</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The server MUST NOT deliver the message to the same client within the
                    context of the current channel. The recommended strategy is to attempt to
                    deliver the message to an alternative consumer, and if that is not possible,
                    to move the message to a dead-letter queue. The server MAY use more
                    sophisticated tracking to hold the message on the queue and redeliver it to
                    the same client at a later stage.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>basic / recover-async / 01</xref>
            <type/>
            <actor>server</actor>
            <text>
                  The server MUST set the redelivered flag on all messages that are resent.
                </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>basic / recover / 01</xref>
            <type/>
            <actor>server</actor>
            <text>
                  The server MUST set the redelivered flag on all messages that are resent.
                </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>tx / not multiple queues</xref>
            <type/>
            <actor/>
            <text>
              Applications MUST NOT rely on the atomicity of transactions that
              affect more than one queue.
              </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>tx / not immediate</xref>
            <type/>
            <actor/>
            <text>
              Applications MUST NOT rely on the behaviour of transactions that
              include messages published with the immediate option.
              </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>tx / not mandatory</xref>
            <type/>
            <actor/>
            <text>
              Applications MUST NOT rely on the behaviour of transactions that
              include messages published with the mandatory option.
              </text>
          </rule>

          <rule>
            <status value="ok">ok</status>
            <type>MUST NOT</type>
            <xref>tx / commit / transacted</xref>
            <type/>
            <actor>server</actor>
            <text>
                  The client MUST NOT use the Commit method on non-transacted channels.
                </text>
          </rule>

          <rule>
            <status value="ok">ok</status>
            <type>MUST NOT</type>
            <xref>tx / rollback / transacted</xref>
            <type/>
            <actor>server</actor>
            <text>
                  The client MUST NOT use the Rollback method on non-transacted channels.
                </text>
          </rule>
        </rules>
      </doc:section>

      <doc:section name="rules-pdf">
        <doc:heading>Rules from the AMQP specification, version 0-9-1 (PDF)</doc:heading>
        <p>
          The rules listed below are from the PDF version of the 0-9-1 specification,
          wherever MUST, SHOULD or MAY appear in the text.
        </p>
        <rules xmlns="https://www.rabbitmq.com/namespaces/ad-hoc/conformance">
	  <rule>
	    <status value="ok">does, doesn't</status>
        <notes>
        Property names, method arguments, and frame fields legitimately appear as
        camel-case in some contexts.
        </notes>
	    <xref> 1.4.1 </xref>
	    <context>
	    </context>
	    <type>
	      SHOULD, SHOULD
	    </type>
	    <actor>
	    </actor>
	    <text>
          Protocol constants are shown as upper-case names. AMQP implementations SHOULD
          use these names when defining and using constants in source code and documentation.
	      Property names, method arguments, and frame fields are shown as lower-case names.
          AMQP implementations SHOULD use these names consistently in source code and
          documentation.
	    </text>
	  </rule>

	  <rule>
	    <status value="ok"></status>
	    <xref> 2.2.4 </xref>
	    <context>
	    </context>
	    <type>
	      MUST
	    </type>
	    <actor>
	    </actor>
	    <text>
          There is no hand-shaking for errors on connections that are not fully
          open. Following successful protocol header negotiation, [...] and prior to
          sending or receiving Open or Open-Ok, a peer that detects an error MUST
          close the socket without sending any further data.
	    </text>
	  </rule>

	  <rule>
	    <status value="ok">does</status>
        <notes>The server supports 0-8, 0-9 and 0-9-1 on the same port.</notes>
	    <xref> 2.3.3 </xref>
	    <context>
	    </context>
	    <type>
	      MAY
	    </type>
	    <actor>
	    </actor>
	    <text>
         The server MAY host multiple protocols on the same port.
	    </text>
	  </rule>

	  <rule>
	    <status value="ok">doesn't</status>
	    <xref> 2.3.3 </xref>
	    <context>
	    </context>
	    <type>
	      MAY
	    </type>
	    <actor>
	    </actor>
	    <text>
	      Agreed limits MAY enable both parties to pre-allocate key buffers, avoiding deadlocks.
	    </text>
	  </rule>

	  <rule>
	    <status value="ok"></status>
	    <xref> 2.3.3 </xref>
	    <context>
	    </context>
	    <type>
	      MUST
	    </type>
	    <actor>
	    </actor>
	    <text>
          Every incoming frame either obeys the agreed limits, and so is "safe",
          or exceeds them, in which case the other party IS faulty and MUST be disconnected.
	    </text>
	  </rule>

	  <rule>
	    <status value="ok"></status>
	    <xref> 2.3.3 </xref>
	    <context>
	    </context>
	    <type>
	      MUST
	    </type>
	    <actor>
	    </actor>
	    <text>
	      The server MUST tell the client what limits it proposes.
	    </text>
	  </rule>

	  <rule>
	    <status value="ok">doesn't</status>
	    <xref> 2.3.3 </xref>
	    <context>
	    </context>
	    <type>
	      MAY
	    </type>
	    <actor>
	    </actor>
	    <text>
	     The client responds and MAY reduce those limits for its connection.
	    </text>
	  </rule>

	  <rule>
	    <status value="ok">does</status>
	    <xref> 2.3.5.2 </xref>
	    <context>
	    </context>
	    <type>
	      MAY
	    </type>
	    <actor>
	    </actor>
	    <text>
          The data [for content frames] can be any size, and MAY be broken into
          several (or many) chunks, each forming a "content body frame".
	    </text>
	  </rule>

	  <rule>
	    <status value="ok"></status>
	    <xref> 2.3.7 </xref>
	    <context>
	    </context>
	    <type>
	      MUST, MUST
	    </type>
	    <actor>
	    </actor>
	    <text>
         A connection or channel is considered â€œopenâ€ for the client when it has sent Open,
         and for the server when it has sent Open-Ok. From this point onwards a peer that
         wishes to close the channel or connection MUST do so using a hand-shake protocol [...].
         When a peer decides to close a channel or connection, it sends a Close method.
         The receiving peer MUST respond to a Close with a Close-Ok, and then both parties
         can close their channel or connection.
	    </text>
	  </rule>

	  <rule>
	    <status value="failing">does</status>
        <notes>
         "BCC" headers are removed from properties after routing.
        </notes>
	    <xref> 3.1.1 </xref>
	    <context>
	    </context>
	    <type>
	      MUST NOT, MUST NOT
	    </type>
	    <actor>
	    </actor>
	    <text>
         The server MUST NOT modify message content bodies that it receives and passes to consumer
         applications.  [...] [The server] MUST NOT remove or modify existing information.
	    </text>
	  </rule>

	  <rule>
	    <status value="ok">doesn't</status>
	    <xref> 3.1.1 </xref>
	    <context>
	    </context>
	    <type>
	      MAY
	    </type>
	    <actor>
	    </actor>
	    <text>
         The server MAY add information to content headers [...]
	    </text>
	  </rule>

	  <rule>
	    <status value="ok"></status>
	    <xref> 3.1.2 </xref>
	    <context>
	    </context>
	    <type>
	      MUST
	    </type>
	    <actor>
	    </actor>
	    <text>
         Each connection MUST BE associated with a single virtual host.
	    </text>
	  </rule>

	  <rule>
	    <status value="ok">doesn't</status>
	    <xref> 3.1.2 </xref>
	    <context>
	    </context>
	    <type>
	      MAY
	    </type>
	    <actor>
	    </actor>
	    <text>
         [The] authorisation scheme used MAY be unique to each virtual host.
	    </text>
	  </rule>

	  <rule>
	    <status value="ok"></status>
	    <xref> 3.1.3.1 </xref>
	    <context>
	    </context>
	    <type>
	      MUST, MUST
	    </type>
	    <actor>
	    </actor>
	    <text>
         The server MUST implement the direct exchange type and MUST pre-declare within
         each virtual host at least two direct exchanges: one named amq.direct, and one
         with no public name that serves as the default exchange for Publish methods.
         [...] [All] message queues MUST BE automatically bound to the nameless exchange
         using the message queue's name as routing key.
	    </text>
	  </rule>

	  <rule>
	    <status value="ok"></status>
	    <xref> 3.1.3.3 </xref>
	    <context>
	    </context>
	    <type>
	      MUST
	    </type>
	    <actor>
	    </actor>
	    <text>
         The routing key used for a topic exchange MUST consist of zero or more words delimited
         by dots.
	    </text>
	  </rule>


	  <rule>
	    <status value="ok">does, ok</status>
	    <xref> 3.1.3.3 </xref>
	    <context>
	    </context>
	    <type>
	      SHOULD, MUST
	    </type>
	    <actor>
	    </actor>
	    <text>
        The server SHOULD implement the topic exchange type and in that case, the server
        MUST pre-declare within each virtual host at least one topic exchange, named amq.topic.
	    </text>
	  </rule>

	  <rule>
	    <status value="ok">does, ok</status>
	    <xref> 3.1.3.4 </xref>
	    <context>
	    </context>
	    <type>
	      SHOULD, MUST
	    </type>
	    <actor>
	    </actor>
	    <text>
        The server SHOULD implement the headers exchange type and in that case, the server
        MUST pre-declare within each virtual host at least one headers exchange, named amq.match.
	    </text>
	  </rule>

	  <rule>
	    <status value="ok"></status>
	    <xref> 3.1.3.4 </xref>
	    <context>
	    </context>
	    <type>
	      MUST
	    </type>
	    <actor>
	    </actor>
	    <text>
        All non-normative exchange types MUST be named starting with "x-".
	    </text>
	  </rule>

	  <rule>
	    <status value="ok">does</status>
        <notes>
         FIFO characteristics are guaranteed under the conditions specified
         in section 4.7.
        </notes>
	    <xref> 3.1.4 </xref>
	    <context>
	    </context>
	    <type>
	      MAY NOT
	    </type>
	    <actor>
	    </actor>
	    <text>
        Note that in the presence of multiple readers from a queue, or client transactions,
        or use of priority fields, or use of message selectors, or implementation-specific
        delivery optimisations the queue MAY NOT exhibit true FIFO characteristics.
	    </text>
	  </rule>

	  <rule>
	    <status value="ok"></status>
	    <xref> 3.1.10 </xref>
	    <context>
	    </context>
	    <type>
	      MUST
	    </type>
	    <actor>
	    </actor>
	    <text>
        The server and client MUST respect [the specified naming] conventions
	    </text>
	  </rule>

	  <rule>
	    <status value="ok">does</status>
	    <xref> 3.2.1 </xref>
	    <context>
	    </context>
	    <type>
	      SHOULD
	    </type>
	    <actor>
	    </actor>
	    <text>
        The AMQP methods may define specific minimal values (such as numbers
        of consumers per message queue) for interoperability reasons. These
        minima are defined in the description of each class.  Conforming AMQP
        implementations SHOULD implement reasonably generous values for such
        fields, the minima is only intended for use on the least capable platforms.
	    </text>
	  </rule>

	  <rule>
	    <status value="ok">does, doesn't</status>
	    <xref> 3.2.1 </xref>
	    <context>
	    </context>
	    <type>
	      SHOULD, MAY
	    </type>
	    <actor>
	    </actor>
	    <text>
          The sending peer SHOULD wait for the specific reply method
          [after sending a synchronous request], but MAY implement this asynchronously
	    </text>
	  </rule>

	  <rule>
	    <status value="ok"></status>
	    <xref> 4.2.2 </xref>
	    <context>
	    </context>
	    <type>
	      MUST
	    </type>
	    <actor>
	    </actor>
	    <text>
          The client MUST start a new connection by sending a protocol header.
	    </text>
	  </rule>

	  <rule>
	    <status value="ok">doesn't</status>
        <notes>
        The core broker accepts only AMQP. Plugins exist for other protocols.
        </notes>
	    <xref> 4.2.2 </xref>
	    <context>
	    </context>
	    <type>
	      MAY
	    </type>
	    <actor>
	    </actor>
	    <text>
        The server MAY accept non-AMQP protocols such as HTTP.
	    </text>
	  </rule>

	  <rule>
	    <status value="ok"></status>
	    <xref> 4.2.2 </xref>
	    <context>
	    </context>
	    <type>
	      MUST
	    </type>
	    <actor>
	    </actor>
	    <text>
        If the server does not recognise the first 5 octets of data on the socket,
        or does not support the specific protocol version that the client requests,
        it MUST write a valid protocol header to the socket, then flush the socket
        (to ensure the client application will receive the data) and then close the
        socket connection.
	    </text>
	  </rule>

	  <rule>
	    <status value="ok">does</status>
        <notes>
         Relevant information will be written to the server log.
        </notes>
	    <xref> 4.2.2 </xref>
	    <context>
	    </context>
	    <type>
	      MAY
	    </type>
	    <actor>
	    </actor>
	    <text>
         The server MAY print a diagnostic message [during failed protocol negotiation]
         to assist debugging.
	    </text>
	  </rule>

	  <rule>
	    <status value="ok">doesn't</status>
	    <xref> 4.2.2 </xref>
	    <context>
	    </context>
	    <type>
	      MAY
	    </type>
	    <actor>
	    </actor>
	    <text>
        The client MAY detect the server protocol version by attempting to connect with
        its highest supported version and reconnecting with a lower version if it receives
        such information back from the server.
	    </text>
	  </rule>

	  <rule>
	    <status value="ok"></status>
	    <xref> 4.2.3 </xref>
	    <context>
	    </context>
	    <type>
	      MUST
	    </type>
	    <actor>
	    </actor>
	    <text>
         The frame-end octet MUST always be the hexadecimal value %xCE.
	    </text>
	  </rule>

	  <rule>
	    <status value="ok"></status>
	    <xref> 4.2.3 </xref>
	    <context>
	    </context>
	    <type>
	      MUST, MUST, MUST
	    </type>
	    <actor>
	    </actor>
	    <text>
        If a peer receives a frame with a type that is not one of these defined types,
        it MUST treat this as a fatal protocol error and close the connection without
        sending any further data on it.
        When a peer reads a frame it MUST check that the frame-end is valid before
        attempting to decode the frame. If the frame-end is not valid it MUST treat
        this as a fatal protocol error and close the connection without sending any
        further data on it.
	    </text>
	  </rule>

	  <rule>
	    <status value="ok">does</status>
	    <xref> 4.2.3 </xref>
	    <context>
	    </context>
	    <type>
	      SHOULD
	    </type>
	    <actor>
	    </actor>
	    <text>
         It SHOULD log information about the [frame decoding] problem, since this
         indicates an error in either the server or client framing code implementation.
	    </text>
	  </rule>

	  <rule>
	    <status value="ok"></status>
	    <xref> 4.2.3 </xref>
	    <context>
	    </context>
	    <type>
	      MUST NOT, MUST, MUST, MUST, MUST
	    </type>
	    <actor>
	    </actor>
	    <text>
        A peer MUST NOT send frames larger than the agreed-upon size.
        A peer that receives an oversized frame MUST signal a connection
        exception with reply code 501 (frame error).  The channel number
        MUST be zero for all heartbeat frames, and for method, header
        and body frames that refer to the Connection class. A peer that
        receives a non-zero channel number for one of these frames MUST
        signal a connection exception with reply code 503 (command invalid).
	    </text>
	  </rule>

	  <rule>
	    <status value="ok"></status>
	    <xref> 4.2.5.1 </xref>
	    <context>
	    </context>
	    <type>
	      MUST NOT
	    </type>
	    <actor>
	    </actor>
	    <text>
         Implementers MUST NOT assume that integers encoded in a frame are
         aligned on memory word boundaries.
	    </text>
	  </rule>

	  <rule>
	    <status value="ok"></status>
	    <xref> 4.2.5.5 </xref>
	    <context>
	    </context>
	    <type>
	      MUST
	    </type>
	    <actor>
	    </actor>
	    <text>
         Field names MUST start with a letter, '$' or '#' [...]
	    </text>
	  </rule>

	  <rule>
	    <status value="ok">doesn't, doesn't</status>
	    <xref> 4.2.5.5 </xref>
	    <context>
	    </context>
	    <type>
	      SHOULD, SHOULD
	    </type>
	    <actor>
	    </actor>
	    <text>
         The server SHOULD validate field names and upon receiving an
         invalid field name, it SHOULD signal a connection exception
         with reply code 503 (syntax error).
	    </text>
	  </rule>

	  <rule>
	    <status value="planned"></status>
        <notes>
         The given reply code is not returned for all possible ways in
         which content can be badly-formatted.
        </notes>
	    <xref> 4.2.6 </xref>
	    <context>
	    </context>
	    <type>
	      MUST
	    </type>
	    <actor>
	    </actor>
	    <text>
         A peer that receives an incomplete or badly-formatted content
         MUST raise a connection exception with reply code 505 (unexpected frame).
	    </text>
	  </rule>

	  <rule>
	    <status value="ok"></status>
	    <xref> 4.2.6.1 </xref>
	    <context>
	    </context>
	    <type>
	      MUST, MUST
	    </type>
	    <actor>
	    </actor>
	    <text>
         The class-id [of the content header] MUST match the method frame class id.
         The peer MUST respond to an invalid class-id by raising a connection
         exception with reply code 501 (frame error).
	    </text>
	  </rule>

	  <rule>
	    <status value="ok"></status>
	    <xref> 4.2.6.1 </xref>
	    <context>
	    </context>
	    <type>
	      MUST NOT, MUST
	    </type>
	    <actor>
	    </actor>
	    <text>
        The channel number in content frames MUST NOT be zero.
        A peer that receives a zero channel number in a content
        frame MUST signal a connection exception with reply code 504 (channel error).
	    </text>
	  </rule>

	  <rule>
	    <status value="ok"></status>
	    <xref> 4.2.6.2 </xref>
	    <context>
	    </context>
	    <type>
	      MUST
	    </type>
	    <actor>
	    </actor>
	    <text>
        A peer MUST handle a content body that is split into multiple frames by
        storing these frames as a single set, and either retransmitting them as-is,
        broken into smaller frames, or concatenated into a single block for delivery
        to an application.
	    </text>
	  </rule>

	  <rule>
	    <status value="ok"></status>
	    <xref> 4.2.6.2 </xref>
	    <context>
	    </context>
	    <type>
	      MUST
	    </type>
	    <actor>
	    </actor>
	    <text>
        Heartbeat frames MUST have a channel number of zero.
	    </text>
	  </rule>

	  <rule>
	    <status value="ok"></status>
        <notes>
        The broker and supported clients do support heartbeat frames.
        </notes>
	    <xref> 4.2.7 </xref>
	    <context>
	    </context>
	    <type>
	      MUST
	    </type>
	    <actor>
	    </actor>
	    <text>
         If the peer does not support heartbeating it MUST discard
         the heartbeat frame without signalling any error or fault.
	    </text>
	  </rule>

	  <rule>
	    <status value="ok">does, doesn't</status>
	    <xref> 4.3 </xref>
	    <context>
	    </context>
	    <type>
	      MAY, MAY
	    </type>
	    <actor>
	    </actor>
	    <text>
         An AMQP peer MAY support multiple channels.
         The maximum number of channels is defined at connection negotiation,
         and a peer MAY negotiate this down to 1.
	    </text>
	  </rule>

	  <rule>
	    <status value="ok">does, doesn't</status>
	    <xref> 4.3 </xref>
	    <context>
	    </context>
	    <type>
	      SHOULD, SHOULD NOT
	    </type>
	    <actor>
	    </actor>
	    <text>
        Each peer SHOULD balance the traffic on all open channels
        in a fair fashion. This balancing can be done on a per-frame
        basis, or on the basis of amount of traffic per channel.
        A peer SHOULD NOT allow one very busy channel to starve
        the progress of a less busy channel.
	    </text>
	  </rule>

	  <rule>
	    <status value="ok"></status>
	    <xref> 4.6 </xref>
	    <context>
	    </context>
	    <type>
	      MUST NOT, MUST
	    </type>
	    <actor>
	    </actor>
	    <text>
        The effects of the request-response MUST NOT be visible on the
        channel before the response method, and MUST be visible thereafter.
	    </text>
	  </rule>

	  <rule>
	    <status value="ok"></status>
        <notes>
        The broker makes <a href="semantics.html#ordering">stronger
        guarantees</a>.
        </notes>
	    <xref> 4.7 </xref>
	    <context>
	    </context>
	    <type>
	      MUST
	    </type>
	    <actor>
	    </actor>
	    <text>
        The server MUST preserve the order of contents flowing through a
        single content processing path, unless the redelivered field is
        set on the Basic.Deliver or Basic.Get-Ok methods, and according to the
        rules governing the conditions under which that field can be set.
	    </text>
	  </rule>

	  <rule>
	    <status value="ok">does</status>
	    <xref> 4.10.2 </xref>
	    <context>
	    </context>
	    <type>
	      SHOULD
	    </type>
	    <actor>
	    </actor>
	    <text>
        The server SHOULD log all [exceptions during connection negotiation stage] and flag or block
        clients provoking multiple failures.
	    </text>
	  </rule>

        </rules>
      </doc:section>

      <doc:section name="rules-08">
        <doc:heading>Rules from the AMQP specification, version 0-8</doc:heading>
        <p>
          The rules listed below relate to features supported by RabbitMQ that
          have been deprecated.
        </p>
        <rules xmlns="https://www.rabbitmq.com/namespaces/ad-hoc/conformance">
          <rule>
            <status value="ok">doesn't</status>
            <xref>
            </xref>
            <context>
              method/connection/redirect
            </context>
            <type>
              SHOULD
            </type>
            <actor>
              client
            </actor>
            <text>
              When getting the Connection.Redirect method, the client SHOULD reconnect to the host specified, and if that host is not present, to any of the hosts specified in the known-hosts list.
            </text>
          </rule>
          <rule>
            <status value="ok">doesn't</status>
            <xref>
            </xref>
            <context>
              method/connection/redirect
            </context>
            <type>
              SHOULD
            </type>
            <actor>
              client
            </actor>
            <text>
              When getting the Connection.Redirect method, the client SHOULD reconnect to the host specified, and if that host is not present, to any of the hosts specified in the known-hosts list.
            </text>
          </rule>
          <rule>
            <status value="ok">does</status>
            <xref>
            </xref>
            <context>
              domain/known hosts
            </context>
            <type>
              MAY
            </type>
            <actor>
              server
            </actor>
            <text>
              The server MAY leave this field empty if it knows of no other hosts than itself.
            </text>
          </rule>
        </rules>
      </doc:section>
  </body>
</html>
