<?xml-stylesheet type="text/xml" href="page.xsl"?>
<html xmlns:doc="http://www.rabbitmq.com/namespaces/ad-hoc/doc">
  <head>
    <title>RabbitMQ - Specification</title>
  </head>
  <body>
    <doc:div>
      <h2>Compatibility and Conformance</h2>

      <doc:toc class="compact">
	<doc:heading>Table of Contents</doc:heading>
      </doc:toc>
      <doc:section name="spec">
  <p>
  The AMQP specification is open and free to all users and implementers.
  RabbitMQ implements version 0-9-1 of the specification today,
  with legacy support for version 0-8 and 0-9.  RabbitMQ will perform protocol
  negotiation with clients implementing 0-9-1, 0-9 and 0-8, in accordance
  with the specification.
  </p>
  <p>
  The RabbitMQ team is an active participant in the AMQP Working Group,
  which aims to deliver an implementable AMQP 1.0 draft this year.  A
  future version of RabbitMQ will implement AMQP 1.0.  Please 
  <a href="mailto:info@rabbitmq.com">contact us</a> for details, or 
  <a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo">ask on the 
  mailing list</a>.  You can also read about <a href="http://jira.amqp.org/confluence/display/AMQP/AMQP%2B1-0%2BBusiness%2BRequirements">the 1.0 business requirements</a> or view a
  <a href="/resources/f2f-overview12.ppt">1-0 public review presentation</a> (PPT) or an <a href="/resources/AMQPF2FPresentation.pdf">introduction to the
1-0 Draft</a> (PDF).
	</p>
        <p>
          The 0-9-1, 0-9 and 0-8 specifications are linked to below for
          your convenience.  We recommend reading them if you want to
          learn more about AMQP.  Please see our <a
          href="documentation.html">Documentation</a> and <a
          href="how.html">Getting Started</a> pages for more information.
          Or, you can visit <a
          href="http://www.amqp.org/">amqp.org</a>.
	</p>
      </doc:section>
      
      <doc:section name="release-version-mapping">
	<doc:heading>Specification versions supported</doc:heading>
	<p>
	  The following table describes the version of the <a
	  href="http://jira.amqp.org/confluence/display/AMQP/Download">AMQP
	  protocol specification</a> implemented by each RabbitMQ
	  release:
	</p>

	<table>
	  <tr>
	    <th>RabbitMQ versions through</th>
	    <th>implement AMQP protocol version</th>
	  </tr>
	  <tr>
	    <td>(present release) (server when connected to a 0-9-1 client)</td>
	    <td>
	      0-9-1 (<a
	      href="https://www.amqp.org/confluence/download/attachments/720900/amqp0-9-1.pdf">core
	      spec</a>, <a
	      href="https://www.amqp.org/confluence/download/attachments/720900/amqp-xml-doc0-9-1.pdf">class
	      def pdf</a>, <a
	      href="https://www.amqp.org/confluence/download/attachments/720900/amqp0-9-1.xml">class
	      def xml</a>)
	    </td>
	  </tr>
	  <tr>
	    <td>(present release) (server when connected to a 0-9 client)</td>
	    <td>
	      0-9 (<a
	      href="https://www.amqp.org/confluence/download/attachments/720900/amqp0-9.pdf">core
	      spec</a>, <a
	      href="https://www.amqp.org/confluence/download/attachments/720900/amqp-xml-doc0-9.pdf">class
	      def pdf</a>, <a
	      href="https://www.amqp.org/confluence/download/attachments/720900/amqp0-9.xml">class
	      def xml</a>)
	    </td>
	  </tr>
	  <tr>
	    <td>(present release) (server when connected to a 0-8 client)</td>
	    <td>
	      0-8 (<a
	      href="https://www.amqp.org/confluence/download/attachments/720900/amqp0-8.pdf">core
	      spec</a>, <a
	      href="https://www.amqp.org/confluence/download/attachments/720900/amqp-xml-doc0-8.pdf">class
	      def pdf</a>, <a
	      href="https://www.amqp.org/confluence/download/attachments/720900/amqp0-8.xml">class
	      def xml</a>)
	    </td>
	  </tr>
	  <tr>
	    <td>(present release) (Java client)</td>
	    <td>0-9-1</td>
	  </tr>
	  <tr>
	    <td>(present release) (.NET/C# client ONLY)</td>
	    <td>
	      0-9-1, 0-9 and 0-8 switchable at runtime
	    </td>
	  </tr>
	</table>
      </doc:section>

      <doc:section name="interop">
	<doc:heading>Interoperability</doc:heading>
	<p>
	  Please see the <a href="interoperability.html">interoperability page</a>.
	</p>
      </doc:section>

      <doc:section name="deprecated-classes">
	<doc:heading>Deprecated classes</doc:heading>
    <p>
      The following classes were deprecated in version 0-9-1. 
      RabbitMQ does not implement these classes at all, including 
      when the broker is connected to a version 0-8 client, or 
      when the .NET client is configured to use 0-8.
    </p>
      <table>
       <tr>
        <td>access</td>
        <td>dtx</td>
        <td>file</td>
        <td>stream</td>
        <td>test</td>
        <td>tunnel</td>
       </tr>
      </table>
	<p>
	  See also the detailed specification compatibility tables
	  below. Backwards-compatible support for the access.request 
      method as a no-op will be removed in the near future and
      should not be relied on.
	</p>
      </doc:section>

      <doc:section name="classes">
	<doc:heading>Classes from the AMQP specification, version 0-9-1</doc:heading>
	<p>
	  The following table describes the current implementation status
	  of the various AMQP protocol message classes.
	</p>
	<classes xmlns="http://www.rabbitmq.com/namespaces/ad-hoc/conformance">
	  <class name="connection" handler="connection" index="10"><status value="ok"/></class>
	  <class name="channel" handler="channel" index="20"><status value="ok"/></class>
	  <class name="exchange" handler="channel" index="40"><status value="ok"/></class>
	  <class name="queue" handler="channel" index="50"><status value="ok"/></class>
	  <class name="basic" handler="channel" index="60"><status value="ok"/></class>
	  <class name="tx" handler="channel" index="90"><status value="ok"/></class>
	</classes>
      </doc:section>

      <doc:section name="methods">
	<doc:heading>Methods from the AMQP specification, version 0-9-1</doc:heading>
	<p>
	  The following table describes the current implementation status
	  of the various AMQP protocol methods in each class.
	</p>
	<methods xmlns="http://www.rabbitmq.com/namespaces/ad-hoc/conformance">
	  <method name="connection.start"><status value="ok"/></method>
	  <method name="connection.start-ok"><status value="ok"/></method>
	  <method name="connection.secure">
	    <status value="ok"/>
	    <notes>We also plan to implement further authentication methods.</notes>
	  </method>
	  <method name="connection.secure-ok"><status value="ok"/></method>
	  <method name="connection.tune"><status value="ok"/></method>
	  <method name="connection.tune-ok"><status value="ok"/></method>
	  <method name="connection.open"><status value="ok"/></method>
	  <method name="connection.open-ok"><status value="ok"/></method>
	  <method name="connection.redirect">
            <status value="deprecated"/>
            <notes>This method has been deprecated, but is still supported.
            Support will be withdrawn in a future release.
            </notes>
      </method>
	  <method name="connection.close"><status value="ok"/></method>
	  <method name="connection.close-ok"><status value="ok"/></method>
	  <method name="channel.open"><status value="ok"/></method>
	  <method name="channel.open-ok"><status value="ok"/></method>
	  <method name="channel.flow"><status value="ok"/></method>
	  <method name="channel.flow-ok"><status value="ok"/></method>
	  <method name="channel.close"><status value="ok"/></method>
	  <method name="channel.close-ok"><status value="ok"/></method>
	  <method name="exchange.declare"><status value="ok"/></method>
	  <method name="exchange.declare-ok"><status value="ok"/></method>
	  <method name="exchange.delete"><status value="ok"/></method>
	  <method name="exchange.delete-ok"><status value="ok"/></method>
	  <method name="queue.declare"><status value="ok"/></method>
	  <method name="queue.declare-ok"><status value="ok"/></method>
	  <method name="queue.bind"><status value="ok"/></method>
	  <method name="queue.bind-ok"><status value="ok"/></method>
	  <method name="queue.unbind"><status value="ok"/></method>
	  <method name="queue.unbind-ok"><status value="ok"/></method>
	  <method name="queue.purge"><status value="ok"/></method>
	  <method name="queue.purge-ok"><status value="ok"/></method>
	  <method name="queue.delete"><status value="ok"/></method>
	  <method name="queue.delete-ok"><status value="ok"/></method>
	  <method name="basic.qos">
            <status value="partial"/>
            <notes>The server supports non-global prefetch count
            limits; global limits and prefetch size limits are not
            implemented.</notes>
          </method>
	  <method name="basic.qos-ok"><status value="partial"/></method>
	  <method name="basic.consume"><status value="ok"/></method>
	  <method name="basic.consume-ok"><status value="ok"/></method>
	  <method name="basic.cancel"><status value="ok"/></method>
	  <method name="basic.cancel-ok"><status value="ok"/></method>
	  <method name="basic.publish"><status value="ok"/></method>
	  <method name="basic.return"><status value="ok"/></method>
	  <method name="basic.deliver"><status value="ok"/></method>
	  <method name="basic.get"><status value="ok"/></method>
	  <method name="basic.get-ok"><status value="ok"/></method>
	  <method name="basic.get-empty"><status value="ok"/></method>
	  <method name="basic.ack"><status value="ok"/></method>
	  <method name="basic.reject"><status value="planned"/></method>
	  <method name="basic.recover"><status value="ok"/></method>
	  <method name="tx.select"><status value="ok"/></method>
	  <method name="tx.select-ok"><status value="ok"/></method>
	  <method name="tx.commit"><status value="ok"/></method>
	  <method name="tx.commit-ok"><status value="ok"/></method>
	  <method name="tx.rollback"><status value="ok"/></method>
	  <method name="tx.rollback-ok"><status value="ok"/></method>
	</methods>
      </doc:section>

      <doc:section name="rules">
	<doc:heading>Rules from the AMQP specification, version 0-9-1</doc:heading>
	<p>
	  The Reference column contains the class or domain, method, field and 
      rule name where present.
	</p>
	<rules xmlns="http://www.rabbitmq.com/namespaces/ad-hoc/conformance">
          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>delivery-tag / channel-local</xref>
            <type/>
            <actor/>
            <text>
                The delivery tag is valid only within the channel from which the message was
                received. I.e. a client MUST NOT receive a message on one channel and then
                acknowledge it on another.
              </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>delivery-tag / non-zero</xref>
            <type/>
            <actor/>
            <text>
                The server MUST NOT use a zero value for delivery tags. Zero is reserved
                for client use, meaning "all messages so far received".
              </text>
          </rule>

          <rule>
            <status value="ok">does</status>
            <type>SHOULD</type>
            <xref>redelivered / implementation</xref>
            <type/>
            <actor/>
            <text>
                The server SHOULD try to signal redelivered messages when it can. When
                redelivering a message that was not successfully acknowledged, the server
                SHOULD deliver it to the original client if possible.
              </text>
          </rule>

          <rule>
            <status value="planned"/>
            <notes>
                The client already conforms, in that it does not rely on the 
                redelivered field, and we plan on adding duplicate tracking in a future 
                release.
            </notes>
            <type>MUST NOT</type>
            <xref>redelivered / hinting</xref>
            <type/>
            <actor/>
            <text>
                The client MUST NOT rely on the redelivered field but should take it as a
                hint that the message may already have been processed. A fully robust
                client must be able to track duplicate received messages on non-transacted,
                and locally-transacted channels.
              </text>
          </rule>
          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>connection / start / protocol-name</xref>
            <type/>
            <actor>client</actor>
            <text>
                  If the server cannot support the protocol specified in the protocol header,
                  it MUST respond with a valid protocol header and then close the socket
                  connection.
                </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>connection / start / server-support</xref>
            <type/>
            <actor>client</actor>
            <text>
                  The server MUST provide a protocol version that is lower than or equal to
                  that requested by the client in the protocol header.
                </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>connection / start / client-support</xref>
            <type/>
            <actor>client</actor>
            <text>
                  If the client cannot handle the protocol version suggested by the server
                  it MUST close the socket connection without sending any further data.
                </text>
          </rule>

          <rule>
            <status value="ok">does</status>
            <type>SHOULD</type>
            <xref>connection / start / server-properties / required-fields</xref>
            <type/>
            <actor>client</actor>
            <text>
                    The properties SHOULD contain at least these fields: "host", specifying the
                    server host name or address, "product", giving the name of the server product,
                    "version", giving the name of the server version, "platform", giving the name
                    of the operating system, "copyright", if appropriate, and "information", giving
                    other general information.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>connection / start / locales / required-support</xref>
            <type/>
            <actor>client</actor>
            <text>
                    The server MUST support at least the en_US locale.
                  </text>
          </rule>

          <rule>
            <status value="ok">does</status>
            <type>SHOULD</type>
            <xref>connection / start-ok / client-properties / required-fields</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The properties SHOULD contain at least these fields: "product", giving the name
                    of the client product, "version", giving the name of the client version, "platform",
                    giving the name of the operating system, "copyright", if appropriate, and
                    "information", giving other general information.
                  </text>
          </rule>

          <rule>
            <status value="planned"/>
            <type>SHOULD</type>
            <xref>connection / start-ok / mechanism / security</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The client SHOULD authenticate using the highest-level security profile it
                    can handle from the list provided by the server.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>connection / start-ok / mechanism / validity</xref>
            <type/>
            <actor>server</actor>
            <text>
                    If the mechanism field does not contain one of the security mechanisms
                    proposed by the server in the Start method, the server MUST close the
                    connection without sending any further data.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>connection / tune / frame-max / minimum</xref>
            <type/>
            <actor>client</actor>
            <text>
                    Until the frame-max has been negotiated, both peers MUST accept frames of up
                    to frame-min-size octets large, and the minimum negotiated value for frame-max
                    is also frame-min-size.
                  </text>
          </rule>

          <rule>
            <status value="planned"/>
            <type>MUST</type>
            <xref>connection / tune-ok / channel-max / upper-limit</xref>
            <type/>
            <actor>server</actor>
            <text>
                    If the client specifies a channel max that is higher than the value provided
                    by the server, the server MUST close the connection without attempting a
                    negotiated close.  The server may report the error in some fashion to assist
                    implementors.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <notes>frame-min-size is 4Kb.</notes>
            <type>MUST</type>
            <xref>connection / tune-ok / frame-max / minimum</xref>
            <type/>
            <actor>server</actor>
            <text>
                    Until the frame-max has been negotiated, both peers MUST accept frames of up
                    to frame-min-size octets large, and the minimum negotiated value for frame-max
                    is also frame-min-size.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>connection / tune-ok / frame-max / upper-limit</xref>
            <type/>
            <actor>server</actor>
            <text>
                    If the client specifies a frame max that is higher than the value provided
                    by the server, the server MUST close the connection without attempting a
                    negotiated close. The server may report the error in some fashion to assist
                    implementors.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>connection / open / virtual-host / separation</xref>
            <type/>
            <actor>server</actor>
            <text>
                    If the server supports multiple virtual hosts, it MUST enforce a full
                    separation of exchanges, queues, and all associated entities per virtual
                    host. An application, connected to a specific virtual host, MUST NOT be able
                    to access resources of another virtual host.
                  </text>
          </rule>

          <rule>
            <status value="ok">does</status>
            <type>SHOULD</type>
            <xref>connection / open / virtual-host / security</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The server SHOULD verify that the client has permission to access the
                    specified virtual host.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>connection / close / stability</xref>
            <type/>
            <actor>client</actor>
            <text>
                  After sending this method, any received methods except Close and Close-OK MUST
                  be discarded.  The response to receiving a Close after sending Close must be to
                  send Close-Ok.
                </text>
          </rule>

          <rule>
            <status value="ok">does</status>
            <notes>Only the server maintains an error log.</notes>
            <type>SHOULD</type>
            <xref>connection / close-ok / reporting</xref>
            <type/>
            <actor>client</actor>
            <text>
                  A peer that detects a socket closure without having received a Close-Ok
                  handshake method SHOULD log the error.
                </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>channel / open / state</xref>
            <type/>
            <actor>server</actor>
            <text>
                  The client MUST NOT use this method on an already-opened channel.
                </text>
          </rule>

          <rule>
            <status value="ok">doesn't</status>
            <type>MAY</type>
            <xref>channel / flow / initial-state</xref>
            <type/>
            <actor>server</actor>
            <text>
                  When a new channel is opened, it is active (flow is active). Some applications
                  assume that channels are inactive until started. To emulate this behaviour a
                  client MAY open the channel, then pause it.
                </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>SHOULD</type> <xref>channel / flow / bidirectional</xref>
            <type/>
            <actor>server</actor>
            <text>
                  When sending content frames, a peer SHOULD monitor the channel for incoming
                  methods and respond to a Channel.Flow as rapidly as possible.
                </text>
          </rule>

          <rule>
            <status value="partial"/>
            <notes>
                  The server may issue a Channel.Flow under certain conditions, such as 
                  memory pressure. The clients do not automatically issue a Channel.Flow.
            </notes>
            <type>MAY</type>
            <xref>channel / flow / throttling</xref>
            <type/>
            <actor>server</actor>
            <text>
                  A peer MAY use the Channel.Flow method to throttle incoming content data for
                  internal reasons, for example, when exchanging data over a slower connection.
                </text>
          </rule>

          <rule>
            <status value="ok">does</status>
            <type>MAY</type>
            <xref>channel / flow / expected-behaviour</xref>
            <type/>
            <actor>server</actor>
            <text>
                  The peer that requests a Channel.Flow method MAY disconnect and/or ban a peer
                  that does not respect the request.  This is to prevent badly-behaved clients
                  from overwhelming a server.
                </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>channel / close / stability</xref>
            <type/>
            <actor>client</actor>
            <text>
                  After sending this method, any received methods except Close and Close-OK MUST
                  be discarded.  The response to receiving a Close after sending Close must be to
                  send Close-Ok.
                </text>
          </rule>

          <rule>
            <status value="ok">does</status>
            <type>SHOULD</type>
            <notes>Only the server maintains an error log.</notes>
            <xref>channel / close-ok / reporting</xref>
            <type/>
            <actor>client</actor>
            <text>
                  A peer that detects a socket closure without having received a Channel.Close-Ok
                  handshake method SHOULD log the error.
                </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>exchange / required-types</xref>
            <type/>
            <actor/>
            <text>
                The server MUST implement these standard exchange types: fanout, direct.
              </text>
          </rule>

          <rule>
            <status value="ok">does</status>
            <type>SHOULD</type>
            <xref>exchange / recommended-types</xref>
            <type/>
            <actor/>
            <text>
                The server SHOULD implement these standard exchange types: topic, headers.
              </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>exchange / required-instances</xref>
            <type/>
            <actor/>
            <text>
                The server MUST, in each virtual host, pre-declare an exchange instance
                for each standard exchange type that it implements, where the name of the
                exchange instance, if defined, is "amq." followed by the exchange type name.
              </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>exchange / default-exchange</xref>
            <type/>
            <actor/>
            <text>
                The server MUST pre-declare a direct exchange with no public name to act as
                the default exchange for content Publish methods and for default queue bindings.
              </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>exchange / default-access</xref>
            <type/>
            <actor/>
            <text>
                The server MUST NOT allow clients to access the default exchange except
                by specifying an empty exchange name in the Queue.Bind and content Publish
                methods.
              </text>
          </rule>

          <rule>
            <status value="ok">does</status>
            <type>MAY</type>
            <xref>exchange / extensions</xref>
            <type/>
            <actor/>
            <text>
                The server MAY implement other exchange types as wanted.
              </text>
          </rule>

          <rule>
            <status value="ok">does</status>
            <type>SHOULD</type>
            <xref>exchange / declare / minimum</xref>
            <type/>
            <actor>server</actor>
            <text>
                  The server SHOULD support a minimum of 16 exchanges per virtual host and
                  ideally, impose no limit except as defined by available resources.
                </text>
          </rule>

          <rule>
            <status value="planned"/>
            <notes>
                   The server does not prevent exchange names starting with "amq." from
                   being declared. Clients may declare exchanges starting with "amq." 
                   without the passive bit set.
            </notes>
            <type>MUST, MAY</type>
            <xref>exchange / declare / exchange / reserved</xref>
            <type/>
            <actor>server</actor>
            <text>
                    Exchange names starting with "amq." are reserved for pre-declared and
                    standardised exchanges. The client MAY declare an exchange starting with
                    "amq." if the passive option is set, or the exchange already exists.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <notes>
                   The lexicon is not enforced by the server.
            </notes>
            <type>MUST</type>
            <xref>exchange / declare / exchange / syntax</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The exchange name consists of a non-empty sequence of these characters:
                    letters, digits, hyphen, underscore, period, or colon.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>exchange / declare / type / typed</xref>
            <type/>
            <actor>server</actor>
            <text>
                    Exchanges cannot be redeclared with different types.  The client MUST not
                    attempt to redeclare an existing exchange with a different type than used
                    in the original Exchange.Declare method.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>exchange / declare / type / support</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The client MUST NOT attempt to declare an exchange with a type that the
                    server does not support.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <notes>(refers to the passive flag)</notes>
            <type>MUST</type>
            <xref>exchange / declare / passive / not-found</xref>
            <type/>
            <actor>server</actor>
            <text>
                    If set, and the exchange does not already exist, the server MUST
                    raise a channel exception with reply code 404 (not found).
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <notes>(refers to the passive flag)</notes>
            <type>MUST</type>
            <xref>exchange / declare / passive / equivalent</xref>
            <type/>
            <actor>server</actor>
            <text>
                    If not set and the exchange exists, the server MUST check that the
                    existing exchange has the same values for type, durable, and arguments
                    fields.  The server MUST respond with Declare-Ok if the requested
                    exchange matches these fields, and MUST raise a channel exception if
                    not.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>exchange / declare / durable / support</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The server MUST support both durable and transient exchanges.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>exchange / delete / exchange / exists</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The client MUST NOT attempt to delete an exchange that does not exist.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>exchange / delete / if-unused / in-use</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The server MUST NOT delete an exchange that has bindings on it, if the if-unused
                    field is true.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>queue / declare / default-binding</xref>
            <type/>
            <actor>server</actor>
            <text>
                  The server MUST create a default binding for a newly-declared queue to the
                  default exchange, which is an exchange of type 'direct' and use the queue
                  name as the routing key.
                </text>
          </rule>

          <rule>
            <status value="ok">does</status>
            <type>SHOULD</type>
            <xref>queue / declare / minimum-queues</xref>
            <type/>
            <actor>server</actor>
            <text>
                  The server SHOULD support a minimum of 256 queues per virtual host and ideally,
                  impose no limit except as defined by available resources.
                </text>
          </rule>

          <rule>
            <status value="ok">does</status>
            <type>MAY, MUST</type>
            <xref>queue / declare / queue / default-name</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The queue name MAY be empty, in which case the server MUST create a new
                    queue with a unique generated name and return this to the client in the
                    Declare-Ok method.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <notes>
                   The server does not prevent queue names starting with "amq." from
                   being declared. Clients may declare queues starting with "amq." 
                   without the passive bit set.
            </notes>
            <type>MUST</type>
            <xref>queue / declare / queue / reserved</xref>
            <type/>
            <actor>server</actor>
            <text>
                    Queue names starting with "amq." are reserved for pre-declared and
                    standardised queues. The client MAY declare a queue starting with
                    "amq." if the passive option is set, or the queue already exists.
                  </text>
          </rule>

          <rule>
            <status value="ok">does</status>
            <notes>
                   The lexicon is not enforced by the server.
            </notes>
            <type>MAY</type>
            <xref>queue / declare / queue / syntax</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The queue name can be empty, or a sequence of these characters:
                    letters, digits, hyphen, underscore, period, or colon.
                  </text>
          </rule>

          <rule>
            <status value="ok">does</status>
            <type>MAY</type>
            <xref>queue / declare / passive / passive</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The client MAY ask the server to assert that a queue exists without
                    creating the queue if not.  If the queue does not exist, the server
                    treats this as a failure.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <notes>(refers to the passive flag)</notes>
            <type>MUST</type>
            <xref>queue / declare / passive / equivalent</xref>
            <type/>
            <actor>server</actor>
            <text>
                    If not set and the queue exists, the server MUST check that the
                    existing queue has the same values for durable, exclusive, auto-delete,
                    and arguments fields.  The server MUST respond with Declare-Ok if the
                    requested queue matches these fields, and MUST raise a channel exception
                    if not.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>queue / declare / durable / persistence</xref>
            <type/>
            <actor>server</actor>
            <text>The server MUST recreate the durable queue after a restart.</text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>queue / declare / durable / types</xref>
            <type/>
            <actor>server</actor>
            <text>The server MUST support both durable and transient queues.</text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>queue / declare / exclusive / types</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The server MUST support both exclusive (private) and non-exclusive (shared)
                    queues.
                  </text>
          </rule>

          <rule>
            <status value="ok">doesn't</status>
            <type>MAY NOT</type>
            <xref>queue / declare / exclusive / exclusive</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The client MAY NOT attempt to use a queue that was declared as exclusive
                    by another still-open connection.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>queue / declare / auto-delete / pre-existence</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The server MUST ignore the auto-delete field if the queue already exists.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>queue / bind / duplicates</xref>
            <type/>
            <actor>server</actor>
            <text>
                  A server MUST allow ignore duplicate bindings - that is, two or more bind
                  methods for a specific queue, with identical arguments - without treating these
                  as an error.
                </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>queue / bind / unique</xref>
            <type/>
            <actor>server</actor>
            <text>
                  A server MUST not deliver the same message more than once to a queue, even if
                  the queue has multiple bindings that match the message.
                </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>queue / bind / transient-exchange</xref>
            <type/>
            <actor>server</actor>
            <text>
                  The server MUST allow a durable queue to bind to a transient exchange.
                </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>queue / bind / durable-exchange</xref>
            <type/>
            <actor>server</actor>
            <text>
                  Bindings of durable queues to durable exchanges are automatically durable
                  and the server MUST restore such bindings after a server restart.
                </text>
          </rule>

          <rule>
            <status value="ok">does</status>
            <type>SHOULD</type>
            <xref>queue / bind / binding-count</xref>
            <type/>
            <actor>server</actor>
            <text>
                  The server SHOULD support at least 4 bindings per queue, and ideally, impose no
                  limit except as defined by available resources.
                </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>queue / bind / queue / queue-known</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The client MUST either specify a queue name or have previously declared a
                    queue on the same channel
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>queue / bind / queue / must-exist</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The client MUST NOT attempt to bind a queue that does not exist.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>queue / bind / exchange / exchange-existence</xref>
            <type/>
            <actor>server</actor>
            <text>
                    A client MUST NOT be allowed to bind a queue to a non-existent exchange.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>queue / bind / exchange / default-exchange</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The server MUST accept a blank exchange name to mean the default exchange.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>queue / bind / routing-key / direct-exchange-key-matching</xref>
            <type/>
            <actor>server</actor>
            <text>
                    If a message queue binds to a direct exchange using routing key K and a
                    publisher sends the exchange a message with routing key R, then the message
                    MUST be passed to the message queue if K = R.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>queue / unbind / 01</xref>
            <type/>
            <actor>server</actor>
            <text>If a unbind fails, the server MUST raise a connection exception.</text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>queue / unbind / queue / queue-known</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The client MUST either specify a queue name or have previously declared a
                    queue on the same channel
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>queue / unbind / queue / must-exist</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The client MUST NOT attempt to unbind a queue that does not exist.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>queue / unbind / exchange / must-exist</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The client MUST NOT attempt to unbind a queue from an exchange that
                    does not exist.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>queue / unbind / exchange / default-exchange</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The server MUST accept a blank exchange name to mean the default exchange.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>queue / purge / 02</xref>
            <type/>
            <actor>server</actor>
            <text>
                  The server MUST NOT purge messages that have already been sent to a client
                  but not yet acknowledged.
                </text>
          </rule>

          <rule>
            <status value="ok">doesn't</status>
            <type>MAY</type>
            <xref>queue / purge / 03</xref>
            <type/>
            <actor>server</actor>
            <text>
                  The server MAY implement a purge queue or log that allows system administrators
                  to recover accidentally-purged messages. The server SHOULD NOT keep purged
                  messages in the same storage spaces as the live messages since the volumes of
                  purged messages may get very large.
                </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>queue / purge / queue / queue-known</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The client MUST either specify a queue name or have previously declared a
                    queue on the same channel
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>queue / purge / queue / must-exist</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The client MUST NOT attempt to purge a queue that does not exist.
                  </text>
          </rule>

          <rule>
            <status value="planned">doesn't</status>
            <type>SHOULD</type>
            <xref>queue / delete / 01</xref>
            <type/>
            <actor>server</actor>
            <text>
                  The server SHOULD use a dead-letter queue to hold messages that were pending on
                  a deleted queue, and MAY provide facilities for a system administrator to move
                  these messages back to an active queue.
                </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>queue / delete / queue / queue-known</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The client MUST either specify a queue name or have previously declared a
                    queue on the same channel
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>queue / delete / queue / must-exist</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The client MUST NOT attempt to delete a queue that does not exist.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>queue / delete / if-unused / in-use</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The server MUST NOT delete a queue that has consumers on it, if the if-unused
                    field is true.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>queue / delete / if-empty / not-empty</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The server MUST NOT delete a queue that has messages on it, if the
                    if-empty field is true.
                  </text>
          </rule>

          <rule>
            <status value="ok">does</status>
            <type>SHOULD</type>
            <xref>basic /
               01</xref>
            <type/>
            <actor/>
            <text>
                The server SHOULD respect the persistent property of basic messages and
                SHOULD make a best-effort to hold persistent basic messages on a reliable
                storage mechanism.
              </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>basic / 02</xref>
            <type/>
            <actor/>
            <text>
                The server MUST NOT discard a persistent basic message in case of a queue
                overflow.
              </text>
          </rule>

          <rule>
            <status value="ok">does</status>
            <type>MAY</type>
            <xref>basic / 03</xref>
            <type/>
            <actor/>
            <text>
                The server MAY use the Channel.Flow method to slow or stop a basic message
                publisher when necessary.
              </text>
          </rule>

          <rule>
            <status value="ok">does</status>
            <type>MAY</type>
            <xref>basic / 04</xref>
            <type/>
            <actor/>
            <text>
                The server MAY overflow non-persistent basic messages to persistent
                storage.
              </text>
          </rule>

          <rule>
            <status value="ok">doesn't</status>
            <type>MAY</type>
            <xref>basic / 05</xref>
            <type/>
            <actor/>
            <text>
                The server MAY discard or dead-letter non-persistent basic messages on a
                priority basis if the queue size exceeds some configured limit.
              </text>
          </rule>

          <rule>
            <status value="planned"/>
            <type>MUST</type>
            <xref>basic / 06</xref>
            <type/>
            <actor/>
            <text>
                The server MUST implement at least 2 priority levels for basic messages,
                where priorities 0-4 and 5-9 are treated as two distinct levels.
              </text>
          </rule>

          <rule>
            <status value="ok">doesn't</status>
            <type>MAY</type>
            <xref>basic / 07</xref>
            <type/>
            <actor/>
            <text>
                The server MAY implement up to 10 priority levels.
              </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>basic / 08</xref>
            <type/>
            <actor/>
            <text>
                The server MUST deliver messages of the same priority in order irrespective of
                their individual persistence.
              </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>basic / 09</xref>
            <type/>
            <actor/>
            <text>
                The server MUST support un-acknowledged delivery of Basic content, i.e.
                consumers with the no-ack field set to TRUE.
              </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>basic / 10</xref>
            <type/>
            <actor/>
            <text>
                The server MUST support explicitly acknowledged delivery of Basic content,
                i.e. consumers with the no-ack field set to FALSE.
              </text>
          </rule>

          <rule>
            <status value="ok"/>
            <notes>(refers to prefetch-size)</notes>
            <type>MUST</type>
            <xref>basic / qos / prefetch-size / 01</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The server MUST ignore this setting when the client is not processing any
                    messages - i.e. the prefetch size does not limit the transfer of single
                    messages to a client, only the sending in advance of more messages while
                    the client still has one or more unacknowledged messages.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>basic / qos / prefetch-count / 01</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The server may send less data in advance than allowed by the client's
                    specified prefetch windows but it MUST NOT send more.
                  </text>
          </rule>

          <rule>
            <status value="ok">does</status>
            <type>SHOULD</type>
            <xref>basic / consume / 01</xref>
            <type/>
            <actor>server</actor>
            <text>
                  The server SHOULD support at least 16 consumers per queue, and ideally, impose
                  no limit except as defined by available resources.
                </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>basic / consume / consumer-tag / 01</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The client MUST NOT specify a tag that refers to an existing consumer.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>basic / consume / consumer-tag / 02</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The consumer tag is valid only within the channel from which the
                    consumer was created. I.e. a client MUST NOT create a consumer in one
                    channel and then use it in another.
                  </text>
          </rule>

          <rule>
            <status value="ok">doesn't</status>
            <type>MAY NOT</type>
            <xref>basic / consume / exclusive / 01</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The client MAY NOT gain exclusive access to a queue that already has
                    active consumers.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>basic / cancel / 01</xref>
            <type/>
            <actor>server</actor>
            <text>
                  If the queue does not exist the server MUST ignore the cancel method, so
                  long as the consumer tag is valid for that channel.
                </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>basic / publish / exchange / must-exist</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The client MUST NOT attempt to publish a content to an exchange that
                    does not exist.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>basic / publish / exchange / default-exchange</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The server MUST accept a blank exchange name to mean the default exchange.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <notes>Deprecation of internal exchanges in 0-9-1 voids the antecedent.</notes>
            <type>MUST</type>
            <xref>basic / publish / exchange / 02</xref>
            <type/>
            <actor>server</actor>
            <text>
                    If the exchange was declared as an internal exchange, the server MUST raise
                    a channel exception with a reply code 403 (access refused).
                  </text>
          </rule>

          <rule>
            <status value="ok">doesn't</status>
            <type>MAY</type>
            <xref>basic / publish / exchange / 03</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The exchange MAY refuse basic content in which case it MUST raise a channel
                    exception with reply code 540 (not implemented).
                  </text>
          </rule>

          <rule>
            <status value="ok">does</status>
            <type>SHOULD</type>
            <xref>basic / publish / mandatory / 01</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The server SHOULD implement the mandatory flag.
                  </text>
          </rule>

          <rule>
            <status value="ok">does</status>
            <type>SHOULD</type>
            <xref>basic / publish / immediate / 01</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The server SHOULD implement the immediate flag.
                  </text>
          </rule>

          <rule>
            <status value="planned"/>
            <type>SHOULD</type>
            <xref>basic / deliver / 01</xref>
            <type/>
            <actor>client</actor>
            <text>
                  The server SHOULD track the number of times a message has been delivered to
                  clients and when a message is redelivered a certain number of times - e.g. 5
                  times - without being acknowledged, the server SHOULD consider the message to be
                  unprocessable (possibly causing client applications to abort), and move the
                  message to a dead letter queue.
                </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>basic / ack / multiple / exists</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The server MUST validate that a non-zero delivery-tag refers to a delivered
                    message, and raise a channel exception if this is not the case.  On a transacted
                    channel, this check MUST be done immediately and not delayed until a Tx.Commit.
                    Specifically, a client MUST not acknowledge the same message more than once.
                  </text>
          </rule>

          <rule>
            <status value="planned"/>
            <type>SHOULD</type>
            <xref>basic / reject / 01</xref>
            <type/>
            <actor>server</actor>
            <text>
                  The server SHOULD be capable of accepting and process the Reject method while
                  sending message content with a Deliver or Get-Ok method. I.e. the server should
                  read and process incoming methods while sending output frames. To cancel a
                  partially-send content, the server sends a content body frame of size 1 (i.e.
                  with no data except the frame-end octet).
                </text>
          </rule>

          <rule>
            <status value="planned"/>
            <type>SHOULD</type>
            <xref>basic / reject / 02</xref>
            <type/>
            <actor>server</actor>
            <text>
                  The server SHOULD interpret this method as meaning that the client is unable to
                  process the message at this time.
                </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>basic / reject / 03</xref>
            <type/>
            <actor>server</actor>
            <text>
                  The client MUST NOT use this method as a means of selecting messages to process.
                </text>
          </rule>
          <rule>
            <status value="planned"/>
            <type>MUST NOT</type>
            <xref>basic / reject / requeue / 01</xref>
            <type/>
            <actor>server</actor>
            <text>
                    The server MUST NOT deliver the message to the same client within the
                    context of the current channel. The recommended strategy is to attempt to
                    deliver the message to an alternative consumer, and if that is not possible,
                    to move the message to a dead-letter queue. The server MAY use more
                    sophisticated tracking to hold the message on the queue and redeliver it to
                    the same client at a later stage.
                  </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>basic / recover-async / 01</xref>
            <type/>
            <actor>server</actor>
            <text>
                  The server MUST set the redelivered flag on all messages that are resent.
                </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST</type>
            <xref>basic / recover / 01</xref>
            <type/>
            <actor>server</actor>
            <text>
                  The server MUST set the redelivered flag on all messages that are resent.
                </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>tx / not multiple queues</xref>
            <type/>
            <actor/>
            <text>
              Applications MUST NOT rely on the atomicity of transactions that
              affect more than one queue.
              </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>tx / not immediate</xref>
            <type/>
            <actor/>
            <text>
              Applications MUST NOT rely on the behaviour of transactions that
              include messages published with the immediate option.
              </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>tx / not mandatory</xref>
            <type/>
            <actor/>
            <text>
              Applications MUST NOT rely on the behaviour of transactions that
              include messages published with the mandatory option.
              </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>tx / commit / transacted</xref>
            <type/>
            <actor>server</actor>
            <text>
                  The client MUST NOT use the Commit method on non-transacted channels.
                </text>
          </rule>

          <rule>
            <status value="ok"/>
            <type>MUST NOT</type>
            <xref>tx / rollback / transacted</xref>
            <type/>
            <actor>server</actor>
            <text>
                  The client MUST NOT use the Rollback method on non-transacted channels.
                </text>
          </rule>
        </rules>
      </doc:section>


      <doc:section name="rules">
        <doc:heading>Rules from the AMQP specification, version 0-8</doc:heading>
        <p>
          The rules listed below relate to features supported by RabbitMQ that 
          have been deprecated.
        </p>
        <rules xmlns="http://www.rabbitmq.com/namespaces/ad-hoc/conformance">
          <rule>
            <status value="ok">does</status>
            <xref>
            </xref>
            <context>
              method/connection/redirect
            </context>
            <type>
              SHOULD
            </type>
            <actor>
              client
            </actor>
            <text>
              When getting the Connection.Redirect method, the client SHOULD reconnect to the host specified, and if that host is not present, to any of the hosts specified in the known-hosts list.
            </text>
          </rule>
          <rule>
            <status value="ok">does</status>
            <xref>
            </xref>
            <context>
              method/connection/redirect
            </context>
            <type>
              SHOULD
            </type>
            <actor>
              client
            </actor>
            <text>
              When getting the Connection.Redirect method, the client SHOULD reconnect to the host specified, and if that host is not present, to any of the hosts specified in the known-hosts list.
            </text>
          </rule>
          <rule>
            <status value="ok">does</status>
            <xref>
            </xref>
            <context>
              domain/known hosts
            </context>
            <type>
              MAY
            </type>
            <actor>
              server
            </actor>
            <text>
              The server MAY leave this field empty if it knows of no other hosts than itself.
            </text>
          </rule>
        </rules>
      </doc:section>
    </doc:div>
  </body>
</html>
