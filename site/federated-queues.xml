<?xml-stylesheet type="text/xml" href="page.xsl"?>
<!DOCTYPE html [
<!ENTITY % entities SYSTEM "rabbit.ent" >
%entities;
]>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:doc="http://www.rabbitmq.com/namespaces/ad-hoc/doc"
      xmlns:x="http://www.rabbitmq.com/2011/extensions">
  <head>
    <title>Federated Queues</title>
  </head>
  <body show-in-this-page="true">
    <doc:section name="what-does-it-do">
      <h3>Overview</h3>
      <p>
        In addition to <a href="">federated exchanges</a>, RabbitMQ
        supports federated queues. This feature can be used for
        asynchronous replication, as a network split tolerant
        alternative to clustering, as a way of balancing the load
        of a single queue across nodes, and more.
      </p>

      <p>
        A federated queue links to other
        queues (called <i>upstream</i> queues). It will retrieve
        messages from upstream queues in order to satisfy demand for
        messages from local consumers. The upstream queues do not
        need to be reconfigured and they do not have to be on the same
        broker or in the same cluster.
      </p>

      <img src="/img/federated_queues00.png"
           width="700"
           alt="Overview of federated queues" />

      <p>
        All of the configuration needed to establish the upstream links
        and the federated queue is in the broker with the federated queue
        (<i>downstream</i>).
      </p>

      <h3>Typical Use Cases</h3>
      <p>
        The typical use would be to have the same "logical" queue
        distributed over many brokers. Each broker would declare a federated
        queue with all the other federated queues upstream. (The links
        would form a complete bi-directional graph on <i>n</i> queues.)
      </p>
      <p>
        Such a logical distributed queue is capable of having rather
        higher capacity than a single queue. It will perform best when
        there is some degree of locality; i.e. as many messages as
        possible are consumed from the same queue as they were published
        to, and the federation mechanism only needs to move messages
        around in order to perform load balancing.
      </p>
    </doc:section>

    <doc:section name="usage">
      <doc:heading>Using Federated Queues</doc:heading>
      <h3>Configuration</h3>
      <p>
        Federated queues are declared just like any other queue, by applications.
        In order for RabbitMQ to recognize that a queue needs to be federated,
        and what other nodes messages should be consumed from, <i>downstream</i>
        (consuming) nodes need to be configured.
      </p>
      <p>
        Configuration is done by declaring <i>policies</i>. A policy is
        a pattern that queue names are matched against. Matching queues will
        be federated.
      </p>
      <p>
        A federated queue can belong to only one policy. If more than one
        policy matches queue name, <i>policy priority</i> acts as a tie breaker.
        When two policies have the same priority, the matching one is chosen
        non-deterministically.
      </p>

      <img src="/img/federated_queues01.png"
           width="700"
           alt="Federated queue policies" />

      <h3>How It Works</h3>
      <p>
        The federated queue will connect to all its upstream queues using
        AMQP 0-9-1. When declaring or configuring the federated queue each
        upstream queue is listed with the connection properties to be used
        to establish the link.
      </p>

      <p>
        The federated queue will only retrieve messages when it has run
        out of messages locally, it has consumers that need messages, and
        the upstream queue has "spare" messages that are not being
        consumed. The intent is to ensure that messages are only
        transferred between federated queues when needed.
      </p>

      <h3>Queue Arguments</h3>
      <p>
        In general each individual queue applies its arguments separately;
        for example if you set <code>x-max-length</code> on a federated
        queue then that queue will have its length limited (possibly
        discarding messages when it gets full) but other queues that are
        federated with it will not be affected. Note in particular that
        when <a href="ttl.html">per-queue or per-message TTL</a> is in
        use, a message will have its timer reset when it is transferred to
        another queue.
      </p>

      <h3>Message Ordering Semantics</h3>
      <p>
        If messages are forwarded from one queue to another then message
        ordering is only preserved for messages which have made exactly
        the same journey between nodes. In some cases messages which were
        adjacent when published may take different routes to the same node
        to be consumed; therefore messages can be reordered in the
        presence of queue federation.
      </p>
    </doc:section>

    <doc:section name="limitations">
      <doc:heading>Limitations</doc:heading>
      <h3><code>basic.get</code> Support</h3>
      <p>
        <code>basic.get</code> cannot retrieve messages over
        federation if there aren't any in a local queue (on the node
        the client is connected to). Since <code>basic.get</code> is a
        synchronous method, the node serving a request would have to
        block while contacting all the other nodes to retrieve more
        messages. This wouldn't sit well with federation's
        availability promise (partition tolerance).
      </p>
    </doc:section>

    <doc:section name="advanced">
      <doc:heading>Advanced Usage</doc:heading>
      <h3>Federation of Federated Queues</h3>
      <p>
        There is nothing to prevent a federated queue being 'upstream'
        from another federated queue. One can even form 'loops', for
        example, queue A declares queue B to be upstream from it, and
        queue B declares queue A to be upstream from it. More complex
        multiply-connected arrangements are allowed.
      </p>
      <p>
        However, federated queues cannot currently cause messages to
        traverse multiple hops between brokers based solely on need for
        messages in one place. For example, if you federate queues on
        nodes A, B and C, with A and B connected and B and C connected,
        but not A and C, then if messages are available at A and consumers
        waiting at C then messages will not be transferred from A to C via
        B unless there is also a consumer at B.
      </p>

      <h3>Use In Combination With Federated Exchanges</h3>
      <p>
        It is possible to bind a federated queue to a federated
        exchange. However, the results may be unexpected to some.
        Since a federated exchange will retrieve messages from its
        upstream that match its bindings, any message published to a
        federated exchange will be copied to any nodes that matching
        bindings. A federated queue will then move these messages
        around between nodes, and it is therefore possible to end up
        with multiple copies of the same message on the same node.
      </p>
    </doc:section>

    <doc:section name="implementation">
      <doc:heading>Implementation</doc:heading>
      <p>
        Inter-broker communication is implemented using AMQP 0-9-1 (optionally
        secured with SSL). When a federated queue is empty and has active
        consumers with a <a href="consumer-priority.html">priority</a> of
        0 or greater, it consumes from all upstream queues. As soon as it
        is non-empty, or its consumers are no longer active, it stops
        consuming.
      </p>

      <p>
        Since it consumes from the upstreams with a priority of -1, each
        upstream is able to prioritise delivering messages to its "own"
        consumers before delivering to another queue. We therefore ensure
        that messages are not forwarded between federated queues
        needlessly.
      </p>

      <p>
        However, unlike with federated exchanges, there is no limit to how
        many times a message can be forwarded between federated queues. In
        a set of mutually-federated queues, messages will move to where
        the spare consuming capacity is - so if the spare consuming
        capacity keeps moving around then so will the messages.
      </p>

      <h3>RabbitMQ Version Requirements</h3>
      <p>
        Brokers running different versions of RabbitMQ can be connected
        using federation. However, since queue federation requires
        consumer priorities, it is not possible to federate a queue with a
        broker running a RabbitMQ version prior to 3.2.0.
      </p>
    </doc:section>
  </body>
</html>
