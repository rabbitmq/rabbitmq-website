<?xml-stylesheet type="text/xml" href="page.xsl"?>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:doc="http://www.rabbitmq.com/namespaces/ad-hoc/doc"
      xmlns:x="http://www.rabbitmq.com/2011/extensions">
  <head>
    <title>Highly Available Queues</title>
  </head>
  <body show-in-this-page="true">
      <doc:section name="overview">
        <p>
          If your RabbitMQ broker consists of a single node, then a
          failure of that node will cause downtime, temporary
          unavailability of service, and potentially loss of messages
          (especially non-persistent messages held by non-durable
          queues). You could publish all messages persistent, to
          durable queues, but even then, due to buffering there is an
          amount of time between the message being sent and the
          message being written to disk and fsync'd. Using <a
          href="confirms.html">publisher confirms</a> is
          one means to ensure the client understands which messages
          have been written to disk, but even so, you may not wish to
          suffer the downtime and inconvenience of the unavailability
          of service caused by a node failure, or the performance
          degradation of having to write every message to disk.
        </p>
        <p>
          You could use a <a href="clustering.html">cluster</a> of
          RabbitMQ nodes to construct your RabbitMQ broker. This will
          be resilient to the loss of individual nodes in terms of the
          overall availability of service, but some important caveats
          apply: whilst exchanges and bindings survive the loss of
          individual nodes, queues and their messages do not. This is
          because a queue and its contents reside on exactly one node,
          thus the loss of a node will render its queues unavailable.
        </p>
        <p>
          You could use an <a href="pacemaker.html">active/passive</a>
          pair of nodes such that should one node fail, the passive
          node will be able to come up and take over from the failed
          node. This can even be combined with clustering. Whilst this
          approach ensures that failures are quickly detected and
          recovered from, there can be reasons why the passive node
          can take a long time to start up, or potentially even fail
          to start. This can cause at best, temporary unavailability
          of queues which were located on the failed node.
        </p>
        <p>
          To solve these various problems, we have developed
          active/active high availability for queues. This works by
          allowing queues to be <i>mirrored</i> on other nodes within
          a RabbitMQ cluster. The result is that should one node of a
          cluster fail, the queue can automatically switch to one of
          the mirrors and continue to operate, with no unavailability
          of service. This solution still requires a RabbitMQ cluster,
          which means that it will not cope seamlessly with network
          partitions within the cluster and, for that reason, is not
          recommended for use across a WAN (though of course, clients
          can still connect from as near and as far as needed).
        </p>
      </doc:section>

      <doc:section name="behaviour">
        <doc:heading>Mirrored Queue Behaviour</doc:heading>
        <p>
          In normal operation, for each mirrored-queue, there is one
          <i>master</i> and several <i>slaves</i>, each on a
          different node. The slaves apply the operations that occur
          to the master in exactly the same order as the master and
          thus maintain the same state. All actions other than
          publishes go only to the master, and the master then
          broadcasts the effect of the actions to the slaves. Thus
          clients consuming from a mirrored queue are in fact
          consuming from the master.
        </p>
        <p>
          Should a slave fail, there is little to be done other than
          some bookkeeping: the master remains the master and no
          client need take any action or be informed of the failure.
        </p>
        <p>
          If the master fails, then one of the slaves must be
          promoted. At this point, the following happens:
          <ol>
            <li>A slave is promoted to become the new master. The
            slave chosen for promotion is the eldest slave. As such,
            it has the best chance of being synchronised with the
            master. However, note that should there be no slave that
            is <a href="#unsynchronised-slaves">synchronised</a> with
            the master, messages that only the master held will be
            lost.</li>

            <li>The slave considers all previous consumers to have
            been abruptly disconnected. As such, it requeues all
            messages that have been delivered to clients but are
            pending acknowledgement. This can include messages for
            which a client has issued acknowledgements: either the
            acknowledgement was lost on the wire before reaching the
            master, or it was lost during broadcast from the master to
            the slaves. In either case, the new master has no choice
            but to requeue all messages it thinks have not been
            acknowledged.</li>

            <li>Clients that were consuming from the mirrored-queue
            and support our <a
            href="consumer-cancel.html">Consumer
            Cancellation Notifications</a> extension will receive a
            notification that their subscription to the mirrored-queue
            has been abruptly cancelled. At this point they should
            re-consume from the queue, which will pick up the new
            master. The reason for sending this notification is that
            informing clients of the loss of the master is essential:
            otherwise the client may continue to issue
            acknowledgements for messages they were sent by the old,
            failed master, and not expect that they might be about to
            see the same messages again, this time sent by the new
            master. Of course, clients that were connected to the
            failed node will find their connections failed, and will
            need to reconnect to a surviving node of the cluster.</li>

            <li><i>As a result of the requeuing, clients that
            re-consume from the queue <b>must</b> be aware that they
            are likely to subsequently receive messages that they have
            seen previously.</i></li>
          </ol>
        </p>
        <p>
          As the chosen slave becomes the master, no messages that are
          published to the mirrored-queue during this time will be
          lost: messages published to a mirrored-queue are always
          published directly to the master and all slaves. Thus should
          the master fail, the messages continue to be sent to the
          slaves and will be added to the queue once the promotion of
          a slave to the master completes.
        </p>
        <p>
          Similarly, messages published by clients using <a
          href="confirms.html">publisher confirms</a> will
          still be confirmed correctly even if the master (or any
          slaves) fail between the message being published and the
          message being able to be confirmed to the publisher. Thus
          from the point of view of the publisher, publishing to a
          mirrored-queue is no different from publishing to any other
          sort of queue. It is only consumers that need to be aware of
          the possibility of needing to re-consume from a
          mirrored-queue upon receipt of a <a
          href="consumer-cancel.html">Consumer
          Cancellation Notification</a>.
        </p>
        <p>
          If you are consuming from a mirrored-queue with
          <i>noAck=true</i> (i.e. the client is not sending message
          acknowledgements) then messages can be lost. This is no
          different from the norm of course: the broker considers a
          message <i>acknowledged</i> as soon as it has been sent to a
          <i>noAck=true</i> consumer, and should the client disconnect
          abruptly, the message may never be received. In the case of
          a mirrored-queue, should the master die, messages that are
          in-flight on their way to <i>noAck=true</i> consumers may
          never be received by those clients, and will not be requeued
          by the new master. Because of the possibility that the
          consuming client is connected to a node that survives, the
          <a href="consumer-cancel.html">Consumer
          Cancellation Notification</a> is useful in identifying when
          such events may have occurred. Of course, in practise, if
          you care about not losing messages then you are advised to
          consume with <i>noAck=false</i>.
        </p>
        <doc:subsection name="confirms-transactions">
          <doc:heading>Publisher Confirms and Transactions</doc:heading>
          <p>
            Mirrored queues support both <a
            href="confirms.html">Publisher Confirms</a> and
            <a href="specification.html#tx">Transactions</a>. The
            semantics chosen are that in the case of both confirms and
            transactions, the action spans all mirrors of the
            queue. So in the case of a transaction, a
            <code>tx.commit-ok</code> will only be returned to a
            client when the transaction has been applied across all
            mirrors of the queue. Equally, in the case of publisher
            confirms, a message will only be confirmed to the
            publisher when it has been accepted by all of the
            mirrors. It is correct to think of the semantics as being
            the same as a message being routed to multiple normal
            queues, and of a transaction with publications within
            that similarly are routed to multiple queues.
          </p>
        </doc:subsection>
      </doc:section>

      <doc:section name="unsynchronised-slaves">
        <doc:heading>Unsynchronised Slaves</doc:heading>
        <p>
          A node may join a cluster at any time. Depending on the
          configuration of a queue, when a node joins a cluster,
          queues may add a slave on the new node. At this point, the
          new slave will be empty: it will not contain any existing
          contents of the queue, and currently, there is no
          synchronisation protocol. Such a slave will receive new
          messages published to the queue, and thus over time will
          accurately represent the tail of the mirrored-queue. As
          messages are drained from the mirrored-queue, the size of
          the head of the queue for which the new slave is missing
          messages, will shrink until eventually the slave's contents
          precisely match the master's contents. At this point, the
          slave can be considered fully synchronised, but it is
          important to note that this has occured because of actions
          of clients in terms of draining the pre-existing head of the
          queue.
        </p>
        <p>
          Thus a newly added slave provides no additional form of
          redundancy or availability of the queue's contents until the
          contents of the queue that existed before the slave was
          added have been removed.  As a result of this, it is
          preferable to bring up all nodes on which slaves will exist
          prior to creating mirrored queues, or even better to ensure
          that your use of messaging generally results in very short
          or empty queues that rapidly drain.
        </p>
        <p>
          You can determine which slaves have synchronised with the
          following rabbitmqctl invocation, or through the management
          plugin:
        </p>
        <pre class="sourcecode">rabbitmqctl list_queues name slave_pids synchronised_slave_pids</pre>
      </doc:section>

      <doc:section name="start-stop">
        <doc:heading>Starting and Stopping Nodes</doc:heading>
        <p>
          If you stop a RabbitMQ node which contains the master of a
          mirrored-queue, some slave on some other node will be
          promoted to the master (assuming there is one). If you
          continue to stop nodes then you will reach a point where a
          mirrored-queue has no more slaves: it exists only on one
          node, which is now its master.  If the mirrored-queue was
          declared <i>durable</i> then, if its last remaining node is
          shutdown, durable messages in the queue will survive the
          restart of that node. In general, as you restart other
          nodes, if they were previously part of a mirrored-queue then
          they will rejoin the mirrored queue.
        </p>
        <p>
          However, there is currently no way for a slave to know
          whether or not its queue contents have diverged from the
          master to which it is rejoining (this could happen during a
          network partition, for example). As such, when a slave
          rejoins a mirrored-queue, it throws away any durable local
          contents it already has and starts empty. Its behaviour is
          at this point the same as if it were a <a
          href="#unsynchronised-slaves">new node joining the
          cluster</a>.
        </p>
      </doc:section>

      <doc:section name="genesis">
        <doc:heading>Configuring Mirroring</doc:heading>
        <p>
          Queues have mirroring enabled
          via <a href="parameters.html#policies">policy</a>. Policies
          can change at any time; it is valid to create a non-mirrored
          queue, and then make it mirrored at some later point (and
          vice versa). There is a difference between a non-mirrored
          queue and a mirrored queue which does not have any slaves -
          the former lacks the extra mirroring infrastructure and will
          run faster.
        </p>
        <p>
          You should be aware of the behaviour
          of <a href="#unsynchronised-slaves">adding mirrors to a
          queue</a>.
        </p>
        <p>
          To cause queues to become mirrored, you should create a
          policy which matches them and sets policy
          keys <code>ha-mode</code> and
          (optionally) <code>ha-params</code>. The following table
          explains the options for these keys:
        </p>

        <table>
          <tr>
            <th><code>ha-mode</code></th>
            <th><code>ha-params</code></th>
            <th>Result</th>
          </tr>
          <tr>
            <td><code>all</code></td>
            <td>(absent)</td>
            <td>
              Queue is mirrored across all nodes in the
              cluster. When a new node is added to the cluster, the
              queue will be mirrored to that node.
            </td>
          </tr>
          <tr>
            <td><code>exactly</code></td>
            <td><i>count</i></td>
            <td>
              Queue is mirrored to <i>count</i> nodes in the
              cluster. If there are less than <i>count</i> nodes in
              the cluster, the queue is mirrored to all nodes. If
              there are more than <i>count</i> nodes in the cluster,
              and a node containing a mirror goes down, then a new
              mirror will <b>not</b> be created on another node. (This
              is to prevent queues migrating across a cluster as it is
              brought down.)
            </td>
          </tr>
          <tr>
            <td><code>nodes</code></td>
            <td><i>node names</i></td>
            <td>
              Queue is mirrored to the nodes listed in <i>node
              names</i>. If any of those node names are not a part of
              the cluster, this does not constitute an error. If none
              of the nodes in the list are online at the time when the
              queue is declared then the queue will be created on the
              node that the declaring client is connected to.
            </td>
          </tr>
        </table>

        <p>
          Whenever the HA policy for a queue changes it will endeavour
          to keep its existing mirrors as far as this fits with the new
          policy.
        </p>

        <h3>"nodes" policy and migrating masters</h3>

        <p>
          Note that setting or modifying a "nodes" policy will never
          cause an existing master to go away, even if you ask it
          to. For example, if a queue is on <code>[A]</code>, and
          you give it a <code>nodes</code> policy telling it to be on
          <code>[B C]</code>, it will end up on <code>[A B
          C]</code>. If node <code>A</code> then fails or is shut
          down, the mirror on that node will not come back and the
          queue will stay on <code>[B C]</code>.
        </p>

        <h3>Some examples</h3>

        <p>
          Policy where queues whose names begin with
          "<code>ha.</code>" are mirrored to all nodes in the cluster:
        </p>

        <table>
          <tr>
            <th>rabbitmqctl</th>
            <td>
              <pre>rabbitmqctl set_policy ha-all "^ha\." '{"ha-mode":"all"}'</pre>
            </td>
          </tr>
          <tr>
            <th>rabbitmqctl (Windows)</th>
            <td>
              <pre>rabbitmqctl set_policy ha-all "^ha\." "{""ha-mode"":""all""}"</pre>
            </td>
          </tr>
          <tr>
            <th>HTTP API</th>
            <td>
              <pre>PUT /api/parameters/policy/%2f/ha-all
   {"pattern":"^ha\.", "definition":{"ha-mode":"all"}}</pre>
            </td>
          </tr>
          <tr>
            <th>Web UI</th>
            <td>
              <ul>
                <li>
                  Navigate to Admin > Policies > Add / update a
                  policy.
                </li>
                <li>
                  Enter "ha-all" next to Name, "^ha\." next to Pattern,
                  and "ha-mode" = "all" in the first line next to
                  Policy.
                </li>
                <li>
                  Click Add policy.
                </li>
              </ul>
            </td>
          </tr>
        </table>


        <p>
          Policy where queues whose names begin with
          "<code>two.</code>" are mirrored to any two nodes in the
          cluster:
        </p>

        <table>
          <tr>
            <th>rabbitmqctl</th>
            <td>
              <pre>rabbitmqctl set_policy ha-two "^two\." \
   '{"ha-mode":"exactly","ha-params":2}'</pre>
            </td>
          </tr>
          <tr>
            <th>rabbitmqctl (Windows)</th>
            <td>
              <pre>rabbitmqctl set_policy ha-two "^two\." ^
   "{""ha-mode"":""exactly"",""ha-params"":2}"</pre>
            </td>
          </tr>
          <tr>
            <th>HTTP API</th>
            <td>
              <pre>PUT /api/parameters/policy/%2f/ha-two
   {"pattern":"^two\.", "definition":{"ha-mode":"exactly", "ha-params":2}}</pre>
            </td>
          </tr>
          <tr>
            <th>Web UI</th>
            <td>
              <ul>
                <li>
                  Navigate to Admin > Policies > Add / update a
                  policy.
                </li>
                <li>
                  Enter "ha-two" next to Name and "^two\." next to
                  Pattern.
                </li>
                <li>
                  Enter "ha-mode" = "exactly" in the first line
                  next to Policy, then "ha-params" = 2 in the second line,
                  and set the type on the second line to "Number".
                </li>
                <li>
                  Click Add policy.
                </li>
              </ul>
            </td>
          </tr>
        </table>

      </doc:section>
  </body>
</html>
