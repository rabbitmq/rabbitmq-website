<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xml" href="page.xsl"?>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:doc="http://www.rabbitmq.com/namespaces/ad-hoc/doc"
      xmlns:x="http://www.rabbitmq.com/2011/extensions">
  <head>
    <title>Confirms (aka Publisher Acknowledgements)</title>
  </head>
  <body>
    <p>
      Using standard AMQP, the only way to guarantee that a
      message isn't lost is by using transactions -- make the
      channel transactional, publish the message, commit.  In this
      case, transactions are unnecessarily heavyweight and
      decrease throughput by a factor of 250.  To remedy this,
      a confirmation mechanism was introduced.
    </p>

    <p>
      To enable confirms, a client sends the
      <code>confirm.select</code> method.  Depending on whether
      <code>no-wait</code> was set or not, the broker may respond
      with a <code>confirm.select-ok</code>.  Once the
      <code>confirm.select</code> method is used on a channel, it
      is said to be in confirm mode.  A transactional channel
      cannot be put into confirm mode and once a channel is in
      confirm mode, it cannot be made transactional.
    </p>

    <p>
      Once a channel is in confirm mode, both the broker and the
      client count messages (counting starts at 1 on the first
      <code>confirm.select</code>).  The broker then confirms
      messages as it handles them by sending a
      <code>basic.ack</code> on the same channel. The
      <code>delivery-tag</code> field contains the sequence number
      of the confirmed message.  The broker may also set the
      <code>multiple</code> field in <code>basic.ack</code> to
      indicate that all messages up to and including the one with
      the sequence number have been handled.
    </p>

    <p>
      In exceptional cases when the broker is unable to handle
      messages successfully, instead of a <code>basic.ack</code>,
      the broker will send a <code>basic.nack</code>.  In this
      context, fields of the <code>basic.nack</code> have the same
      meaning as the corresponding ones in <code>basic.ack</code>
      and the <code>requeue</code> field should be ignored.  By
      nack'ing one or more messages, the broker indicates that it
      was unable to process the messages and refuses responsibility
      for them; at that point, the client may choose to re-publish
      the messages.
    </p>

    <p>
      After a channel is put into confirm mode, all subsequently
      published messages will be confirmed or nack'd once.  No
      guarantees are made as to how soon a message is confirmed.
      No message will be both confirmed and nack'd.
    </p>

    <p>
      An example in Java that publishes a large number of
      messages to a channel in confirm mode and waits for the
      acknowledgements can be found <a
                                       href="http://hg.rabbitmq.com/rabbitmq-java-client/file/default/test/src/com/rabbitmq/examples/ConfirmDontLoseMessages.java">here</a>.
    </p>

    <h3 id="when">When will messages be confirmed?</h3>

    <p>
      The broker will confirm messages once:
    </p>

    <ul>
      <li>
        it decides a message will not be routed to queues<br/>
        (if the <code>mandatory</code> flag is set then
        the <code>basic.return</code> is sent first) <b>or</b>
      </li>
      <li>
        a transient message has reached all its queues (and mirrors) <b>or</b>
      </li>
      <li>
        a persistent message has reached all its queues (and mirrors)
        and been persisted to disk (and <code>fsync</code>ed) <b>or</b>
      </li>
      <li>
        a persistent message has been consumed (and if necessary
        acknowledged) from all its queues
      </li>
    </ul>

    <h3>Notes</h3>

    <p>
      The broker loses persistent messages if it crashes before
      said messages are written to disk.  Under certain
      conditions, this causes the broker to behave in surprising
      ways.
    </p>

    <p>
      For instance, consider this scenario:
      <ol>
        <li>a client publishes a persistent message to a durable
          queue</li>
        <li>a client consumes the message from the queue (noting
          that the message is persistent and the queue
          durable), but doesn't yet ack it,</li>
        <li>the broker dies and is restarted, and</li>
        <li>the client reconnects and starts consuming messages.</li>
      </ol>
      At this point, the client could reasonably assume that the
      message will be delivered again.  This is not the case:
      the restart has caused the broker to lose the message.  In
      order to guarantee persistence, a client should use
      confirms.  If the publisher's channel had been in confirm
      mode, the publisher would <em>not</em> have received an
      ack for the lost message (since the consumer hadn't ack'd
      it and it hadn't been written to disk).
    </p>
  </body>
</html>
