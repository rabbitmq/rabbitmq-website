<?xml-stylesheet type="text/xml" href="page.xsl"?>
<!DOCTYPE html [
<!ENTITY % entities SYSTEM "rabbit.ent" >
%entities;
]>
<!--
Copyright (c) 2007-2016 Pivotal Software, Inc.

All rights reserved. This program and the accompanying materials
are made available under the terms of the under the Apache License,
Version 2.0 (the "License”); you may not use this file except in compliance
with the License. You may obtain a copy of the License at

https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:doc="http://www.rabbitmq.com/namespaces/ad-hoc/doc"
      xmlns:x="http://www.rabbitmq.com/2011/extensions">
  <head>
    <title>TLS Support</title>
  </head>
  <body show-in-this-page="true">
      <doc:section name="intro-and-requirements">
        <doc:heading>Intro</doc:heading>
        <p class="intro">RabbitMQ has inbuilt support for TLS. This includes
        client connections and popular plugins, where applicable, such as <a href="federation.html">Federation
        links</a>. It is also possible to use TLS to <a href="clustering-ssl.html">encrypt inter-node connections in clusters</a>.</p>

        <p>
          This guide covers various topics related to TLS in RabbitMQ:

          <ul>
            <li>Enabling TLS listeners in RabbitMQ</li>
            <li>How to generate self-signed certificates for development and QA environments</li>
            <li>TLS configuration in Java and .NET clients</li>
            <li>Known vulnerabilities and their migration</li>
            <li>TLS version and cipher suite configuration</li>
            <li>Certificate chain validation depth</li>
            <li>Tools that can be used to evaluate a TLS setup</li>
          </ul>

          and more. It is not, however, a primer on TLS, encryption, <a href="https://en.wikipedia.org/wiki/Public_key_infrastructure">Public Key Infrastructure</a>
          and related topics, so the concepts are covered very briefly.
          A number of beginner-oriented primers are available elsewhere on the Web:
          <a href="https://hpbn.co/transport-layer-security-tls/">one</a>
          <a href="https://blog.talpor.com/2015/07/ssltls-certificates-beginners-tutorial/">two</a>,
          <a href="https://blogs.akamai.com/2016/03/enterprise-security---ssltls-primer-part-1---data-encryption.html">three</a>, <a href="https://blogs.akamai.com/2016/03/enterprise-security---ssltls-primer-part-2---public-key-certificates.html">four</a>.
        </p>

        <p>
          TLS can be enabled for all protocols supported by RabbitMQ, not just AMQP 0-9-1,
          which this guide focuses on. <a href="/management.html">HTTP API</a> can be configured
          to use TLS (HTTPS) as well.
        </p>

        <p>
          For an overview of common TLS troubleshooting techniques,
          see <a href="troubleshooting-ssl.html">Troubleshooting TLS-related issues</a>.
        </p>

        <doc:subsection name="tls-connectivity-options">
          <doc:heading>Using TLS for Client Connections with RabbitMQ</doc:heading>
          <p>
            For client connections, there are two common approaches:
            <ul>
              <li>Configure RabbitMQ to handle TLS connections</li>
              <li>
                Use a proxy or load balancer (such as <a href="http://www.haproxy.org/">HAproxy</a>)
                to perform <a href="https://en.wikipedia.org/wiki/TLS_termination_proxy">TLS termination</a> of client connections and use plain TCP connections
                to RabbitMQ nodes.
              </li>
            </ul>

            Both approaches are valid and have pros and cons. This guide will focus on the
            first option.
          </p>
        </doc:subsection>

        <doc:subsection name="erlang-otp-requirements">
          <doc:heading>Erlang/OTP Requirements for TLS Support</doc:heading>
          <p>
            In order to support TLS connections, RabbitMQ needs TLS and
            crypto-related modules to be available in the Erlang/OTP
            installation. The recommended Erlang/OTP version to use with
            TLS is the most recent <a href="/which-erlang.html">supported Erlang release</a>.
            Earlier versions, even if they are supported, may work for most certificates
            but have known limitations (see below).
          </p>

          <p>The Erlang <code>crypto</code>, <code>asn1</code>,
          <code>public_key</code>, and <code>ssl</code> libraries
          (applications) must be installed and functional. On Debian and
          Ubuntu this is provided by the <a
          href="http://packages.ubuntu.com/search?keywords=erlang-ssl">erlang-ssl</a>
          package. The <a
          href="https://github.com/rabbitmq/erlang-rpm">zero dependency
          Erlang RPM for RabbitMQ</a> includes the above modules.</p>

          <p>If Erlang/OTP is compiled from source, it is necessary to ensure that <code>configure</code>
          finds OpenSSL and builds the above libraries.</p>

          <p>
            When investigating TLS connectivity issues, please keep in mind that in the vast majority
            of cases they are environment-specific and do not indicate a bug or limitation
            in Erlang/OTP's TLS implementation. Please go through the steps outlined
            in the <a href="troubleshooting-ssl.html">Troubleshooting TLS guide</a> to gather
            more information first.
          </p>
        </doc:subsection>

        <doc:subsection name="known-compatibility-issues">
          <doc:heading>Known Incompatibilities and Limitations</doc:heading>
          <p>
            If elliptic curve cryptography (ECC) cipher suites is
            expected to be used, a recent <a href="/which-erlang.html">supported Erlang release</a>
            is highly recommended. Earlier releases have known limitations around ECC support.
          </p>
          <p>
            If you face the above limitations or any other incompatibilities,
            use the TLS termination option (see above).
          </p>
          <p>
            For Windows XP users running RabbitMQ as a service: It is not possible to
            use SSL with RabbitMQ running as a service on Windows XP in combination with
            OpenSSL versions 0.9.8 or later. The bug has been confirmed on Windows XP SP3
            with OpenSSL v0.9.8r and v1.0.0d. Suggested workarounds if you want to run RabbitMQ
            as a service is to upgrade to a later Windows release or downgrade to an earlier version of
            OpenSSL (v0.9.7e is known to work).
          </p>
        </doc:subsection>
      </doc:section>


      <doc:section>
        <doc:heading>The Short Route to Generating a CA, Certificates, and Keys</doc:heading>
        <p>
          This guide walks you through the process of setting up a <a
          href="https://en.wikipedia.org/wiki/Certificate_authority">Certificate
          Authority</a> and using it to generate client and server
          certificate/key pairs. Keys and certificates are necessary
          for RabbitMQ and clients that connect to the server on a
          TLS-enabled port. However, the process is fairly labourious
          and can be error-prone. An easier way of generating all that
          stuff on MacOS or Linux is with <a
          href="https://github.com/michaelklishin/tls-gen">tls-gen</a>:
          you will need <code>Python 3.4+</code>, <code>make</code> and <code>openssl</code>
          in <code>PATH</code>.
        </p>
        <p>
          Note that <code>tls-gen</code> and the certificate/key pairs
          it generates are self-signed and only suitable for development
          and test environments. The vast majority of production environments
          should use certificates and keys issued by a well known commercial
          CA.
        </p>
        <p>
          <code>tls-gen</code> supports RSA and <a href="https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/">Elliptic Curve Cryptography</a> algorithms for key generation.
        </p>
      </doc:section>

      <doc:section name="keys-and-certs">
        <doc:heading>Keys, Certificates and CA Certificates</doc:heading>
          <p>
            TLS is a large and complex topic. For a thorough understanding of
            TLS, OpenSSL and how to get the most out of it, we would recommend the use
            of other resources, for example <a class="extlink" href="http://oreilly.com/catalog/9780596002701/">Network Security with
            OpenSSL</a>.
          </p>
          <p>
            TLS can be used simply to establish an encrypted communication
            channel, but can additionally exchange signed certificates between the
            end points of the channel, and those certificates can optionally be
            verified. The verification of a certificate requires establishing a
            chain of trust from a known, trusted <i>root</i> certificate, and the
            certificate presented. The <i>root</i> certificate is a self-signed
            certificate, made available by a <i>Certificate Authority</i>. These
            exist as commercial companies, and will, for a fee, sign TLS (x509)
            certificates that you have generated.
          </p>

          <p>
            For the purposes of this guide, we will start by creating our own
            <i>Certificate Authority</i>. Once we have done this, we will generate
            signed certificates for the server and clients, in a number of
            formats. These will we then use with the Java, .Net and Erlang AMQP
            clients. Note that Mono has more stringent requirements on OpenSSL
            certificates (and a few bugs too), so we will be specifying slightly
            more stringent key usage constraints than is normally necessary.
          </p>
<pre class="sourcecode bash">
mkdir testca
cd testca
mkdir certs private
chmod 700 private
echo 01 &gt; serial
touch index.txt
</pre>
          <p>
            Now place the following in <code>openssl.cnf</code> within the <code>testca</code>
            directory we've just created:
          </p>

<pre class="sourcecode ini">
[ ca ]
default_ca = testca

[ testca ]
dir = .
certificate = $dir/cacert.pem
database = $dir/index.txt
new_certs_dir = $dir/certs
private_key = $dir/private/cakey.pem
serial = $dir/serial

default_crl_days = 7
default_days = 365
default_md = sha256

policy = testca_policy
x509_extensions = certificate_extensions

[ testca_policy ]
commonName = supplied
stateOrProvinceName = optional
countryName = optional
emailAddress = optional
organizationName = optional
organizationalUnitName = optional
domainComponent = optional

[ certificate_extensions ]
basicConstraints = CA:false

[ req ]
default_bits = 2048
default_keyfile = ./private/cakey.pem
default_md = sha256
prompt = yes
distinguished_name = root_ca_distinguished_name
x509_extensions = root_ca_extensions

[ root_ca_distinguished_name ]
commonName = hostname

[ root_ca_extensions ]
basicConstraints = CA:true
keyUsage = keyCertSign, cRLSign

[ client_ca_extensions ]
basicConstraints = CA:false
keyUsage = digitalSignature,keyEncipherment
extendedKeyUsage = 1.3.6.1.5.5.7.3.2

[ server_ca_extensions ]
basicConstraints = CA:false
keyUsage = digitalSignature,keyEncipherment
extendedKeyUsage = 1.3.6.1.5.5.7.3.1
</pre>
          <p>
            Now we can generate the key and certificates that our test
            <i>Certificate Authority</i> will use. Still within the <code>testca</code>
            directory:
          </p>

<pre class="sourcecode bash">
openssl req -x509 -config openssl.cnf -newkey rsa:2048 -days 365 \
    -out cacert.pem -outform PEM -subj /CN=MyTestCA/ -nodes
openssl x509 -in cacert.pem -out cacert.cer -outform DER
</pre>

          <p>
            This is all that is needed to generate our test <i>Certificate
            Authority</i>. The <i>root</i> certificate is in <code>testca/cacert.pem</code>
            and is also in <code>testca/cacert.cer</code>. These two files contain the
            same information, but in different formats. Whilst the vast majority
            of the world is perfectly happy to use the <i>PEM</i> format, Microsoft
            and Mono like to be different, and so use the <i>DER</i> format.
          </p>
          <p>
            Having set up our <i>Certificate Authority</i>, we now need to generate
            keys and certificates for the clients and the server. The Erlang
            client and the RabbitMQ broker are both able to use <i>PEM</i> files
            directly.  They will both be informed of three files: the <i>root</i>
            certificate, which is implicitly trusted, the private key, which is
            used to prove ownership of the public certificate being presented, and
            the public certificate itself, which identifies the peer.
          </p>
          <p>
            For convenience, we provide to the Java and .Net clients, a <i>PKCS
            #12</i> store, which contains both the client's certificate and key. The
            <i>PKCS store</i> is usually password protected itself, and so that
            password must also be provided.
          </p>
          <p>
            The process for creating server and client certificates is very
            similar. First the server:
          </p>
<pre class="sourcecode bash">
cd ..
ls
# => testca
mkdir server
cd server
openssl genrsa -out key.pem 2048
openssl req -new -key key.pem -out req.pem -outform PEM \
    -subj /CN=$(hostname)/O=server/ -nodes
cd ../testca
openssl ca -config openssl.cnf -in ../server/req.pem -out \
    ../server/cert.pem -notext -batch -extensions server_ca_extensions
cd ../server
openssl pkcs12 -export -out keycert.p12 -in cert.pem -inkey key.pem \
    -passout pass:MySecretPassword
</pre>

          <p>
          And now the client:
<pre class="sourcecode bash">
cd ..
ls
# => server testca
mkdir client
cd client
openssl genrsa -out key.pem 2048
openssl req -new -key key.pem -out req.pem -outform PEM \
    -subj /CN=$(hostname)/O=client/ -nodes
cd ../testca
openssl ca -config openssl.cnf -in ../client/req.pem -out \
    ../client/cert.pem -notext -batch -extensions client_ca_extensions
cd ../client
openssl pkcs12 -export -out keycert.p12 -in cert.pem -inkey key.pem \
    -passout pass:MySecretPassword
</pre>
          </p>
          <p>
            The two examples above generate private keys that are 2048 bits in size.
            It is possible to use longer (and thus more secure but also slower to generate)
            keys by providing a different value to <code>openssl genrsa</code>, e.g.:

<pre class="sourcecode bash">
openssl genrsa -out key.pem 4096
</pre>
          </p>
          <p>
            Another option would be to generate a key using <a href="https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/">Elliptic Curve Cryptography</a>. Instead of <code>openssl genrsa</code> use
            <code>openssl ecparam</code> like so:

<pre class="sourcecode bash">
openssl ecparam -out key.pem -genkey -name prime256v1
</pre>

            <code>prime256v1</code> in the example above is an elliptic curve name.
            Different versions of OpenSSL will have a different set of curves available,
            list them with <code>openssl ecparam -list_curves</code>.
          </p>
      </doc:section>

      <doc:section name="enabling-ssl">
        <doc:heading>Enabling TLS Support in RabbitMQ</doc:heading>

          <p>To enable the SSL/TLS support in RabbitMQ, we need to
          provide to RabbitMQ the location of the <i>root</i>
          certificate, the server's certificate file, and the server's
          key. We also need to tell it to listen on a socket that is
          going to be used for TLS connections, and we need to tell it
          whether it should ask for clients to present certificates,
          and if the client does present a certificate, whether we
          should accept the certificate if we can't establish a chain
          of trust to it. These settings are controlled by
          severalconfiguration keys:</p>

          <ul class="plain">
            <li>
              <code>listeners.ssl</code>: this is a list of ports to listen on for TLS
              connections. RabbitMQ can listen on a single interface or multiple ones.
            </li>
            <li>
              <code>ssl_options.cacertfile</code>: Certificate Authority (CA) certificate file path
            </li>
            <li>
              <code>ssl_options.certfile</code>: server certificate file path
            </li>
            <li>
              <code>ssl_options.keyfile</code>: server private key file path
            </li>
            <li>
              <code>ssl_options.verify</code>: controls peer verification mode
            </li>
            <li>
              <code>ssl_options.fail_if_no_peer_cert</code>: when set to true, TLS connection
              will be rejected if client fails to provide a certificate
            </li>
          </ul>

          <p>
            The simplest way to set these options, is to edit the <a
            href="configure.html#configuration-file">configuration
            file</a>.  An example of the config file is below, which
            will start one ssl_listener on port 5671 on all interfaces
            on this hostname:
          </p>

<pre class="sourcecode ini">
listeners.ssl.default = 5671

ssl_options.cacertfile = /path/to/testca/cacert.pem
ssl_options.certfile = /path/to/server/cert.pem
ssl_options.keyfile = /path/to/server/key.pem
ssl_options.verify = verify_peer
ssl_options.fail_if_no_peer_cert = false
</pre>

Below is the same example using the <a href="/configure.html#erlang-term-config-file">classic config format</a>:

<pre class="sourcecode erlang">
[
  {rabbit, [
     {ssl_listeners, [5671]},
     {ssl_options, [{cacertfile,"/path/to/testca/cacert.pem"},
                    {certfile,"/path/to/server/cert.pem"},
                    {keyfile,"/path/to/server/key.pem"},
                    {verify,verify_peer},
                    {fail_if_no_peer_cert,false}]}
   ]}
].
</pre>

          <p>
            <b>Note to Windows users:</b> Backslashes ("\") in the
            configuration file are interpreted as escape sequences -
            so for example to specify the
            path <code>c:\cacert.pem</code> for the CA certificate you
            would need to use <code>"c:\\cacert.pem"</code> or <code>"c:/cacert.pem"</code>.
          </p>

          <p>When a web browser connects to an HTTPS web server, the
          server presents its public certificate, the web browser
          attempts to establish a chain of trust between the root
          certificates the browser is aware of and the server's
          certificate, and all being well, an encrypted communication
          channel is established. Although not used normally by web
          browsers and web servers, TLS allows the server to ask the
          client to present a certificate. In this way the server can
          verify that the client is who they say they are.</p>

          <p>This policy of whether or not the server asks for a
          certificate from the client, and whether or not they demand
          that they are able to trust the certificate, is what the
          <code>verify</code> and <code>fail_if_no_peer_cert</code>
          arguments control. By setting
          the <code>fail_if_no_peer_cert</code> option to <code>false</code>, we state
          that we're prepared to accept clients which don't have a
          certificate to send us, but through the
          <code>verify</code> option set to <code>verify_peer</code>, we state that if
          the client does send us a certificate, we must be able to
          establish a chain of trust to it.</p>

          <p>Note that if the <code>verify_none</code> mode is used,
          no certificate exchange takes place from the client to the
          server and <code>rabbitmqctl list_connections</code> will
          output empty strings for the peer certificate info
          items.</p>

          <p>After starting the broker, you should then see the
          following in the <code>rabbit.log</code>:</p>
          <pre class="sourcecode">
=INFO REPORT==== 9-Aug-2010::15:10:55 ===
started TCP Listener on 0.0.0.0:5672

=INFO REPORT==== 9-Aug-2010::15:10:55 ===
started SSL Listener on 0.0.0.0:5671</pre>
          <p>Also, take note of the last line, which shows that RabbitMQ server is
          up and running and listening for ssl connections.</p>

        <doc:subsection name="clients-root">
          <doc:heading>Trust the Client's Root CA</doc:heading>
          <p>Currently, we're telling RabbitMQ to look at the <code>testca/cacert.pem</code> file. This contains just the public certificate of
          our test <i>Certificate Authority</i>. We may have certificates being
          presented by clients which have been signed by several different
          <i>Certificate Authorities</i>, and we wish RabbitMQ to trust all of
          them. Therefore, we can simply append these certificates to one
          another and provide the path to this new file as the <code>cacerts</code>
          argument to RabbitMQ:</p>
<pre class="sourcecode bash">
cat testca/cacert.pem &gt;&gt; all_cacerts.pem
cat otherca/cacert.pem &gt;&gt; all_cacerts.pem
</pre>

          <p>and so forth.</p>
        </doc:subsection>

        <doc:subsection name="peer-verification">
          <doc:heading>TLS Peer Verification: Who Do You Say You Are?</doc:heading>
            <p>
              TLS offers peer verification (validation), a way for client and server to
              verify each other's identity based on peer's certificate information.
              When peer verification is enabled, typically the <em class="">hostname</em> of the server
              you're connecting to needs to match the <em class="">CN (Common Name)</em> field on
              the server's certificate, otherwise the certificate will be
              rejected. However, peer verification doesn't have to be limited to just CN
              and hostname matching in general.
            </p>
            <p>
              This is why the commands at the start of this guide specify
              <code>...-subj /CN=$(hostname)/...</code> which dynamically looks up your
              hostname. If you're generating certificates on one machine, and using
              them on the other then be sure to swap out the <code>$(hostname)</code>
              section, and replace it with the correct hostname for your server.
            </p>
            <p>
              On the server end, peer verification is primarily controlled using two <code>rabbit.ssl_options</code>
              options: <code>verify</code> and <code>fail_if_no_peer_cert</code>. For example, the following
              config will perform peer verification and reject clients that do not provide
              a certificate:

<pre class="sourcecode erlang">
[
  {rabbit, [
     {ssl_listeners, [5671]},
     {ssl_options, [{cacertfile,"/path/to/testca/cacert.pem"},
                    {certfile,"/path/to/server/cert.pem"},
                    {keyfile,"/path/to/server/key.pem"},
                    {verify, verify_peer},
                    {fail_if_no_peer_cert, true}]}
   ]}
].
</pre>
            </p>
            <p>
              How exactly peer verification is configured in client libraries varies from library to library.
            </p>
            <p>
              Peer verification is highly recommended in production environments. With careful consideration,
              disabling it can make sense in certain environments (e.g. development).
            </p>
        </doc:subsection>

        <doc:subsection name="private-key-passwords">
          <doc:heading>Providing Private Key Password</doc:heading>
          <p>
            It is possible to provide a password for private key using the <code>password</code> option:

<pre class="sourcecode ini">
listeners.ssl.1 = 5671
ssl_options.cacertfile = /path/to/ca_certificate.pem
ssl_options.certfile   = /path/to/server_certificate.pem
ssl_options.keyfile    = /path/to/server_key.pem
ssl_options.password   = t0p$3kRe7
</pre>

The same example using the <a href="/configure.html#erlang-term-config-file">classic config format</a>:

<pre class="sourcecode erlang">
[
 {rabbit, [
           {ssl_listeners, [5671]},
           {ssl_options, [{cacertfile,"/path/to/ca_certificate.pem"},
                          {certfile,  "/path/to/server_certificate.pem"},
                          {keyfile,   "/path/to/server_key.pem"},
                          {password,  "t0p$3kRe7"}
                         ]}
          ]}
].
</pre>

          </p>
        </doc:subsection>

        <doc:subsection name="disabling-tls-versions">
          <doc:heading>Disabling TLS Versions via Configuration</doc:heading>
          <p>
            To limit enabled SSL/TLS protocol versions, use the <code>versions</code> option.
          </p>

Using the <a href="/configure.html#config-file">standard config</a>:

<pre class="sourcecode ini">
listeners.ssl.1 = 5671
ssl_options.cacertfile = /path/to/ca_certificate.pem
ssl_options.certfile   = /path/to/server_certificate.pem
ssl_options.keyfile    = /path/to/server_key.pem
ssl_options.versions.1 = tlsv1.2
ssl_options.versions.2 = tlsv1.1
ssl_options.versions.3 = tlsv1
</pre>

Using the <a href="/configure.html#advanced-config-file">advanced config</a>:

<pre classic="sourcecode">
%% advanced config here is only used to configure TLS versions
[{ssl, [{versions, ['tlsv1.2', 'tlsv1.1', tlsv1]}]}].
</pre>

Using <a href="/configure.html#erlang-term-config-file">classic config format</a>:

            To limit enabled TLS (SSL protocol versions, use the <code>versions</code> option:
<pre class="sourcecode erlang">
%% Disable SSLv3.0 support, leaves TLSv1.0 enabled.
[
 {ssl, [{versions, ['tlsv1.2', 'tlsv1.1', tlsv1]}]},
 {rabbit, [
           {ssl_listeners, [5671]},
           {ssl_options, [{cacertfile,"/path/to/ca_certificate.pem"},
                          {certfile,  "/path/to/server_certificate.pem"},
                          {keyfile,   "/path/to/server_key.pem"},
                          {versions, ['tlsv1.2', 'tlsv1.1', tlsv1]}
                         ]}
          ]}
].
</pre>

The examples below disable SSLv3.0 and TLSv1.0 support.

Using the <a href="/configure.html#config-file">standard config</a>:

<pre class="sourcecode ini">
listeners.ssl.1 = 5671
ssl_options.cacertfile = /path/to/ca_certificate.pem
ssl_options.certfile   = /path/to/server_certificate.pem
ssl_options.keyfile    = /path/to/server_key.pem
ssl_options.versions.1 = tlsv1.2
ssl_options.versions.2 = tlsv1.1
</pre>

Using the <a href="/configure.html#advanced-config-file">advanced config</a>:

<pre classic="sourcecode">
[{ssl, [{versions, ['tlsv1.2', 'tlsv1.1']}]}].
</pre>

Using <a href="/configure.html#erlang-term-config-file">classic config format</a>:

<pre class="sourcecode erlang">
%% Disable SSLv3.0 and TLSv1.0 support.
[
 {ssl, [{versions, ['tlsv1.2', 'tlsv1.1']}]},
 {rabbit, [
           {ssl_listeners, [5671]},
           {ssl_options, [{cacertfile,"/path/to/ca_certificate.pem"},
                          {certfile,  "/path/to/server_certificate.pem"},
                          {keyfile,   "/path/to/server_key.pem"},
                          {versions, ['tlsv1.2', 'tlsv1.1']}
                         ]}
          ]}
].
</pre>
        </doc:subsection>



        <doc:subsection name="verifying-tls-versions">
          <doc:heading>Verifying Enabled TLS Versions</doc:heading>

          To verify provided TLS versions, use <code>openssl s_client</code>:

<pre class="sourcecode bash">
# connect using SSLv3
openssl s_client -connect 127.0.0.1:5671 -ssl3
</pre>

<pre class="sourcecode bash">
# connect using TLSv1.0 through v1.2
openssl s_client -connect 127.0.0.1:5671 -tls1
</pre>

         and look for the following in the output:

<pre class="sourcecode">
SSL-Session:
  Protocol  : TLSv1
</pre>
        </doc:subsection>

        <doc:subsection name="configuring-tls-settings-in-java-client">
          <doc:heading>Configuring TLS Version in Java Client</doc:heading>

          <p>
            Since RabbitMQ server can be configured to support only specific TLS versions,
            it may be necessary to configure preferred TLS version in the Java client. This is done using
            the <code>ConnectionFactory#useSslProtocol</code> overloads that accept a protocol version name
            or a <code>SSLContext</code>:

            <pre class="sourcecode java">
ConnectionFactory factory = new ConnectionFactory();
factory.setHost(&quot;localhost&quot;);
factory.setPort(5671);

factory.useSslProtocol("TLSv1.2");</pre>
          </p>

          <p>
            As of Java client 3.6.4, the library will attempt to use the latest TLS version
            supported by the runtime.
          </p>
        </doc:subsection>

        <doc:subsection name="tls-version-support-in-jdk-and-net">
          <doc:heading>TLS Version Support Table for JDK and .NET</doc:heading>

          <p>Disabling TLSv1.0 limits the number of client platforms supported. Below is a table that
          explains what TLS versions are supported by what JDK and .NET releases.</p>

          <table>
            <thead>
              <td>TLS version</td>
              <td>Minimum JDK version</td>
              <td>Minimum .NET version</td>
            </thead>
            <tr>
              <td>TLS 1.0</td>
              <td>JDK 5 (RabbitMQ Java client requires &minimum-jdk-version;)</td>
              <td>.NET 2.0 (RabbitMQ .NET client requires &minimum-dotnet-version;)</td>
            </tr>
            <tr>
              <td>TLS 1.1</td>
              <td>JDK 7 (see <a href="http://docs.oracle.com/javase/7/docs/technotes/guides/security/SunProviders.html#SunJSSEProvider">Protocols</a>,
              <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/security/enhancements-8.html">JDK 8 recommended</a>)</td>
              <td>.NET 4.5</td>
            </tr>
            <tr>
              <td>TLS 1.2</td>
              <td>JDK 7 (see <a href="http://docs.oracle.com/javase/7/docs/technotes/guides/security/SunProviders.html#SunJSSEProvider">Protocols</a>,
              <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/security/enhancements-8.html">JDK 8 recommended</a>)</td>
              <td>.NET 4.5</td>
            </tr>
          </table>

          <ul>
            <li><a href="http://msdn.microsoft.com/en-us/library/system.security.authentication.sslprotocols(v=vs.110).aspx">.NET versions source</a>.</li>
            <li><a href="http://docs.oracle.com/javase/7/docs/technotes/guides/security/SunProviders.html#SunJSSEProvider">JDK versions source</a>.</li>
          </ul>
        </doc:subsection>

        <doc:subsection name="configuring-ciphers">
          <doc:heading>Configuring Cipher Suites</doc:heading>

          <p>
            It is possible to configure what cipher suites will be used by RabbitMQ. Note that not all
            suites will be available on all systems. For example, to use elliptic curve ciphers,
            please run the most recent <a href="/which-erlang.html">supported Erlang release</a> available.

            The below examples demonstrates how the <code>ciphers</code> TLS option is used.
          </p>

Cipher suites can only be configured using the <a href="/configure.html#advanced-config-file">advanced config</a>
file or the <a href="/configure.html#erlang-term-config-file">classic config format</a>:

<pre class="sourcecode erlang">
%% List allowed ciphers
[
 {ssl, [{versions, ['tlsv1.2', 'tlsv1.1']}]},
 {rabbit, [
           {ssl_listeners, [5671]},
           {ssl_options, [{cacertfile,"/path/to/ca_certificate.pem"},
                          {certfile,  "/path/to/server_certificate.pem"},
                          {keyfile,   "/path/to/server_key.pem"},
                          {versions, ['tlsv1.2', 'tlsv1.1']},
                          %% This list is just an example!
                          %% Not all cipher suites are available on all machines.
                          %% Cipher suite order is important: preferred suites
                          %% should be listed first.
                          %% Different suites have different security and CPU load characteristics.
                          {ciphers,  [
                                      {ecdhe_ecdsa,aes_256_gcm,null,sha384},
                                      {ecdhe_rsa,aes_256_gcm,null,sha384},
                                      {ecdhe_ecdsa,aes_256_cbc,sha384,sha384},
                                      {ecdhe_rsa,aes_256_cbc,sha384,sha384},
                                      {ecdh_ecdsa,aes_256_gcm,null,sha384},
                                      {ecdh_rsa,aes_256_gcm,null,sha384},
                                      {ecdh_ecdsa,aes_256_cbc,sha384,sha384},
                                      {ecdh_rsa,aes_256_cbc,sha384,sha384},
                                      {dhe_rsa,aes_256_gcm,null,sha384},
                                      {dhe_dss,aes_256_gcm,null,sha384},
                                      {dhe_rsa,aes_256_cbc,sha256},
                                      {dhe_dss,aes_256_cbc,sha256},
                                      {rsa,aes_256_gcm,null,sha384},
                                      {rsa,aes_256_cbc,sha256},
                                      {ecdhe_ecdsa,aes_128_gcm,null,sha256},
                                      {ecdhe_rsa,aes_128_gcm,null,sha256},
                                      {ecdhe_ecdsa,aes_128_cbc,sha256,sha256},
                                      {ecdhe_rsa,aes_128_cbc,sha256,sha256},
                                      {ecdh_ecdsa,aes_128_gcm,null,sha256},
                                      {ecdh_rsa,aes_128_gcm,null,sha256},
                                      {ecdh_ecdsa,aes_128_cbc,sha256,sha256},
                                      {ecdh_rsa,aes_128_cbc,sha256,sha256},
                                      {dhe_rsa,aes_128_gcm,null,sha256},
                                      {dhe_dss,aes_128_gcm,null,sha256},
                                      {dhe_rsa,aes_128_cbc,sha256},
                                      {ecdh_rsa,aes_128_gcm,null,sha256}
                                     ]}
                         ]}
          ]}
].
</pre>

          <p>
            To list all cipher suites supported by installed Erlang runtime, use

<pre class="sourcecode bash">
rabbitmqctl eval 'ssl:cipher_suites().'
</pre>

            the output uses Erlang terms and thus can be copied into
            RabbitMQ's <a href="/configure.html">classic or advanced config file</a>.
          </p>

          <p>The same suites can be listed in the OpenSSL format:</p>

<pre class="sourcecode bash">
rabbitmqctl eval 'ssl:cipher_suites(openssl).'
</pre>

          <p>
            An <a href="https://github.com/erlang/otp/wiki/Cipher-suite-correspondence-table">IANA and Erlang/OTP cipher suite correspondence table</a>
            can be used to find corresponding values in both formats.
          </p>

          <p>
            When overriding cipher suites, it is highly recommended
            that server-preferred cipher suite ordering is enforced
            (see the following section).
          </p>
        </doc:subsection>

        <doc:subsection name="cipher-suite-order">
          <doc:heading>Cipher Suite Order</doc:heading>

          <p>
            During TLS connection negotiation, the server and the client negotiate
            what cipher suite will be used. It is possible to force server's TLS
            implementation to dictate its preference (cipher suite order) to avoid
            malicious clients that intentionally negotiate weak cipher suites in
            preparation for running an attack on them.
            To do so, configure <code>honor_cipher_order</code>
            and <code>honor_ecc_order</code> to <code>true</code>:
          </p>

<pre class="sourcecode ini">
listeners.ssl.1 = 5671
ssl_options.cacertfile = /path/to/ca_certificate.pem
ssl_options.certfile   = /path/to/server_certificate.pem
ssl_options.keyfile    = /path/to/server_key.pem
ssl_options.versions.1 = tlsv1.2
ssl_options.versions.2 = tlsv1.1

ssl_options.honor_cipher_order = true
ssl_options.honor_ecc_order    = true
</pre>

Or, in the classic config format:

<pre class="sourcecode erlang">
%% Enforce server-provided cipher suite order (preference)
[
 {ssl, [{versions, ['tlsv1.2', 'tlsv1.1']}]},
 {rabbit, [
           {ssl_listeners, [5671]},
           {ssl_options, [{cacertfile, "/path/to/ca_certificate.pem"},
                          {certfile,   "/path/to/server_certificate.pem"},
                          {keyfile,    "/path/to/server_key.pem"},
                          {versions,   ['tlsv1.2', 'tlsv1.1']},

                          %% ...


                          {honor_cipher_order,   true},
                          {honor_ecc_order,      true},
                         ]}
          ]}
].
</pre>
        </doc:subsection>
      </doc:section>


      <doc:section name="major-vulnerabilities">
        <doc:heading>Known TLS Vulnerabilities and Their Mitigation</doc:heading>
        <h4>ROBOT</h4>
        <p>
          <a href="https://robotattack.org/">ROBOT attack</a> affects RabbitMQ installations that rely on RSA
          cipher suites and run on Erlang/OTP versions prior to
          19.3.6.4 and 20.1.7. To mitigate, <a href="/which-erlang.html">upgrade Erlang/OTP</a> to a patched version
          and consider <a href="#configuring-ciphers">limiting the list of supported cipher suites</a>.
        </p>

        <h4>POODLE</h4>
        <p>
            <a href="https://www.openssl.org/~bodo/ssl-poodle.pdf">POODLE</a> is a known SSL/TLS attack that originally compromised SSLv3.
            Starting with version 3.4.0, RabbitMQ server refuses to accept SSLv3 connections. In December 2014, a modified version of
            the POODLE attack that affects TLSv1.0 was <a href="https://www.imperialviolet.org/2014/12/08/poodleagain.html">announced</a>.
            It is therefore recommended to either run Erlang 18.0 or later, which
            <a href="http://www.erlang.org/news/88">eliminates TLS 1.0 implementation vulnerability to POODLE</a>,
            or <a href="#disabling-tls-versions">disable TLSv1.0 support</a>.
        </p>

        <h4>BEAST</h4>
        <p>
            <a href="http://en.wikipedia.org/wiki/Transport_Layer_Security#BEAST_attack">BEAST attack</a> is a known vulnerability that
            affects TLSv1.0. To mitigate it, <a href="#disabling-tls-versions">disable TLSv1.0 support</a>.
        </p>
      </doc:section>


      <doc:section name="trust-levels">
        <doc:heading>Levels of Trust</doc:heading>
          <p>When setting up an SSL connection there are two important stages in
          the protocol.</p>
          <p>The first stage is when the peers <em class="">optionally</em> exchange
          certificates. Having exchanged certificates, the peers can <em class="">optionally</em> attempt to establish a chain of trust between their root
          certificates, and the certificates presented. This acts to verify that
          the peer is who it claims to be (provided the private key hasn't been
          stolen!).</p>
          <p>The second stage is where the peers negotiate a symmetric encryption
          key that will be used for the rest of the communication. If
          certificates were exchanged, the public/private keys will be used in
          the key negotiation.</p>
          <p>Thus you can create an encrypted SSL connection <em class="">without</em> having to
          verify certificates. The Java client supports both modes of operation.</p>



        <doc:subsection name="managers-and-stores">
          <doc:heading>Key Managers, Trust Managers and Stores</doc:heading>
            <p>There are three components to be aware of in the Java security
            framework: Key Manager, Trust Manager and Key Store.</p>
            <p>A Key Manager is used by a peer to manage its certificates. This means
            that in a session set-up, the Key Manager will control which
            certificates to send to the remote peer.</p>
            <p>A Trust Manager is used by a peer to manage remote certificates. This
            means that in a session set-up, the Trust Manager will control which
            certificates are trusted from a remote peer.</p>
            <p>A Key Store is a Java encapsulation of certificates. Java needs all
            certificates to either be converted into a Java specific binary format
            or to be in the PKCS#12 format. These formats are managed using the
            Key Store class. For the server certificate, we'll use the Java binary
            format, but for client key/certificate pair, we'll use the PKCS#12
            format.</p>
        </doc:subsection>
        <doc:subsection name="connecting-without-validating">
          <doc:heading>Connecting without validating certificates</doc:heading>
            <p>Our first example will show a simple client, connecting to a RabbitMQ
            server over SSL <em class="">without</em> validating the server certificate, and
            without presenting any client certificate.</p>
<pre class="sourcecode java">
import java.io.*;
import java.security.*;


import com.rabbitmq.client.*;

public class Example1
{
    public static void main(String[] args) throws Exception
    {

        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;localhost&quot;);
        factory.setPort(5671);

        factory.useSslProtocol();
        // Tells the library to setup the default Key and Trust managers for you
        // which do not do any form of remote server trust verification

        Connection conn = factory.newConnection();
        Channel channel = conn.createChannel();

        //non-durable, exclusive, auto-delete queue
        channel.queueDeclare(&quot;rabbitmq-java-test&quot;, false, true, true, null);
        channel.basicPublish(&quot;&quot;, &quot;rabbitmq-java-test&quot;, null, &quot;Hello, World&quot;.getBytes());


        GetResponse chResponse = channel.basicGet(&quot;rabbitmq-java-test&quot;, false);
        if(chResponse == null) {
            System.out.println(&quot;No message retrieved&quot;);
        } else {
            byte[] body = chResponse.getBody();
            System.out.println(&quot;Recieved: &quot; + new String(body));
        }


        channel.close();
        conn.close();
    }
}</pre>

            <p>This simple example is an echo test. It creates a channel <code>rabbitmq-java-test</code> and publishes to the default direct exchange, then
            reads back what has been published and echoes it out. Note that we use
            an exclusive, non-durable, auto-delete queue so we don't have to worry
            about manually cleaning up after ourselves.</p>
        </doc:subsection>


        <doc:subsection name="validating-cerficates">
          <doc:heading>Presenting and validating certificates</doc:heading>
            <p>First, we set-up our Key Store. We'll assume that we have the
            certificate for the server we want to connect to, so we now need to
            add it to our Key Store which we will use for the Trust Manager.</p>
<pre class="sourcecode bash">
keytool -import -alias server1 -file /path/to/server/cert.pem -keystore /path/to/rabbitstore</pre>

            <p>The above command will import <code>cert.pem</code> into the <code>rabbitstore</code> and will internally refer to it as <code>server1</code>. The
            alias argument is used when you have many certificates or keys, as
            they must all have internally distinct names.</p>
            <p>Be sure to answer <em class="">yes</em> to the question about trusting this
            certificate, and to pick a passphrase. For this example I set my
            passphrase to <code>rabbitstore</code>.</p>

            <p>We then use our client certificate and key in a PKCS#12 file as
            already shown above.</p>
            <p>Our next example will be a modification of the previous one, to now
            use our Key Store with our Key Manager and Trust Manager</p>
<pre class="sourcecode java">
  import java.io.*;
  import java.security.*;
  import javax.net.ssl.*;

  import com.rabbitmq.client.*;


  public class Example2
  {
      public static void main(String[] args) throws Exception
      {

        char[] keyPassphrase = &quot;MySecretPassword&quot;.toCharArray();
        KeyStore ks = KeyStore.getInstance(&quot;PKCS12&quot;);
        ks.load(new FileInputStream(&quot;/path/to/client/keycert.p12&quot;), keyPassphrase);

        KeyManagerFactory kmf = KeyManagerFactory.getInstance(&quot;SunX509&quot;);
        kmf.init(ks, passphrase);

        char[] trustPassphrase = &quot;rabbitstore&quot;.toCharArray();
        KeyStore tks = KeyStore.getInstance(&quot;JKS&quot;);
        tks.load(new FileInputStream(&quot;/path/to/trustStore&quot;), trustPassphrase);

        TrustManagerFactory tmf = TrustManagerFactory.getInstance(&quot;SunX509&quot;);
        tmf.init(tks);

        SSLContext c = SSLContext.getInstance(&quot;TLSv1.1&quot;);
        c.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);

        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;localhost&quot;);
        factory.setPort(5671);
        factory.useSslProtocol(c);

        Connection conn = factory.newConnection();
        Channel channel = conn.createChannel();

        channel.queueDeclare(&quot;rabbitmq-java-test&quot;, false, true, true, null);
        channel.basicPublish(&quot;&quot;, &quot;rabbitmq-java-test&quot;, null, &quot;Hello, World&quot;.getBytes());


        GetResponse chResponse = channel.basicGet(&quot;rabbitmq-java-test&quot;, false);
        if(chResponse == null) {
            System.out.println(&quot;No message retrieved&quot;);
        } else {
            byte[] body = chResponse.getBody();
            System.out.println(&quot;Recieved: &quot; + new String(body));
        }


        channel.close();
        conn.close();
    }
}</pre>

          <p>To ensure that the above code works in the other case, try setting up
          your RabbitMQ server with a certificate that has not been imported
          into the key store and watch the verification exceptions decorate your
          screen.</p>
        </doc:subsection>

      </doc:section>
      <doc:section name="configuring-dotnet">
        <doc:heading>Configuring the .NET client</doc:heading>
          <p>For a server certificate to be understood on the .Net platform, they
          can be in a number of formats including <i>DER</i> and <i>PKCS #12</i>, but
          of course, not <i>PEM</i>. For the <i>DER</i> format, .Net expects them to
          be stored in files with <code>.cer</code> extension. In the steps above, when
          creating the test <i>Certificate Authority</i>, we converted the
          certificate from <i>PEM</i> to <i>DER</i> format using:</p>

<pre class="sourcecode bash">
openssl x509 -in /path/to/testca/cacert.pem -out /path/to/testca/cacert.cer -outform DER
</pre>
          <p>PEM is a base64 encoding of this DER format, enclosed within
          delimiters. This encoding is usually done to make it easier to
          transfer the data over 7-bit limited protocols, such as email (SMTP).</p>


        <doc:subsection name="mono">
          <doc:heading>RFC 5280, Certificate Key Usage and Mono</doc:heading>
          <p>As mentioned above, Mono is rather more stringent than is normal about
          enforcing that certificates are only used for the purposes indicated
          by the certificate itself.</p>
          <p>SSL certificate and keys can be used for a variety of purposes, for
          example, email signing, code signing, traffic encryption, etc. (For
          our purposes, we're interested in TCP Traffic encryption).  RFC 5280
          specifies a number of different purposes, and allows a certificate to
          be signed for a specific set of purposes.</p>
          <p>SSL v3 certificates can contain a number of different extensions. The
          extension that deals with how a certificate can be used is call the
          <i>Key Usage Extension</i>. The various usages permitted are not, in
          general, well supported, or even well defined, and their usage is
          subject to wide interpretation. Some of the key usages have been
          deprecated, and mainly, they're just totally ignored.</p>

          <p>There is a further extension, which also specifies usages, but chooses
          to do so using O.I.Ns, such as "1.3.6.1.5.5.7.3.1". Clearly English is
          lacking something that apparently random numbers add. This is the
          <i>Extended Key Usage</i> extension - a sequence of object identifiers
          that further defines which uses of the certificate are permissible.</p>

          <p>Mono, however, seems to think that these extensions are both
          important, and need to be observed. Mono chooses to invalidate the
          certificate if the certificate omits a <i>Key Usage Extension</i>. By
          default, OpenSSL omits the <i>Key Usage Extension</i> for self-signed
          certificates because it is expected that if no <i>Key Usage Extension</i>
          is found, the certificate is valid to be used for any purpose.</p>

          <p>This is the reason why in the sample <code>openssl.cnf</code> file listed
          above, the extensions specified for <code>root_ca_extensions</code>,
          <code>client_ca_extensions</code> and <code>server_ca_extensions</code>
          all have <code>keyUsage</code> specified, and the latter two also have
          <code>extendedKeyUsage</code> defined. Thus the certificates generated above are
          valid for use by Mono; <code>keyEncipherment</code> specifies that the
          certificate can be used by an SSL Server, and <code>digitalSignature</code>

          specifies that the certificate can be used by an SSL client. The
          values in the <code>extendedKeyUsage</code> fields say the
          same thing.</p>
          <p>You can use <a class="extlink" href="http://gist.github.com/145812">this small tool</a> to
          check that the certificate <i>presented by the RabbitMQ server</i> is
          acceptable to Mono.  Note that you'll need to convert the <code>server/cert.pem</code> to <code>server/cert.cer</code> using an appropriate OpenSSL command:</p>

<pre class="sourcecode bash">
openssl x509 -in /path/to/server/cert.pem -out /path/to/server/cert.cer -outform DER
mono certcheck.exe /path/to/server/cert.
# ...
# => This certificate CAN be used by Mono for Server validation
</pre>
        </doc:subsection>


        <doc:subsection name="tls-verification-in-dotnet">
          <doc:heading>TLS Peer Verification in .NET</doc:heading>
            <p>
              TLS offers peer verification (validation), a way for client and server to
              verify each other's identity based on peer's certificate information.
              When peer verification is enabled, typically the <em class="">hostname</em> of the server
              you're connecting to needs to match the <em class="">CN (Common Name)</em> field on
              the server's certificate, otherwise the certificate will be
              rejected. However, peer verification doesn't have to be limited to just CN
              and hostname matching in general.
            </p>
            <p>
              This is why the commands at the start of this guide specify
              <code>...-subj /CN=$(hostname)/...</code> which dynamically looks up your
              hostname. If you're generating certificates on one machine, and using
              them on the other then be sure to swap out the <code>$(hostname)</code>
              section, and replace it with the correct hostname for your server.
            </p>

            <p>
              On the .NET platform, <a href="http://msdn.microsoft.com/en-us/library/system.net.security.remotecertificatevalidationcallback(v=vs.110).aspx">RemoteCertificateValidationCallback</a>
              controls TLS verification behavior.
            </p>

            <p>
              In RabbitMQ .NET client, <code>RabbitMQ.Client.SslOption.CertificateValidatioNCallback</code>
              can be used to provide a <a href="http://msdn.microsoft.com/en-us/library/system.net.security.remotecertificatevalidationcallback(v=vs.110).aspx">RemoteCertificateValidationCallback</a>
              delegate. The delegate will be used to verify peer (RabbitMQ node) identity using whatever logic fits
              the application.

              If this is not specified, the default callback will be
              used in conjunction with the AcceptablePolicyErrors
              property to determine if the remote server certificate is
              valid.

              The <code>System.Net.Security.SslPolicyErrors.RemoteCertificateNameMismatch</code>
              flag in <code>RabbitMQ.Client.SslOption.AcceptablePolicyErrors</code>
              can be used to disable peer verification (not recommended in production environments!).
            </p>

            <p>
              <code>RabbitMQ.Client.SslOption.CertificateSelectionCallback</code>
              can be used to provide
              a <a href="http://msdn.microsoft.com/en-us/library/system.net.security.localcertificateselectioncallback(v=vs.110).aspx">LocalCertificateSelectionCallback</a>
              that will select the local certificate used for peer verification.
            </p>
        </doc:subsection>

        <doc:subsection name="trust-dotNET">
          <doc:heading>.NET Trust Store</doc:heading>
            <p>On the .NET platform, remote certificates are managed by putting them
            into any of a number of Stores. All management of these stores is done
            with the 'certmgr' tool which is available on both Microsoft's
            .Net implementation and on Mono.</p>
          <p>NB: On some flavours of Windows there are two versions of
            the command - one that ships with the operating system and
            provides a graphical interface only, and one that ships
            with the Windows SDK and provides both a
            graphical and command line interface. Either will do the
            job, but the examples below are based on the latter.</p>
            <p>For our case, because we're supplying the client certificate/key pair
            in a separate PKCS #12 file, all we need to do is to import the
            certificate of the root <i>Certificate Authority</i> into
            the <i>Root</i> (Windows) / <i>Trust</i> (Mono)

            store. All certificates signed by any certificate in that
            store are automatically trusted.
            </p>
            <p>
              In contrast to the Java client, which is happy to use an
              SSL connection without verifying the server's
              certificate, the .NET client by default requires this
              verification to succeed. To suppress verification, an
              application can set
              the <code>System.Net.Security.SslPolicyErrors.RemoteCertificateNotAvailable</code>
              and <code>System.Net.Security.SslPolicyErrors.RemoteCertificateChainErrors</code>
              flags
              in <a href="&url-dotnet-apidoc;/RabbitMQ.Client.SslOption.html">SslOptions</a>.
            </p>
        </doc:subsection>

        <doc:subsubsection name="certmgr">
          <doc:heading>Certificate Management with Certmgr</doc:heading>
          <p><code>certmgr</code> allows us to Add, Delete, List and perform other
          actions on a specified Store. These stores can be per-user stores, or
          machine wide. Only admin users can have write access to the machine
          wide stores.</p>
          <p>To add a certificate to the users Root (Windows) / Trust
          (Mono) store we run:</p>

<pre class="sourcecode bash">
(Windows) > certmgr -add -all \path\to\cacert.cer -s Root
(Mono)    $ certmgr -add -c Trust /path/to/cacert.cer</pre>

          <p>To add a certificate to the machine certificate store instead we
          run</p>
<pre class="sourcecode bash">
(Windows) > certmgr -add -all \path\to\cacert.cer -s -r localMachine Root
(Mono)    $ certmgr -add -c -m Trust /path/to/cacert.cer</pre>
          <p>After adding to a store, we can view the contents of that store with the -list switch:</p>
<pre class="sourcecode bash">
(Windows) > certmgr -all -s Root
(Mono)    $ certmgr -list -c Trust

Mono Certificate Manager - version 2.4.0.0
Manage X.509 certificates and CRL from stores.
Copyright 2002, 2003 Motus Technologies. Copyright 2004-2008 Novell. BSD licensed.

Self-signed X.509 v3 Certificate
  Serial Number: AC3F2B74ECDD9EEA00
  Issuer Name:   CN=MyTestCA
  Subject Name:  CN=MyTestCA
  Valid From:    25/08/2009 14:03:01
  Valid Until:   24/09/2009 14:03:01
  Unique Hash:   1F04D1D2C20B97BDD5DB70B9EB2013550697A05E</pre>
          <p>As we can see, there is one Self-signed X.509 v3 Certificate in the
          trust store. The Unique Hash uniquely identifies this certificate in
          this store. To delete this certificate, use the unique hash:</p>
<pre class="sourcecode bash">
(Windows) > certmgr -del -c -sha1 1F04D1D2C20B97BDD5DB70B9EB2013550697A05E -s Root
(Mono)    $ certmgr -del -c Trust 1F04D1D2C20B97BDD5DB70B9EB2013550697A05E

Mono Certificate Manager - version 2.4.0.0
Manage X.509 certificates and CRL from stores.
Copyright 2002, 2003 Motus Technologies. Copyright 2004-2008 Novell. BSD licensed.

Certificate removed from store.</pre>

          <p>With these simple steps we can go ahead and add/delete/list our root
          certificates to the client side store.</p>
        </doc:subsubsection>


        <doc:subsection name="create-conn">
          <doc:heading>Creating The Connection</doc:heading>
            <p>To create an SSL connection to RabbitMQ, we need to set some new
            fields in the ConnectionFactory's Parameters field.
            To make things
            easier, there is a new Field Parameters.Ssl that acts like a namespace
            for all the other fields that we need to set. The fields are:</p>
            <ul class="plain">
              <li> <code>Ssl.CertPath</code>:
              This is the path to the client's certificate in
              PKCS#12 format if your server expects client side verification. This
              is optional.</li>
              <li> <code>Ssl.CertPassphrase</code>:
              If you are using a client certificate in PKCS#12
              format then it'll probably have a password, which you specify in
              this field.</li>
              <li> <code>Ssl.Enabled</code>: This is a boolean field that turns SSL support on or
              off. It is off by default.</li>
              <li> <code>Ssl.ServerName</code>:
              Remember that .Net expects this to match the CN on
              the certificate that the server sends over.</li>
            </ul>
        </doc:subsection>

        <doc:subsection name="code-snippet">
          <doc:heading>Example</doc:heading>

          <p>
            This is the same example as in the Java section. It
            creates a channel, rabbitmq-dotnet-test and publishes to
            the default direct exchange, then reads back what has been
            published and echoes it out. Note that we use an
            exclusive, non-durable, auto-delete queue so we don't have
            to worry about manually cleaning up after ourselves
          </p>

<pre class="sourcecode csharp">
using System;
using System.IO;
using System.Text;

using RabbitMQ.Client;
using RabbitMQ.Util;

namespace RabbitMQ.Client.Examples {
  public class TestSSL {
    public static int Main(string[] args) {
      ConnectionFactory cf = new ConnectionFactory();

      cf.Ssl.ServerName = System.Net.Dns.GetHostName();
      cf.Ssl.CertPath = "/path/to/client/keycert.p12";
      cf.Ssl.CertPassphrase = "MySecretPassword";
      cf.Ssl.Enabled = true;

      using (IConnection conn = cf.CreateConnection()) {
        using (IModel ch = conn.CreateModel()) {
          ch.QueueDeclare("rabbitmq-dotnet-test", false, false, false, null);
          ch.BasicPublish("", "rabbitmq-dotnet-test", null,
                          Encoding.UTF8.GetBytes("Hello, World"));
          BasicGetResult result = ch.BasicGet("rabbitmq-dotnet-test", true);
          if (result == null) {
            Console.WriteLine("No message received.");
          } else {
            Console.WriteLine("Received:");
            DebugUtil.DumpProperties(result, Console.Out, 0);
          }
          ch.QueueDelete("rabbitmq-dotnet-test");
        }
      }
      return 0;
    }
  }
}
</pre>
          <p>Note that, on Windows XP, running the example may fail
          with
<pre>  CryptographicException: Key not valid for use in specified state.</pre>
          In this case, you may be successful
          in loading the certificate from the certificate store and
          setting <code>ConnectionFactory</code>'s
          <code>Ssl.Certs</code> parameter directly.</p>
        </doc:subsection>

      </doc:section>

      <doc:section name="certificate-chains">
        <doc:heading>Certificate Chains and Verification Depth</doc:heading>
        <p>
          When using a client certificate signed by an intermediate CA, it may be necessary
          to configure RabbitMQ server to use a higher verification depth.

          The depth is the maximum number of non-self-issued intermediate certificates that
          may follow the peer certificate in a valid certification path.
          So if depth is 0 the peer (e.g. client) certificate must be signed by the trusted CA directly,
          if 1 the path can be "peer, CA, trusted CA", if it is 2 "peer, CA, CA, trusted CA", and so on.

          The following example demonstrates how to configure certificate validation depth for
          RabbitMQ server:
<pre class="sourcecode erlang">
[
  {rabbit, [
     {ssl_listeners, [5671]},
     {ssl_options, [{cacertfile,"/path/to/testca/cacert.pem"},
                    {certfile,"/path/to/server/cert.pem"},
                    {keyfile,"/path/to/server/key.pem"},
                    {depth, 2},
                    {verify,verify_peer},
                    {fail_if_no_peer_cert,false}]}
   ]}
].
</pre>
        </p>
        <p>When using RabbitMQ plugins such as federation or shovel with TLS, it may be necessary
        to configure verification depth for the Erlang client, as explained below.</p>
      </doc:section>

      <doc:section name="tls-evaluation-tools">
        <doc:heading>Evaluating TLS Setups</doc:heading>
          <p>
            Because TLS has many configurable parameters
            and some of them have suboptimal defaults for historical
            reasons, TLS setup evaluation is a recommended practice.
            Multiple tools exist that perform various tests on TLS-enabled
            server endpoints, for example, testing whether it is prone
            to known attacks such as POODLE, BEAST, and others.
          </p>

        <doc:subsection name="testssl-sh">
          <doc:heading>testssl.sh</doc:heading>
          <p>
            <a href="https://testssl.sh/">testssl.sh</a> is a mature and extensive TLS endpoint testing
            tool that can be used with protocol endpoints that do not serve HTTP.
            Note that the tool performs many tests (for instance, on some machines it runs
            over 350 cipher suite tests alone) and passing every single one may or may not
            make sense for every environment. For example, many production deployments
            do not use CRLs (Certificate Revocation Lists); most development environments
            use self-signed certificates and don't have to worry about
            the most optimal set of cipher suites enabled; and so on.
          </p>
          <p>
            The following example configuration (in the classic config format) passes key testssl tests on Erlang 19.3 or later
            versions:

            <pre class="sourcecode erlang">
[
 {ssl,    [
           {versions,           ['tlsv1.2']},
           {secure_renegotiate, true}
          ]},
 {rabbit, [
           {ssl_listeners, [5671]},
           {ssl_options, [{cacertfile, "/path/to/ca_certificate.pem"},
                          {certfile,   "/path/to/server_certificate.pem"},
                          {keyfile,    "/path/to/server_key.pem"},
                          {versions, ['tlsv1.2']},
                          {ciphers,  [
                                      {ecdhe_ecdsa,aes_256_gcm,null,sha384},
                                      {ecdhe_rsa,aes_256_gcm,null,sha384},
                                      {ecdh_ecdsa,aes_256_gcm,null,sha384},
                                      {ecdh_rsa,aes_256_gcm,null,sha384},
                                      {dhe_rsa,aes_256_gcm,null,sha384},
                                      {rsa,aes_256_gcm,null,sha384},
                                      {ecdhe_ecdsa,aes_128_gcm,null,sha256},
                                      {ecdhe_rsa,aes_128_gcm,null,sha256},
                                      {ecdh_ecdsa,aes_128_gcm,null,sha256},
                                      {ecdh_rsa,aes_128_gcm,null,sha256},
                                      {dhe_rsa,aes_128_gcm,null,sha256},
                                      {ecdh_rsa,aes_128_gcm,null,sha256}
                                     ]},
                          {honor_cipher_order,   true},
                          {honor_ecc_order,      true},
                          {secure_renegotiate,   true},
                          {verify,               verify_peer},
                          {fail_if_no_peer_cert, false}]}
          ]}
].
            </pre>

            For example, this setup is reported as not vulnerable to
            a set of known high profile vulnerabilities:

            <pre class="sourcecode ini">
 Testing vulnerabilities

 Heartbleed (CVE-2014-0160)                not vulnerable (OK), no heartbeat extension
 CCS (CVE-2014-0224)                       not vulnerable (OK)
 Ticketbleed (CVE-2016-9244), experiment.  --   (applicable only for HTTPS)
 Secure Renegotiation (CVE-2009-3555)      not vulnerable (OK)
 Secure Client-Initiated Renegotiation     not vulnerable (OK)
 CRIME, TLS (CVE-2012-4929)                not vulnerable (OK) (not using HTTP anyway)
 POODLE, SSL (CVE-2014-3566)               not vulnerable (OK)
 TLS_FALLBACK_SCSV (RFC 7507)              No fallback possible, TLS 1.2 is the only protocol (OK)
 SWEET32 (CVE-2016-2183, CVE-2016-6329)    not vulnerable (OK)
 FREAK (CVE-2015-0204)                     not vulnerable (OK)
 DROWN (CVE-2016-0800, CVE-2016-0703)      not vulnerable on this port (OK)
                                           make sure you don't use this certificate elsewhere with SSLv2 enabled services
                                           https://censys.io/ipv4?q=D6D88C603E0212109EC14429DCBB4A6B73286F8B7F5C956FE53D1A94A34D88FB could help you to find out
 LOGJAM (CVE-2015-4000), experimental      not vulnerable (OK): no DH EXPORT ciphers, no DH key detected
 BEAST (CVE-2011-3389)                     no SSL3 or TLS1 (OK)
 LUCKY13 (CVE-2013-0169)                   not vulnerable (OK)
 RC4 (CVE-2013-2566, CVE-2015-2808)        no RC4 ciphers detected (OK)
            </pre>
          </p>
        </doc:subsection>
      </doc:section>

      <doc:section name="certificate-chains">
        <doc:heading>Certificate Chains and Verification Depth</doc:heading>
        <p>
          When using a client certificate signed by an intermediate CA, it may be necessary
          to configure RabbitMQ server to use a higher verification depth.

          The depth is the maximum number of non-self-issued intermediate certificates that
          may follow the peer certificate in a valid certification path.
          So if depth is 0 the peer (e.g. client) certificate must be signed by the trusted CA directly,
          if 1 the path can be "peer, CA, trusted CA", if it is 2 "peer, CA, CA, trusted CA", and so on.

          The following example demonstrates how to configure certificate validation depth for
          RabbitMQ server:
<pre class="sourcecode">
listeners.ssl.1 = 5671
ssl_options.cacertfile = /path/to/testca/cacert.pem
ssl_options.certfile   = /path/to/server/cert.pem
ssl_options.keyfile    = /path/to/server/key.pem
ssl_options.depth      = 2
ssl_options.verify     = verify_peer
ssl_options.fail_if_no_peer_cert = false
</pre>

Using the <a href="/configure.html#erlang-term-config-file">classic config format</a>:

<pre class="sourcecode">[
 {rabbit, [
     {ssl_listeners, [5671]},
     {ssl_options, [{cacertfile,"/path/to/testca/cacert.pem"},
                    {certfile,"/path/to/server/cert.pem"},
                    {keyfile,"/path/to/server/key.pem"},
                    {depth, 2},
                    {verify,verify_peer},
                    {fail_if_no_peer_cert,false}]}
   ]}
].
</pre>
        </p>
        <p>When using RabbitMQ plugins such as federation or shovel with TLS, it may be necessary
        to configure verification depth for the Erlang client, as explained below.</p>
      </doc:section>

      <doc:section name="configure-erlang">
        <doc:heading>Configuring the Erlang client</doc:heading>
          <p>Enabling TLS in the RabbitMQ Erlang client is rather
          straightforward. In the <code>#amqp_params_network</code> record, we just need to
          supply values in the <code>ssl_options</code> field. These, you will recognise
          from the options we specified to RabbitMQ.</p>

        <doc:subsection name="erlang-ssl">
          <doc:heading>Erlang TLS Options</doc:heading>
            <p>The three important options which must be supplied are:</p>
            <ul class="plain">
              <li> The <code>cacertfile</code> option specifies the certificates of the root
              <i>Certificate Authorities</i> that we wish to implicitly trust.</li>
              <li> The <code>certfile</code> is the client's own certificate in PEM format</li>
              <li> The <code>keyfile</code> is the client's private key file in PEM format.</li>
            </ul>
            <p><code>server_name_indication</code> - set this option to the host name of the server
              to which a TLS connection will be made to enable "Server Name Indication" verification
              of the certificate presented by the server. This ensures that the server certificate's
              <code>CN=</code> value will be verified during TLS connection establishment. You can
              override this behavior by setting <code>server_name_indication</code> to a different
              host name or to the special value <code>disable</code> to disable this
              verification. Note that, by default, SNI is <b>not</b> enabled. This default
              will change in a future RabbitMQ Erlang client release.
            </p>
            <p><code>verify</code> - set this option to <code>verify_peer</code> to enable X509
              certificate chain verification. The <code>depth</code> option configures certificate
              verification depth. Note that, by default, <code>verify</code> is set to
              <code>verify_none</code>, which disables certificate chain verification. This default
              will change in a future RabbitMQ Erlang client release.
            </p>
        </doc:subsection>

        <doc:subsection name="erlang-code-example">
          <doc:heading>Code</doc:heading>
<pre class="sourcecode erlang">
SslOpts = [{cacertfile, &quot;/path/to/testca/cacert.pem&quot;},
           {certfile, &quot;/path/to/client/cert.pem&quot;},
           {keyfile, &quot;/path/to/client/key.pem&quot;},

           %% only necessary with intermediate CAs
           %% {depth, 2},

           %% Note: it is recommended to set 'verify' to
           %% to 'verify_peer' to ensure that X509
           %% certificate chain validation is enabled
           %%
           %% Do not set 'verify' or set it to verify_none
           %% if x509 certificate chain validation is
           %% not desired
           {verify, verify_peer},

           %% If Server Name Indication validation is desired,
           %% set the following option to the host name to which
           %% the connection is made. If necessary, this option
           %% may be set to another host name to match the server
           %% certificate's CN= value.
           %% Do not set this option or set it to the atom 'disable'
           %% to disable SNI validation
           {server_name_indication, "my.rmq-server.net"}],

Params = #amqp_params_network{host = "my.rmq-server.net",
                              port = 5671,
                              ssl_options = SslOpts}

{ok, Conn} = amqp_connection:start(Params),
</pre>

            <p>You can now go ahead and use Conn as a normal connection.</p>
        </doc:subsection>

      </doc:section>
  </body>
</html>
