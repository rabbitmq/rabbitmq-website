<?xml-stylesheet type="text/xml" href="page.xsl"?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:doc="http://www.rabbitmq.com/namespaces/ad-hoc/doc">
  <head>
    <title>RabbitMQ - AMQP 0-9-1 Model Explained</title>
  </head>
  <body>
    <doc:div>
      <doc:toc class="compact">
        <doc:heading>Table of Contents</doc:heading>
      </doc:toc>

        <doc:section name="about-this-guide">
        <doc:heading>About this guide</doc:heading>
            <p>
              This guide explains the AMQP 0-9-1 Model used by RabbitMQ.
              The <a href="http://bit.ly/amqp-model-explained">original guide</a>
              that this page is based on was written by
              <a href="http://twitter.com/michaelklishin">Michael Klishin</a>
              and edited by <a href="https://twitter.com/celldee">Chris Duncan</a>.
            </p>
           </doc:section>
           <doc:section name="highlevel-overview">
           <doc:heading>High-level overview of AMQP 0-9-1 and the AMQP Model</doc:heading>
             <doc:subsection name="what-is-amqp">
             <doc:heading>What is AMQP?</doc:heading>
               <p>
                 AMQP (Advanced Message Queuing Protocol) is a networking
                 protocol which enables conforming client applications to
                 communicate with conforming
                 messaging middleware brokers.
               </p>
             </doc:subsection>
             <doc:subsection name="brokers=role">
             <doc:heading>Brokers and their role</doc:heading>
                 <p>
                   Messaging brokers receive messages from <em>producers</em>
                   (applications that publish them) and route them to
                   <em>consumers</em> (applications
                   that process them).
                 </p>
             </doc:subsection>
             <doc:subsection name="amqp-model">
             <doc:heading>AMQP 0-9-1 Model in brief</doc:heading>
                 <p>
                   The AMQP 0-9-1 Model has the following view of the world:
                   messages are published by producers to <em>exchanges</em>,
                   often compared to post offices or mailboxes. Exchanges then
                   distribute message copies to <em>queues</em> using rules called
                   <em>bindings</em>. Then AMQP brokers either push messages to
                   <em>consumers</em> subscribed to queues, or consumers
                   fetch/pull messages from queues on demand.
                 </p>
                 <p>
                   <img src="/img/tutorials/intro/hello-world-example-routing.png"
                        alt="Publish path from publisher to consumer via
                             exchange and queue" />
                 </p>
                 <p>
                   When publishing a message, producers may specify various
                   <em>message attributes</em> (message metadata). Some of this
                   metadata may be used by the broker, however, the rest of it
                   is completely opaque to the broker and is only used by
                   applications that receive the message.
                 </p>
                 <p>
                   Networks are unreliable and applications may fail to process
                   messages, therefore the AMQP Model has a notion of
                   <em>message acknowledgements</em>: when a message is pushed
                   down to a consumer, the consumer <em>notifies the broker</em>,
                   either automatically or as soon as the application
                   developer chooses to do so. When message acknowledgements
                   are in use, a broker will only completely remove a message
                   from a queue when it receives a notification for that message
                   (or group of messages).
                 </p>
                 <p>
                   In certain situations, for example, when a message cannot
                   be routed, messages may be <em>returned</em> to producers,
                   dropped, or, if the broker implements an extension,
                   placed into a so-called "dead letter queue". Producers choose
                   how to handle situations like this by publishing messages
                   using certain parameters.
                 </p>
                 <p>
                   Queues, exchanges and bindings are commonly referred to as <em>AMQP entities</em>.
                 </p>
             </doc:subsection>
             <doc:subsection namne="programmable-protocol">
             <doc:heading>AMQP is a Programmable Protocol</doc:heading>
                <p>
                  AMQP 0-9-1 is a programmable protocol in the sense that AMQP
                  entities and routing schemes are defined by applications
                  themselves, not a broker administrator. Accordingly,
                  provision is made for protocol operations that declare
                  queues and exchanges, define bindings between them,
                  subscribe to queues and so on.
                </p>
                <p>
                  This gives application developers a lot of freedom but
                  also requires them to be aware of potential definition
                  conflicts. In practice, definition conflicts are rare and
                  often indicate misconfigurations. This can be very useful
                  as it is a good thing if misconfigurations are caught early.
                </p>
                <p>
                  Applications declare the AMQP entities that they need,
                  define necessary routing schemes and may choose to delete
                  AMQP entities when they are no longer used.
                </p>
             </doc:subsection>
            </doc:section>

          <doc:section name="exchanges">
          <doc:heading>Exchanges and Exchange Types</doc:heading>
            <p>
              <em>Exchanges</em> are AMQP entities where messages are
              sent. Exchanges then take a message and route it into one or
              more (or no) queues. The routing algorithm used
              depends on <em>exchange type</em> and rules called
              <em>bindings</em>. AMQP 0-9-1 brokers provide four
              exchange types:
            </p>

            <table>
              <tr><td>Name</td>             <td>Default pre-declared names</td></tr>
              <tr><td>Direct exchange</td>  <td>(Empty string) and amq.direct</td></tr>
              <tr><td>Fanout exchange</td>  <td>amq.fanout</td></tr>
              <tr><td>Topic exchange</td>   <td>amq.topic</td></tr>
              <tr><td>Headers exchange</td> <td>amq.match (and amq.headers in RabbitMQ)</td></tr>
            </table>
            <p>
              Besides the type, exchanges are declared with a number of
              attributes, most important of which are:
            </p>
            <ul>
              <li>Name</li>
              <li>Durability (exchanges survive broker restart)</li>
              <li>Auto-delete (exchange is deleted when all queues have finished using it)</li>
              <li>Arguments (these are broker-dependent)</li>
            </ul>
            <p>
              Exchanges can be durable or transient. Durable
              exchanges survive broker restart, transient
              exchanges don't (they have to be redeclared
              when broker comes back online). Not all scenarios
              and use cases require exchanges to be durable.
            </p>

               <doc:subsection name="exchange-default">
               <doc:heading>Default Exchange</doc:heading>
               <p>
                 The default exchange is a direct exchange with no name (the
                 amqp gem refers to it using an empty string) pre-declared by
                 the broker. It has one special property that makes it very
                 useful for simple applications, namely that every queue is
                 automatically bound to it with a routing key which is the
                 same as the queue name.
               </p>
               <p>
                 For example, when you declare a queue with the name of
                 "search-indexing-online", the AMQP broker will bind it
                 to the default exchange using "search-indexing-online" as
                 the routing key. Therefore a message published to the default
                 exchange with routing key = "search-indexing-online"
                 will be routed to the queue "search-indexing-online". In
                 other words, the default exchange makes it seem like it
                 is possible to deliver messages directly to queues, even
                 though that is not technically what is happening.
               </p>
               </doc:subsection>

               <doc:subsection name="exchange-direct">
               <doc:heading>Direct Exchange</doc:heading>
               <p>
                 A direct exchange delivers messages to queues based on the
                 message routing key. A direct exchange is ideal for the unicast
                 routing of messages (although they can be used for multicast
                 routing as well). Here is how it works:
                 <ul>
                   <li>A queue binds to the exchange with a routing key K</li>
                   <li>When a new message with routing key R arrives at the
                   direct exchange, the exchange routes it to the queue if K = R</li>
                 </ul>
               <p>
               </p>
                 Direct exchanges are often used to distribute tasks between
                 multiple workers (instances of the same application) in
                 a round robin manner. When doing so, it is important to
                 understand that, in AMQP 0-9-1, messages are load balanced
                 between consumers and not between queues.
               </p>
               <p>
                  A direct echange can be represented graphically as follows:
                  <img src="/img/tutorials/intro/exchange-direct.png"
                       alt="exchange delivering messages to  queues based on routing key" />
               </p>
               </doc:subsection>

               <doc:subsection name="exchange-fanout">
               <doc:heading>Fanout Exchange</doc:heading>
               <p>
                  A fanout exchange routes messages to all of the queues
                  that are bound to it and the routing key is ignored. If N
                  queues are bound to a fanout exchange, when a new message
                  is published to that exchange a copy of the message is
                  delivered to all N queues. Fanout exchanges are ideal for
                  the broadcast routing of messages.
               </p>
               <p>
                  Because a fanout exchange delivers a copy of a message to
                  every queue bound to it, its use cases are quite similar:
                  <ul>
                  <li>Massively multiplayer online (MMO) games can use it
                  for leaderboard updates or other global events</li>
                  <li>Sport news sites can use fanout exchanges for
                  distributing score updates to mobile clients in near
                  real-time</li>
                  <li>Distributed systems can broadcast various state and
                  configuration updates</li>
                  <li>Group chats can distribute messages between participants
                  using a fanout exchange (although AMQP does not have a
                  built-in concept of presence, so XMPP may be a better
                  choice)</li>
                  </ul>
               </p>
               <p>
                  A fanout echange can be represented graphically as follows:
                  <img src="/img/tutorials/intro/exchange-fanout.png"
                       alt="exchange delivering messages to three queues" />
               </p>
               </doc:subsection>

               <doc:subsection name="exchange-topic">
               <doc:heading>Topic Exchange</doc:heading>
               <p>
                  Topic exchanges route messages to one or many queues
                  based on matching between a message routing key and the
                  pattern that was used to bind a queue to an exchange. The
                  topic exchange type is often used to implement various
                  publish/subscribe pattern variations. Topic exchanges are
                  commonly used for the multicast routing of messages.
               </p>
               <p>
                  Topic exchanges have a very broad set of use cases. Whenever
                  a problem involves multiple consumers/applications that
                  selectively choose which type of messages they want to
                  receive, the use of topic exchanges should be considered.
               </p>
               <p>
                 Example uses:
                 <ul>
                 <li>Distributing data relevant to specific geographic
                 location, for example, points of sale</li>
                 <li>Background task processing done by multiple workers,
                 each capable of handling specific set of tasks</li>
                 <li>Stocks price updates (and updates on other kinds of financial data)</li>
                 <li>News updates that involve categorization or tagging
                 (for example, only for a particular sport or team)</li>
                 <li>Orchestration of services of different kinds in the cloud</li>
                 <li>Distributed architecture/OS-specific software builds or
                 packaging where each builder can handle only one architecture
                 or OS</li>
                 </ul>
               </p>
               </doc:subsection>

               <doc:subsection name="exchange-headers">
               <doc:heading>Headers Exchange</doc:heading>
               <p>
                 A headers exchange is designed to for routing on multiple
                 attributes that are more easily expressed as message
                 headers than a routing key. Headers exchanges ignore the
                 routing key attribute. Instead, the attributes used for
                 routing are taken from the headers attribute. A message is
                 considered matching if the value of the header equals the
                 value specified upon binding.
               </p>
               <p>
                 It is possible to bind a queue to a headers exchange using
                 more than one header for matching. In this case, the broker
                 needs one more piece of information from the application
                 developer, namely, should it consider messages with any
                 of the headers matching, or all of them? This is what the
                 "x-match" binding argument is for. When the "x-match"
                 argument is set to "any", just one matching header value
                 is sufficient. So in the example above, any message with
                 "cores" header value equal to 8 will be considered matching.
               </p>
               <p>
                 Headers exchanges can be looked upon as "direct exchanges
                 on steroids". Because they route based on header values,
                 they can be used as direct exchanges where the routing key
                 does not have to be a string; it could be an integer or a
                 hash (dictionary) for example.
               </p>
               <p>
               </p>
               </doc:subsection>

            </doc:section>

           <doc:section name="queues">
          <doc:heading>Queues</doc:heading>
            <p>
              Queues in the AMQP Model are very similar to queues in
              other message and "task queueing" systems: they store
              messages that are consumed by applications. Queues share
              some properties with exchanges, but also have some additional
              properties:
            </p>
            <ul>
              <li>Name</li>
              <li>Durable (the queue will survive a broker restart)</li>
              <li>Exclusive (used by only one connection and the queue will be deleted when that connection closes)</li>
              <li>Auto-delete (queue is deleted when last consumer unsubscribes)</li>
              <li>Arguments (some brokers use it to implement additional features like message TTL)</li>
            </ul>

             <p>
              Before a queue can be used, it has to be declared. Declaring
              a queue will cause it to be created if it does not already
              exist. The declaration will have no effect if the queue does
              already exist and its attributes are the same as those in the
              declaration. When the existing queue attributes are not the
              same as those in the declaration a channel-level exception
              with code 406 (PRECONDITION_FAILED) will be  raised.
             </p>
             <doc:subsection name="queue-names">
             <doc:heading>Queue names</doc:heading>
             <p>
              Applications may pick queue names or ask the broker to generate
              a name for them.  Queue names may be up to 255 bytes of UTF-8
              characters.  To ask an AMQP broker to generate a unique queue
              name for you, pass an empty string as the queue name argument:
              The same generated name may be obtained by subsequent methods
              in the same channel by using the empty string where a queue
              name is expected. This works because the channel remembers the
              last server-generated queue name.
             </p>
             <p>
              Queue names starting with "amq." are reserved for internal
              use by the broker. Attempts to declare a queue with a name that
              violates this rule will result in a channel-level exception
              with reply code 403 (ACCESS_REFUSED).
             </p>
             </doc:subsection>
             <doc:subsection name="queue-durability">
             <doc:heading>Queue durability</doc:heading>
             <p>
              Durable queues are persisted to disk and thus survive broker
              restarts. Queues that are not durable are called transient.
              Not all scenarios and use cases mandate queues to be durable.
             </p>
             <p>
              Note that <strong>only durable queues can be bound to
              durable exchanges</strong>. This guarantees that it is
              possible to restore bindings on broker restart.
             </p>
             <p>
              Durability of a queue does not make <em>messages</em> that
              are routed to that queue durable. If broker is taken down
              and then brought back up, durable queue will be re-declared
              during broker startup, however, only <em>persistent</em>
              messages will be recovered.
             </p>
             </doc:subsection>
            </doc:section>

           <doc:section name="bindings">
          <doc:heading>Bindings</doc:heading>
            <p>
              Bindings are rules that exchanges use (among other things)
              to route messages to queues. To instruct an exchange E to
              route messages to a queue Q,
              Q has to <em>be bound</em> to E. Bindings may have an optional
              <em>routing key</em> attribute used by some exchange types. The
              purpose of the routing key is to
              selectively match only specific (matching) messages published
              to an exchange to the bound queue. In other words, the routing
              key acts like a filter.
            </p>
            <p>
              To draw an analogy:
            </p>
            <ul>
              <li>Queue is like your destination in New York city</li>
              <li>Exchange is like JFK airport</li>
              <li>Bindings are routes from JFK to your destination. There
              can be none or more than one way to reach it</li>
            </ul>
            <p>
              Having this layer of indirection enables routing scenarios
              that are impossible or very hard to implement using publishing
              directly to queues and also eliminates certain amount of
              duplicated work application developers have to do.
            </p>
            <p>
              If AMQP message cannot be routed to any queue (for example,
              because there are no bindings for the exchange it was published
              to), it is either dropped or returned to the publisher,
              depending on message attributes the publisher has set.
            </p>
            </doc:section>

          <doc:section name="consumers">
          <doc:heading>Consumers</doc:heading>
            <p>
              Storing messages in queues is useless unless applications
              can <em>consume</em> them. In the AMQP 0-9-1 Model, there
              are two ways for applications to do this:
            </p>
            <ul>
              <li>Have messages pushed to them ("push API")</li>
              <li>Fetch messages as needed ("pull API")</li>
            </ul>
            <p>
              With the "push API", applications have to indicate interest in
              consuming messages from a particular queue. When they do so,
              we say that they <em>register a consumer</em>
              or, simply put, <em>subscribe to a queue</em>. It is possible
              to have more than one consumer per queue or to register an
              <em>exclusive consumer</em> (excludes all other consumers from
              the queue while it is consuming).
            </p>
            <p>
              Each consumer (subscription) has an identifier called a
              <em>consumer tag</em>. It can be used to unsubscribe from
              messages. Consumer tags are just strings.
            </p>

            <doc:subsection name="message-acknowledge">
            <doc:heading>Message Acknowledgements</doc:heading>
              <p>
               Consumer applications – applications that receive and process
               messages – may occasionally fail to process individual
               messages, or will just crash. There is also the possibility
               of network issues causing problems. This raises a question –
               "When should the AMQP broker remove messages from queues?" The
               AMQP 0-9-1 specification proposes two choices:
               <ul>
               <li>After broker sends a message to an application (using
               either basic.deliver or basic.get-ok methods).</li>
               <li>After the application sends back an acknowledgement
               (using basic.ack AMQP method).</li>
               </ul>
               </p>
              <p>
               The former choice is called the automatic acknowledgement
               model, while the latter is called the *explicit acknowledgement
               model*. With the explicit model, the application chooses when
               it is time to send an acknowledgement.  It can be right after
               receiving a message, or after persisting it to a data store
               before processing, or after fully processing the message
               (for example, successfully fetching a Web page, processing
               and storing it into some persistent data store).
              </p>
              <p>
               If a consumer dies without sending an acknowledgement,
               the AMQP broker will redeliver it to another consumer, or,
               if none are available at the time, the broker will wait until
               at least one consumer is registered for the same queue before
               attempting redelivery.
              </p>
            </doc:subsection>
            <doc:subsection name="messages-reject">
            <doc:heading>Rejecting Messages</doc:heading>
              <p>
               When a consumer application receives a message, processing
               of that message may or may not succeed. An application can
               indicate to the broker that message processing has failed
               (or cannot be accomplished at the time) by rejecting a
               message. When rejecting a message, an application can ask
               the broker to discard or requeue it. When there is only one
               consumer on a queue, make sure you do not create infinite
               message delivery loops by rejecting and requeueing a message
               from the same consumer over and over again.
              </p>
            </doc:subsection>
            <doc:subsection name="messages-nack">
            <doc:heading>Negative acknowledgements </doc:heading>
              <p>
               Messages are rejected with the <code>basic.reject</code> AMQP
               method. There is one limitation that <code>basic.reject</code> has:
               there is no way to reject multiple messages, as you can do
               with acknowledgements. However, if you are using RabbitMQ,
               then there is a solution. RabbitMQ provides an AMQP 0-9-1
               extension known as negative acknowledgements (nacks) and
               the amqp gem supports this extension. For more information,
               please refer to the <a href="/extensions.html#negative-acknowledgements">Rabbit-specific
               extensuions</a>.
              </p>
            </doc:subsection>
            <doc:subsection name="messages-prefetch">
            <doc:heading>Prefetching messages</doc:heading>
              <p>
               For cases when multiple consumers share a queue, it is useful
               to be able to specify how many messages each consumer can be
               sent at once before sending the next acknowledgement. This can
               be used as a simple load balancing technique or to improve
               throughput if messages tend to be published in batches. For
               example, if a producing application sends messages every
               minute because of the nature of the work it is doing.
              </p>
              <p>
               Note that RabbitMQ only supports channel-level prefetch-count,
               not connection or size based prefetching.
              </p>
            </doc:subsection>
            </doc:section>

          <doc:section name="messages">
          <doc:heading>Message Attributes and Payload</doc:heading>
            <p>
              Messages in the AMQP Model have <em>attributes</em>. Some
              attributes are so common that the AMQP 0-9-1 specification
              defines them and application developers do not have to think
              about the exact attribute name. Some examples are
            </p>
            <ul>
              <li>Content type</li>
              <li>Content encoding</li>
              <li>Routing key</li>
              <li>Delivery mode (persistent or not)</li>
              <li>Message priority</li>
              <li>Message publishing timestamp</li>
              <li>Expiration period</li>
              <li>Producer application id</li>
            </ul>
            <p>
              Some attributes are used by AMQP brokers, but most are open
              to interpretation by applications that receive them. Some
              attributes are optional and known
              as <em>headers</em>. They are similar to X-Headers in
              HTTP. Message attributes are set when a message is published.
            </p>
            <p>
              AMQP messages also have a <em>payload</em> (the data that
              they carry). Brokers treat this data as opaque (it is neither
              modified nor used by them). It is possible for messages to
              contain only attributes
              and no payload. It is common to use serialization formats
              like JSON, Thrift, Protocol Buffers and MessagePack
              to serialize structured data
              in order to publish it as AMQP message payload.
            </p>
            <p>
              Messages may be published as persistent, which makes AMQP broker
              persist them to disk. If the server is restarted, the
              system ensures that received persistent messages are not
              lost. Simply publishing message to a durable exchange or
              the fact that queue(s) they are routed to is durable doesn't
              make messages persistent: it all depends on persistence mode
              of the messages itself. Publishing messages as persistent
              affects performance (just like with data stores, durability
              comes at a certain cost in performance and vise versa).
            </p>
            </doc:section>

          <doc:section name="acknowledgements">
          <doc:heading>Message Acknowledgements</doc:heading>
            <p>
              Since networks are unreliable and applications fail,
              it is often necessary to have some kind of "processing
              acknowledgement". Sometimes it is only necessary to
              acknowledge the fact that a message has been received. Sometimes
              acknowledgements mean that a message was validated and processed
              by a consumer, for example, verified as having mandatory data
              and persisted to a data store or indexed.
            </p>
            <p>
              This situation is very common, so AMQP 0-9-1 has a built-in
              feature called <em>message acknowledgements</em> (sometimes
              referred to as <em>acks</em>) that consumers use to confirm
              message delivery and/or processing. If an application crashes
              (AMQP broker notices this when connection is closed), if an
              acknowledgement for a message was expected but not received
              by the AMQP broker, the message is re-queued (and possibly
              immediately delivered to another consumer, if any exists).
            </p>
            <p>
              Having acknowledgements built into the protocol helps
              developers to build more robust software.
            </p>
            </doc:section>
          <doc:section name="amqp-methods">
          <doc:heading>AMQP 0-9-1 Methods</doc:heading>
            <p>
              AMQP 0-9-1 is structured as a number of
              <em>methods</em>. Methods are operations (like HTTP methods)
              and have nothing in common with methods in object-oriented
              programming
              languages. AMQP methods are grouped into
              <em>classes</em>. Classes are just logical groupings of AMQP
              methods. The <a href="/amqp-0-9-1-reference.html">AMQP 0-9-1
              reference</a> can be found on
              the RabbitMQ website.
            </p>
            <p>
              Let us take a look at the <em>exchange</em> class, a group
              of methods related to operations on exchanges. It includes
              the following operations:
            </p>
            <ul>
              <li>exchange.declare</li>
              <li>exchange.declare-ok</li>
              <li>exchange.delete</li>
              <li>exchange.delete-ok</li>
            </ul>
            <p>
              (note that the RabbitMQ site reference also includes
              RabbitMQ-specific extensions to the exchange class that we
              will not discuss in this guide).
            </p>
            <p>
              The operations above form logical pairs:
              <strong>exchange.declare</strong> and
              <strong>exchange.declare-ok</strong>,
              <strong>exchange.delete</strong> and
              <strong>exchange.delete-ok</strong>. These operations are
              "requests" (sent by clients) and "responses" (sent by
              brokers in response to the aforementioned "requests").
            </p>
            <p>
              As an example, the client asks the broker to declare a new
              exchange using the <strong>exchange.declare</strong> method:
            </p>
            <p>
              <img src="/img/tutorials/intro/exchange-declare.png"
                   alt="exchange.declare" />
            </p>
            <p>
              As shown on the diagram above,
              <strong>exchange.declare</strong> carries several
              <em>parameters</em>. They enable the client to specify
              exchange name, type, durability flag and so on.
            </p>
            <p>
              If the operation succeeds, the broker responds with the <strong>exchange.declare-ok</strong> method:
            </p>
            <p>
              <img src="/img/tutorials/intro/exchange-declare-ok.png"
                   alt="exchange.declare-ok" />
            </p>
            <p>
              <strong>exchange.declare-ok</strong> does not carry any
              parameters except for the channel number (channels will be
              described later in this guide).
            </p>
            <p>
              The sequence of events is very similar for another
              method pair, <strong>queue.declare</strong> and
              <strong>queue.declare-ok</strong>:
            </p>
            <p>
              <img src="/img/tutorials/intro/queue-declare.png"
                   alt="queue.declare" />
            </p>
            <p>
              <img src="/img/tutorials/intro/queue-declare-ok.png"
                   alt="queue.declare-ok" />
            </p>
            <p>
              Not all AMQP methods have counterparts. Some
              (<strong>basic.publish</strong> being the most widely used one)
              do not have corresponding "response" methods
              and some others (<strong>basic.get</strong>, for example)
              have more than one possible "response".
            </p>
            </doc:section>
          <doc:section name="amqp-connections">
          <doc:heading>Connections</doc:heading>
            <p>
              AMQP connections are typically long-lived. AMQP is an
              application level protocol that uses TCP for reliable
              delivery. AMQP connections use authentication and can be
              protected using TLS (SSL). When an application no longer needs
              to be connected to an AMQP broker, it should gracefully close
              the AMQP connection instead of abruptly closing the underlying
              TCP connection.
            </p>
            </doc:section>
          <doc:section name="amqp-channels">
          <doc:heading>Channels</doc:heading>
            <p>
              Some applications need multiple connections to an AMQP
              broker. However, it is undesirable to keep many TCP
              connections open at the same time because doing so consumes
              system resources and makes it more difficult to configure
              firewalls. AMQP 0-9-1 connections are multiplexed with
              <em>channels</em> that can be thought of as "lightweight
              connections that share a single TCP connection".
            </p>
            <p>
              For applications that use multiple threads/processes/etc for
              processing, it is very common to open a new channel per thread
              (process, etc.)
              and <strong>not share</strong> channels between them.
            </p>
            <p>
              Communication on a particular channel is completely separate
              from communication on another channel, therefore every AMQP
              method also carries a channel number that clients use to
              figure out which channel the method is for (and thus, which
              event handler needs to be invoked, for example).
            </p>
            </doc:section>
           <doc:section name="amqp-vhosts">
          <doc:heading>Virtual Hosts</doc:heading>
            <p>
              To make it possible for a single broker to host multiple
              isolated "environments" (groups of users, exchanges,
              queues and so on), AMQP includes the concept of <em>virtual
              hosts</em> (vhosts). They are similar to virtual hosts used
              by many popular Web servers and provide completely isolated
              environments in which AMQP entities live. AMQP clients
              specify what vhosts they want to use during AMQP connection
              negotiation.
            </p>
            <p>
              An AMQP 0-9-1 vhost name can be any non-blank string.
            </p>
            </doc:section>
          <doc:section name="amqp-extensibility">
          <doc:heading>AMQP is Extensible</doc:heading>
            <p>
              AMQP 0-9-1 has several extension points:
            </p>
            <ul>
              <li>Custom exchange types let developers implement routing schemes that exchange types
                  provided out-of-the-box do not cover well, for example, geodata-based routing.</li>
              <li>Declaration of exchanges and queues can include additional attributes that the broker
                  can use. For example, per-queue message TTL in RabbitMQ is implemented this way.</li>
              <li>Broker-specific extensions to the protocol. See, for example,
                  <a href="/extensions.html">extensions RabbitMQ implements</a>.</li>
              <li>New AMQP 0-9-1 method classes can be introduced.</li>
              <li>Brokers can be extended with additional plugins, for example, RabbitMQ management
                  frontend and HTTP API are implemented as a plugin.</li>
            </ul>
            <p>
              These features make the AMQP 0-9-1 Model even more flexible
              and applicable to a very broad range of problems.
            </p>
            </doc:section>
          <doc:section name="amqp-clients">
          <doc:heading>AMQP 0-9-1 clients ecosystem</doc:heading>
            <p>
              There are many AMQP 0-9-1 clients for many popular programming
              languages and platforms. Some of them follow AMQP terminology
              closely and only provide implementation of AMQP methods. Some
              others have additional features, convenience methods
              and abstractions. Some of the clients are asynchronous
              (non-blocking), some are synchronous (blocking), some support
              both models. Some clients support vendor-specific extensions
              (for example, RabbitMQ-specific extensions).
            </p>
            <p>
              Because one of the main AMQP goals is interoperability, it is
              a good idea for developers to understand protocol operations
              and not limit themselves to terminology of a particular client
              library. This way communicating with developers using different
              libraries will be significantly easier.
            </p>
            </doc:section>
          </body>
  </doc:div>
</html>

