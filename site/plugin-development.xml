<?xml-stylesheet type="text/xml" href="page.xsl"?>
<!DOCTYPE html PUBLIC "bug in xslt processor requires fake doctype" 
"otherwise css isn't included" [
<!ENTITY % entities SYSTEM "rabbit.ent" >
%entities;
]>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:doc="http://www.rabbitmq.com/namespaces/ad-hoc/doc">
  <head>
    <title>RabbitMQ - Plugin Development Guide</title>
  </head>
  <body>
    <doc:div>
      <p class="intro">
        This is the RabbitMQ Server Plugin Development Guide. It is expected that
        before reading this guide, the reader has a basic understanding of the RabbitMQ
        plugin mechanism, as described in the <a href="admin-guide.html#plugins">Plugins</a>
        section of the Administration Guide. Readers are also expected to have a basic
        understanding of Erlang OTP
        <a href="http://www.erlang.org/doc/system_principles/users_guide.html">system</a> and
        <a href="http://www.erlang.org/doc/design_principles/users_guide.html">design</a> principles.
      </p>

      <doc:toc class="compact">
        <doc:heading>Table of Contents</doc:heading>
      </doc:toc>

      <doc:section name="why">
        <doc:heading>Why Write A Plugin?</doc:heading>

        <p>
          Writing a RabbitMQ plugin provides a number of appealing possibilities:
        </p>
        <ul>
          <li>
            Enable your application to access internal RabbitMQ functionality that is not exposed
            via the AMQP interface.
          </li>
          <li>
            Running in the same Erlang VM as the broker may increase performance for certain applications.
          </li>
          <li>
            Plugins provide an easy deployment model, since they allow for a single &quot;RabbitMQ Appliance&quot;
            to be built that acts in a self-contained manner. This can be useful both for easing production
            deployments, and for producing all-in-one infrastructure for use during development.
          </li>
        </ul>
      </doc:section>

      <doc:section name="why-not">
        <doc:heading>Why To Not Write A Plugin</doc:heading>

        <p>
          As with any plugin mechanism, consideration should be given when developing functionality as to whether
          embedding it as a plugin is the most appropriate path to take. Some reasons that you might not want to
          develop your functionality as a plugin:
        </p>

        <ul>
          <li>
            Depending on undocumented internal Rabbit APIs can result in your application requiring changes when
            RabbitMQ is updated. If you can do what you need to do without using RabbitMQ internals, then your
            application will be far more compatible in the future.
          </li>
          <li>
            As mentioned in the Admin Guide, a poorly written plugin can result in the entire broker crashing!
          </li>
        </ul>
      </doc:section>

      <doc:section name="getting-started">
        <doc:heading>Getting Started</doc:heading>

        <p>
          To develop a RabbitMQ plugin, a working RabbitMQ development environment
          first needs to be configured. An &quot;umbrella&quot; project is now
          provided to assist in assembling all the necessary repositories. The following
          steps will walk through the process of checking out and using a copy of the
          umbrella project in your local environment.
        </p>
        <ul>
          <li>
            Ensure that you have a working installation of <a href="http://mercurial.selenic.com/wiki/">Mercurial</a>.
          </li>
          <li>
            Ensure that the dependencies detailed in the <a href="build-server.html#prerequisites">Server Build</a>
            documentation are installed and functional.
          </li>
          <li>
            Clone the RabbitMQ public umbrella:
            <pre class="sourcecode">$ hg clone http://hg.rabbitmq.com/rabbitmq-public-umbrella</pre>
          </li>
          <li>
            Checkout the sub-projects into the Umbrella:
            <pre class="sourcecode">$ cd rabbitmq-public-umbrella
$ make co</pre>
          </li>
          <li>
            Build all the components under the Umbrella to ensure that your environment is functional:
            <pre class="sourcecode">$ make</pre>
          </li>
        </ul>
      </doc:section>

      <doc:section name="installing-plugins-during-development">
        <doc:heading>Installing plugins during development</doc:heading>

        <p>
          Instead of requiring that developers rebuild plugin archives and re-install them each time a change
          is made, plugins can be operated in a development-style mode to make it possible to develop plugins
          in place.
        </p>
        <p>
          To activate a plugin in a development environment, create a
          symlink for the plugin development directory in the
          rabbitmq-server/plugins directory (you will have to create
          that directory if it does not exist already). For example,
          to activate a development build of
          the rabbitmq-shovel plugin and
          its dependencies:
          <pre class="sourcecode">$ mkdir -p rabbitmq-server/plugins
$ cd rabbitmq-server/plugins
$ ln -s ../../rabbitmq-erlang-client
$ ln -s ../../rabbitmq-shovel</pre>
        </p>
        <p>
          Conversely, to disable a plugin, simply remove the symlink and restart the broker instance.
        </p>
      </doc:section>

      <doc:section name="plugin-quality-tips">
        <doc:heading>Plugin Quality Tips</doc:heading>

        <p>
          As highlighted in the Administration Guide, badly-written plugins can pose a risk to the stability of the
          broker. The following tips aim to provide a series of best-practices for ensuring that your plugin
          can safely co-exist with Rabbit.
        </p>

        <ul>
          <li>
            Always install a Supervisor above your application. You should never start your application directly,
            instead opting to create a (possibly quite trivial) supervisor that will prevent the Erlang VM from
            shutting down due to a crashed top-level application.
          </li>
        </ul>
      </doc:section>

      <doc:section name="plugin-hello-world">
        <doc:heading>RabbitMQ Plugin Hello World</doc:heading>

        <p>
          Seeing as no development guide would be complete without a Hello World example, the following tries to
          provide the basics of how your would build your very own RabbitMQ plugin. The following example details
          how you might build a simple plugin that acts like a metronome. Every second, it fires a message that has
          a routing key in the form yyyy.MM.dd.dow.hh.mm.ss to a topic exchange called &quot;metronome&quot;. Applications
          can attach queues to this exchange with various routing keys in order to be invoked at regular intervals. For
          example, to receive a message every second, a binding of &quot;*.*.*.*.*.*.*&quot; could be applied. To recieve
          a message every minute, a binding of &quot;*.*.*.*.*.*.00&quot; could be applied instead.
        </p>
        <ul>
          <li>
            The first thing to do is create the basic skeleton of your project. Within your rabbitmq-public-umbrella
            working copy, create a new directory (for the purposes of this example, we'll call it rabbit_metronome).
          </li>
          <li>
            Create your basic Makefile, containing:
            <pre class="sourcecode">PACKAGE=rabbitmq-metronome
DEPS=rabbitmq-server rabbitmq-erlang-client

include ../include.mk</pre>
            The top-level include.mk file aims to make your application's Makefile as declarative as possible. Your
            plugin's Makefile is still a real Makefile however, so you can still do any kind of normal Make tasks.
          </li>
          <li>
            Create your ebin and source directories:
            <pre class="sourcecode">$ mkdir ebin
$ mkdir src</pre>
          </li>
          <li>
            Create a simple .app file in the ebin directory. Again, for the purposes of this example, call it
            ebin/rabbit_metronome.app:
            <pre class="sourcecode">{application, rabbit_metronome,
 [{description, "Embedded Rabbit Metronome"},
  {vsn, "0.01"},
  {modules, [
    rabbit_metronome,
    rabbit_metronome_sup,
    rabbit_metronome_worker
  ]},
  {registered, []},
  {mod, {rabbit_metronome, []}},
  {env, []},
  {applications, [kernel, stdlib, rabbit, amqp_client]}]}.</pre>
             This .app file is declaring that, alongside the normal Erlang dependencies, the plugin requires
             rabbit and amqp_client to be available and started before starting the plugin. This information helps
             the Erlang infrastructure to correctly order the Rabbit startup sequence.
          </li>
          <li>
            Now create your application entry point (src/rabbit_metronome.erl):
            <pre class="sourcecode">-module(rabbit_metronome).

-export([start/0, stop/0, start/2, stop/1]).

start() ->
    rabbit_metronome_sup:start_link(), ok.

stop() ->
    ok.

start(normal, []) ->
    rabbit_metronome_sup:start_link().

stop(_State) ->
    ok.</pre>
          </li>
          <li>
            Followed by your very basic supervisor (src/rabbit_metronome_sup.erl):
            <pre class="sourcecode">-module(rabbit_metronome_sup).
-behaviour(supervisor).

-export([start_link/0, init/1]).

start_link() ->
  supervisor:start_link({local, ?MODULE}, ?MODULE, _Arg = []).

init([]) ->
    {ok, {{one_for_one, 3, 10},
          [{rabbit_metronome_worker,
            {rabbit_metronome_worker, start_link, []},
            permanent,
            10000,
            worker,
            [rabbit_metronome_worker]}
          ]}}.</pre>
          </li>
          <li>
            Finally, the core of the plugin - the worker. The worker will connect internally to the broker, then create a task
            that will be triggered every second (src/rabbit_metronome_worker.erl):
            <pre class="sourcecode">-module(rabbit_metronome_worker).
-behaviour(gen_server).

-export([start/0, start/2, stop/0, stop/1, start_link/0]).
-export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2, code_change/3]).

-include_lib("amqp_client/include/amqp_client.hrl").

-record(state, {channel}).
-define(RKFormat, "~4.10.0B.~2.10.0B.~2.10.0B.~1.10.0B.~2.10.0B.~2.10.0B.~2.10.0B").

start() ->
  start_link(),
  ok.

start(normal, []) ->
  start_link().

stop() ->
  ok.

stop(_State) ->
  stop().

start_link() ->
  gen_server:start_link({global, ?MODULE}, ?MODULE, [], []).

%---------------------------
% Gen Server Implementation
% --------------------------

init([]) ->
  Connection = amqp_connection:start_direct(),
  Channel = amqp_connection:open_channel(Connection),
  amqp_channel:call(Channel, #'exchange.declare'{exchange = &lt;&lt;"metronome">>,
                                                 type = &lt;&lt;"topic">>}),

  timer:apply_after(1000, gen_server, call, [{global, ?MODULE}, fire]),
  {ok, #state{channel = Channel}}.

handle_call(Msg,_From,State = #state{channel = Channel}) ->
  case Msg of
    fire ->
      Properties = #'P_basic'{content_type = &lt;&lt;"text/plain">>, delivery_mode = 1},
      {Date={Year,Month,Day},{Hour, Min,Sec}} = erlang:universaltime(),
      DayOfWeek = calendar:day_of_the_week(Date),
      RoutingKey = list_to_binary(io_lib:format(?RKFormat, [Year, Month, Day,
                                                            DayOfWeek, Hour, Min, Sec])),
      Message = RoutingKey,
      BasicPublish = #'basic.publish'{exchange = &lt;&lt;"metronome">>,
                                      routing_key = RoutingKey},
      Content = #amqp_msg{props = Properties, payload = Message},
      amqp_channel:call(Channel, BasicPublish, Content),

      timer:apply_after(1000, gen_server, call, [{global, ?MODULE}, fire]),
      {reply, ok, State};
    _ ->
      {reply, unknown_command, State}
  end.

handle_cast(_,State) ->
    {noreply,State}.

handle_info(_Info, State) ->
    {noreply, State}.

terminate(_,#state{channel = Channel}) ->
    amqp_channel:call(Channel, #'channel.close'{}),
    ok.

code_change(_OldVsn, State, _Extra) ->
    {ok, State}.</pre>
          </li>
          <li>
            Run make to build your application:
            <pre class="sourcecode">$ make</pre>
            Note: If you receive an error similar to:
            <pre class="sourcecode">src/rabbit_metronome_worker.erl:8: can't find include file "rabbit_framing.hrl"
src/rabbit_metronome_worker.erl:44: record 'P_basic' undefined</pre>
            It means that your rabbitmq-server isn't built. Change to ../rabbitmq-server, and execute make there first.
          </li>
          <li>
            Next, associate your plugin (and its dependencies) with the server:
            <pre class="sourcecode">$ mkdir -p rabbitmq-server/plugins
$ cd ../rabbitmq-server/plugins
$ ln -s ../../rabbitmq-erlang-client
$ ln -s ../../rabbit_metronome
$ cd ..</pre>
          </li>
          <li>
            Start up your Rabbit broker:
            <pre class="sourcecode">$ make run</pre>
          </li>
          <li>
            To ensure that your new plugin is up and running, execute the following in the Erlang shell
            the broker is running within:
            <pre class="sourcecode">application:which_applications().</pre>
            If your plugin has loaded successfully, you should see an entry in the returned list that looks
            like: <pre class="sourcecode">{rabbit_metronome,"Embedded Rabbit Metronome","0.01"}</pre>
          </li>
        </ul>

        <doc:subsection name="testing">
          <doc:heading>Testing Your Plugin</doc:heading>

         <p>
           One of the key challenges in developing a plugin is often finding an appropriate (and manageable)
           way of testing it. Alongside the standard build targets, the include.mk file defines
           targets that will allow the execution of test cases against your plugin - including starting a
           broker instance running your plugin.
         </p>
         <ul>
           <li>
             To begin with testing your plugin, create a test/ subdirectory to contain your test code:
             <pre class="sourcecode">$ mkdir test</pre>
           </li>
           <li>
             Create some test cases for your plugin (for this example, create the file test/rabbit_metronome_tests.erl):
             <pre class="sourcecode">-module(rabbit_metronome_tests).

-include_lib("eunit/include/eunit.hrl").
-include_lib("amqp_client/include/amqp_client.hrl").

receive_tick_test() ->
  Connection = amqp_connection:start_direct(),
  Channel = amqp_connection:open_channel(Connection),
  #'queue.declare_ok'{queue = Q}
    = amqp_channel:call(Channel, #'queue.declare'{exclusive = true, auto_delete = true}),
  #'queue.bind_ok'{}
    = amqp_channel:call(Channel, #'queue.bind'{queue = Q,
                                               exchange = &lt;&lt;"metronome">>,
                                               routing_key = &lt;&lt;"#">>}),
  timer:sleep(2000),
  case amqp_channel:call(Channel, #'basic.get'{queue = Q, no_ack = true}) of
    {'basic.get_empty', _} -> exit(metronome_didnt_send_message);
    {_, #amqp_msg{}} ->
      ok
  end,
  ok.
</pre>
           </li>
           <li>
             Now that you've written your test, configure the Makefile to execute it by adding the
             following before the include statement:
             <pre class="sourcecode">TEST_APPS=amqp_client rabbit_metronome
TEST_COMMANDS=rabbit_metronome_tests:test()
START_RABBIT_IN_TESTS=true</pre>
             This instructs the Makefile to start Rabbit for your tests, add the rabbit_metronome plugin,
             and execute the given commands to run your tests.
             Note that further test commands should be space-separated.
           </li>
           <li>
             You can now run your tests by issuing:
             <pre class="sourcecode">$ make test</pre>
           </li>
         </ul>
        </doc:subsection>

        <doc:subsection name="packaging">
          <doc:heading>Packaging Your Plugin</doc:heading>

          <p>
            Whilst it is entirely possible to distribute your plugin by having users checkout from your
            source repository, it is often easier to package your built application into a single archive.
            As detailed in the Administration Guide, Rabbit supports plugins installed as .ez archives
            in the plugins/ directory. The standard include.mk file includes a default packaging goal, which
            can be invoked with:
            <pre class="sourcecode">$ make package</pre>
            And will produce an archive under the dist directory.
          </p>
        </doc:subsection>
      </doc:section>
    </doc:div>
  </body>
</html>
