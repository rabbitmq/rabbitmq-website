<?xml-stylesheet type="text/xml" href="page.xsl"?>
<!DOCTYPE html [
<!ENTITY % entities SYSTEM "rabbit.ent" >
%entities;
]>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:doc="http://www.rabbitmq.com/namespaces/ad-hoc/doc">
  <head>
    <title>Frequently Asked Questions</title>
  </head>
  <body>
      <doc:faqtoc class="compact"/>

      <doc:section name="background">
	<doc:heading>Background</doc:heading>

        <doc:faq name="what-is-messaging">
          <doc:heading>What is messaging?</doc:heading>
          <doc:a>
            <p>
            Messaging describes the sending and receiving of data (in the form of messages) between systems.
            Messages are exchanged between programs or applications, similar to the way people communicate
            by email but with guarantees on delivery, speed, security and the absence of spam.
            </p>
            <p>
            A messaging infrastructure (a.k.a. message-oriented middleware, a.k.a. enterprise service bus)
            makes it easier for developers to create complex applications by decoupling the individual program
            components. Rather than communicating directly, the messaging infrastructure facilitates the
            exchange of data between components. The components need know nothing about each otherâ€™s status,
            availability or implementation, which allows them to be distributed over heterogeneous platforms
            and turned off and on as required.
            </p>
            <p>
            In adopting this architecture, the developer is insulated from the details of the various operating
            systems and network interfaces involved and the interoperability, scalability and flexibility of the
            application are improved.
            </p>
            <p>
            Please see this presentation on <a href="http://blog.pasker.net/2008/06/16/you-might-need-messaging-if/">Why you might need messaging</a>
            for a general introduction or <a href="http://en.wikipedia.org/wiki/Message_Oriented_Middleware">this page on Wikipedia</a>
            for more information.
            </p>
          </doc:a>
        </doc:faq>

        <doc:faq name="at-least-once-delivery">
           <doc:heading>Can you explain the cases where a message might be delivered to a consumer more than once? </doc:heading>
          <doc:a>
            <p>
              If a message is delivered to a consumer, and that consumer then
              dies (or closes the channel which has the subscription to the
              queue, or closes the connection itself) without acking the
              message, then RabbitMQ will reinject the message into the queue. If
              that same consumer then reconnects and creates a new subscription
              to the same queue, it's possible it'll receive the same message
              again. This is 'at least once' delivery and is very deliberate
              design to ensure that messages are not lost in transit.
            </p>
            <p>
              The consumer can also call basic.recover which tells rabbit to
              resend all the messages sent to the consumer for which rabbit has
              not received an ack for. This basically amounts to the consumer
              saying "I know you sent me some messages, but I've forgotten what
              they are. Could you resend them all again?".
            </p>
          </doc:a>
        </doc:faq>


      </doc:section>

      <doc:section name="architecture">
        <doc:heading>RabbitMQ Architecture</doc:heading>

      <doc:faq name="node-runs-out-of-memory">
        <doc:heading>What happens when a node runs out of message memory? Does the node fall over?</doc:heading>
        <doc:a>
          <p>
            The RabbitMQ server has the ability to write messages to
            disk and forget them from memory should memory pressure
            occur. This allows RabbitMQ to store vastly more messages
            than can fit in RAM. Because of the fact that hard discs
            are slower than RAM, there are occasions where RabbitMQ
            will block producers when absolutely necessary to allow it
            to write out messages to disk in order to free up RAM.
          </p>
        </doc:a>
      </doc:faq>

     <doc:faq name="limitation-on-message-size">
        <doc:heading>What limitations are there on message size? For example, If I have
            a box with 8GB of RAM will it be able to hold one 8GB message?</doc:heading>
        <doc:a>
          <p>
            The main limitation is installed memory on the server (or, more accurately,
            the amount of per-process memory available on your platform).
          </p>
          <p>
            However, it's not as simple as available RAM = maximum message size. This
            would only be possible if there was zero copying of a message from when
            it arrives at the machine until when it leaves. Its very likely that
            it will be copied several times.
          </p>
          <p>
            We would be surprised if it's possible to push messages into RabbitMQ that
            are greater than 1/4 of the installed RAM. RabbitMQ tries to avoid using
            swap wherever possible and uses a configurable parameter to set a <a href="memory.html">memory
            threshold above which producers are throttled</a>.
          </p>
          <p>
            Be aware that <a href="http://msdn.microsoft.com/en-us/library/aa366778%28VS.85%29.aspx#physical_memory_limits_windows_7">Windows
            imposes some "gotcha" constraints on per-process memory</a> that have
            caught some people out in the past.
          </p>
         </doc:a>
      </doc:faq>

      </doc:section>

      <doc:section name="integration">
        <doc:heading>RabbitMQ Integration &amp; Interoperability</doc:heading>

        <doc:faq name="AMQP-1-0-migration">
          <doc:heading>What are your plans for migrating yourselves and your users to AMQP 1-0 when it is finalised?</doc:heading>
          <doc:a>
            <p>
              The <a href="https://www.amqp.org/confluence/display/AMQP/AMQP+Specification">AMQP 1-0 specification</a>
              is still a work in progress and introduces some major changes from previous
              versions.
            </p>
            <p>
              Our plan is to support 1-0 once it is finalised.  As a matter of
              practicality we will offer a migration path, for example it will be possible
              to simulate 0-8 and 0-9-1 in 1-0.  We do not expect 1-0 to be ready for
              serious implementation in the near term, and are satisfied that we are
              supporting the right versions with 0-8 and 0-9-1.
            </p>
          </doc:a>
        </doc:faq>

      </doc:section>

      <doc:section name="howto">
        <doc:heading>How-To</doc:heading>

        <doc:faq name="analyse-network-traffic">
          <doc:heading>Are there any tools are available to analyse AMQP network traffic?</doc:heading>
          <doc:a>
            <p>
              There's a very basic, very simple AMQP protocol analyzer in
              class <code>com.rabbitmq.tools.Tracer</code>. Invoke it with
            </p>
            <pre>runjava.sh com.rabbitmq.tools.Tracer <i>listenPort</i> <i>connectHost</i> <i>connectPort</i></pre>
            <p>
              <dl>
                <dt>listenPort</dt>
                <dd>port to listen for incoming AMQP connections on - defaults to 5673.</dd>
                <dt>connectHost</dt>
                <dd>hostname to use when making an outbound connection in response to an incoming connection - defaults to localhost.</dd>
                <dt>connectPort</dt>
                <dd>port number to use when making an outbound connection - defaults to 5672.</dd>
              </dl>
            </p>
            <p>
            There is also an <a href="http://wiki.wireshark.org/AMQP">AMQP plugin</a> available for <a href="http://www.wireshark.org/">Wireshark</a> .
            </p>
          </doc:a>
        </doc:faq>

     </doc:section>

      <doc:section name="configuration">
        <doc:heading>RabbitMQ Configuration</doc:heading>

        <doc:faq name="which-ports-to-open">
          <doc:heading>When running rabbitmq behind a firewall, which ports do I need to open?</doc:heading>
          <doc:a>
            <p>
         5672:tcp
            </p>
          </doc:a>
        </doc:faq>

     </doc:section>

      <doc:section name="performance">
        <doc:heading>Performance, Scalability &amp; Clustering</doc:heading>

        <doc:faq name="how-long-to-come-back-up">
          <doc:heading>How long does it take a node take to come back up?</doc:heading>
          <doc:a>
            <p>
              RabbitMQ records whether it was shutdown safely. Using
              the <code>init</code> scripts or the
              <code>rabbitmq-server</code> script to shutdown
              RabbitMQ counts as a safe shutdown. If RabbitMQ is
              started up after a safe shutdown, then it will start up
              very quickly indeed, almost regardless of the number of
              messages on disk.
            </p>
            <p>
              If RabbitMQ is not shutdown cleanly (e.g. it's killed,
              or the machine crashes), or if during startup it detects
              tampering of its files, it has to do many further checks
              to reach a consistent state from the data it recovers
              from disk. This can take several minutes when many
              millions of messages are involved.
            </p>
          </doc:a>
        </doc:faq>

        <doc:faq name="version-numbering">
          <doc:heading>How should I interpret RabbitMQ's version numbering?</doc:heading>
          <doc:a>
            <p>
              RabbitMQ is versioned with the scheme
              <code><i>major</i>.<i>minor</i>.<i>patch</i></code>.
            </p>
            <ul>
              <li>
                <code>major</code>: This number indicates the major
                version of the software. It is only changed for
                significant alterations to the software, such as (for
                instance) a total rewrite.
              </li>
              <li>
                <code>minor</code>: A change in this number indicates
                new or significantly altered features.
              </li>
              <li>
                <code>patch</code>: This number changes to make each
                distinct packaging of the software uniquely
                numbered. Small changes such as bug-fixes or packaging
                alterations may cause a change in only the
                <code>patch</code> number.
              </li>
            </ul>
          </doc:a>
        </doc:faq>

      </doc:section>
  </body>
</html>
