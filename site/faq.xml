<?xml-stylesheet type="text/xml" href="page.xsl"?>
<html xmlns:doc="http://www.rabbitmq.com/namespaces/ad-hoc/doc">
  <head>
    <title>RabbitMQ - Frequently Asked Questions</title>
  </head>
  <body>
    <doc:div>
      <h2>Frequently Asked Questions</h2>

      <p class="intro">
 See also these other sources of information:
<ul class="plain">
<li>an <a href="/how.html">overview of information resources</a> which includes links to presentations, blog posts and community links.</li>
<li>our standard <a href="/documentation.html">documentation</a></li>
</ul>
</p>

<p>
	If you have a question not answered here,
	please <a href="http://lists.rabbitmq.com">join our mailing list</a> or
	alternatively, contact us directly at <a
	href="mailto:info@rabbitmq.com">info@rabbitmq.com</a>.
</p>
   

      <doc:faqtoc class="compact"/>

      <doc:section name="background">
	<doc:heading>Background</doc:heading>
	
	<doc:faq name="what-is-messaging">
	  <doc:heading>What is messaging?</doc:heading>
	  <doc:a>
	    <p>
	      Messaging is used to manage data in motion, unlike, say, databases, which manage data at rest. Use messaging to
	      communicate between and scale applications, within your enterprise, across the web, or in the cloud.  
	    </p>
	  </doc:a>
	</doc:faq>
	
	<doc:faq name="what-is-amqp">
	  <doc:heading>What is AMQP?</doc:heading>
	  <doc:a>
	    <p>
	      <a href="specification.html">AMQP</a> is a standard
	      wire-level protocol and semantic framework for high
	      performance enterprise messaging.
	    </p>
	    <p>
	      From the AMQP website:
	    </p>
	    <blockquote>
	      <p>
		AMQP is an Open Standard for Messaging Middleware.
	      </p>
	      <p>
		By complying to the AMQP standard, middleware products
		written for different platforms and in different
		languages can send messages to one another. AMQP
		addresses the problem of transporting value-bearing
		messages across and between organisations in a timely
		manner.
	      </p>
	      <p>
		AMQP enables complete interoperability for messaging
		middleware; both the networking protocol and the
		semantics of broker services are defined in AMQP.
	      </p>
	    </blockquote>
	    <p>
	      For more information on what AMQP is, please see the <a
	      href="https://jira.amqp.org/confluence/display/AMQP/About+AMQP">AMQP
	      Working Group's overview page</a>.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="why-amqp">
	  <doc:heading>Why use AMQP?</doc:heading>
	  <doc:a>
	    <p>
	      AMQP is specifically designed with modern messaging
	      needs in mind, including the reduction of change and
	      maintenance costs through separation of integration
	      concerns, removal of silo dependency, and freedom from
	      language and platform lock in, without compromise on
	      user experience, security, scalability and consistently
	      excellent performance.
	    </p>
	    <p>
	      For more details please see <a
	      href="https://jira.amqp.org/confluence/display/AMQP/About+AMQP">this
	      page</a>.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="why-rabbitmq">
	  <doc:heading>Why use RabbitMQ?</doc:heading>
	  <doc:a>
	    <p>
	      RabbitMQ enables developers of messaging solutions to
	      take advantage of not just AMQP but also one of the most
	      proven systems on the planet.  The Open Telecom Platform
	      (OTP) is used by multiple telecommunications companies
	      to manage switching exchanges for voice calls, VoIP and
	      now video.  These systems are designed to never go down
	      and to handle truly vast user loads.  And because the
	      systems cannot be taken offline, they have to be very
	      flexible, for instance it must be possible to 'hot
	      deploy' features and fixes on the fly whilst managing a
	      consistent user SLA.
	    </p>
	    <p>
	      Instead of creating a new messaging infrastructure, the
	      RabbitMQ team selected the best one for the need, and
	      built an AMQP layer on top.  This combines the
	      robustness and scalability of a proven platform with the
	      flexibility of AMQP's messaging model.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="what-is-otp">
	  <doc:heading>What is the Open Telecom Platform (OTP)?</doc:heading>
	  <doc:a>
	    <p>
	      The <a href="http://www.erlang.se/">Open Telecom
	      Platform</a> (OTP) is a battle-tested library of
	      management, monitoring, and support code for
	      constructing extremely high-performance, reliable,
	      scalable, available (nine nines!) distributed network
	      applications. It is written in <a
	      href="http://www.erlang.org/">Erlang</a>.
	    </p>
	    <p>
	      For good general introductions to both technological and
	      business reasons supporting the use of Erlang and OTP,
	      we recommend the following:
	      <ul>
      <li>
        An <a
        href="http://www.ericsson.com/technology/opensource/erlang/index.shtml">overview
        of Erlang and OTP</a> by Ericsson, the original
        developer of the technology and one of its major
        commercial users.
      </li>
    <li>
		  An <a
		  href="http://www.ddj.com/architect/201001928"> 
      interview with Joe Armstrong</a>, Erlang and OTP's Chief Software Architect.
		</li>
    <li>
		  A discussion of <a
		  href="http://www.algorithm.com.au/talks/concurrency-erlang/">concurrency
		  and Erlang</a>, with examples from general Erlang
		  and OO programming, plus highlights from the online
		  multiplayer game industry.
		</li>
		<li>
		  An <a href="resources/armstrong.pdf">introduction to
		  Erlang</a> with motivating examples followed by
		  business proof-points.
		</li>
		<li>
		  A <a
		  href="resources/Carrier_Class_Telephony_Over_IP.pdf">white
		  paper</a> from Ericsson and Cisco (see particularly
		  page 15), discussing Ericsson's Engine Integral
		  softswitch solution, which is implemented using OTP
		  on Erlang.
		</li>
                <li>
                  A <a
                  href="http://www.erlang.se/euc/06/proceedings/1600Nystrom.ppt">case
                  study</a> by Motorola comparing the use of C++ and
                  Erlang for telecoms software.
                </li>
	      </ul>
	    </p>
	    <p>
	      For further details on the rationale for choosing
	      Erlang, please see the FAQ entries on <a
	      href="#clustering-design">clustering technology</a> and
	      <a href="#management-monitoring-control">management
	      interfaces</a>. Finally, we've prepared a comprehensive
	      assessment of Erlang's advantages at <a
	      href="erlang.html">this page</a>.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="scenarios">
	  <doc:heading>What messaging scenarios are supported by AMQP and RabbitMQ?</doc:heading>
	  <doc:a>
	    <p>
	      AMQP is a very general system that can be configured to
	      cover a great variety of messaging middleware
	      use-cases. For example:
	    </p>
	    <p>
	      <ul>
		<li>
		  <b>Point-to-point communication</b>
		  <p>
		    One of the simplest and most common scenarios is
		    for a message producer to transmit a message
		    addressed to a particular message consumer. AMQP
		    covers this scenario by allowing queues to be
		    named and to be bound to a "direct" exchange,
		    which routes messages to queues by name.
		  </p>
		</li>
		<li>
		  <b>One-to-many broadcasting (including multicast)</b>
		  <p>
		    In this scenario, the broadcasters publish
		    messages to an AMQP "fanout" exchange, and
		    subscribers create and subscribe to their own
		    private AMQP queues, which forward published
		    messages on to them, with one copy per queue.
		  </p>
		  <p>
		    Multicast is addressed at the broker
		    implementation level. AMQP clients need not be
		    made aware of transport-level optimisations such
		    as multicast: broker clusters are free to use
		    whatever such low-level optimisations are
		    available from configuration to configuration.
		  </p>
		  <p>
		    Multiple optimisations are possible, since AMQP
		    separates routing logic (exchanges and bindings)
		    from message queueing (queues). Multicast relates
		    only to routing from message publishers to message
		    queues, and as a routing optimisation can be
		    completely physically decoupled from AMQP's
		    logical semantics. Further optimisations include
		    physical separation of exchange from queue or even
		    colocation of queue with a consumer application.
		  </p>
		</li>
		<li>
		  <b>Transactional publication and acknowledgement</b>
		  <p>
		    AMQP supports transactional publication, where an
		    AMQP channel is opened, transactional mode is
		    selected, messages are published and acknowledged,
		    and the transaction is committed. The system
		    guarantees atomicity and durability properties for
		    transactional message activity.
		  </p>
		</li>
		<li>
		  <b>High-speed transient message flows</b>
		  <p>
		    Messages are individually flagged as transient or
		    persistent in AMQP at the time of publication. By
		    sending messages outside the transactional part of
		    the protocol, in non-persistent mode, an
		    application can achieve very high throughput and
		    low latency.
		  </p>
		</li>
		<li>
		  <b>Reliable persistent message delivery</b>
		  <p>
		    Messages that are published in persistent mode are
		    logged to disk for durability. If the server is
		    restarted, the system ensures that received
		    persistent messages are not lost. The
		    transactional part of the protocol provides the
		    final piece of the puzzle, by allowing the server
		    to communicate its definite receipt of a set of
		    published messages.
		  </p>
		</li>
		<li>
		  <b>Store-and-forward</b>
		  <p>
		    Store-and-forward is implemented by delivering
		    messages marked as "persistent" to AMQP's durable
		    queues. Published, persistent messages delivered
		    to durable queues are stored on disk until a
		    consumer retrieves and deletes them.
		  </p>
		</li>
		<li>
		  <b>Wide area messaging</b>
		  <p>
		    Because routing logic is decoupled from message
		    delivery, RabbitMQ is able to support extended
		    broker clustering across WANs. Some of the
		    approaches include AJAX-style access to AMQP
		    resources, and spanning-tree pseudo-multicast
		    implemented internally to a RabbitMQ cluster.
		  </p>
		</li>
		<li>
		  <b>File streaming</b>
		  <p>
		    The AMQP protocol, version 0-8, supports file
		    streaming by way of the <code>file</code> content
		    class. Very large files are transferred to a
		    temporary area on the broker before being routed
		    to queues for download by consumers.
		  </p>
		</li>
	      </ul>
	    </p>
	  </doc:a>
	</doc:faq>

      </doc:section>

      <doc:section name="features">
	<doc:heading>RabbitMQ Features</doc:heading>

	<doc:faq name="feature-transactional">
	  <doc:heading>Is RabbitMQ transactional?</doc:heading>
	  <doc:a>
	    <p>
	      Yes. RabbitMQ implements AMQP's "TX" message class, which
	      provides atomicity and durability properties to those
	      clients that request them.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="feature-reliable">
	  <doc:heading>Is RabbitMQ reliable and highly-available?</doc:heading>
	  <doc:a>
	    <p>
	      Yes. RabbitMQ is built atop the industry-leading <a
	      href="#what-is-otp">OTP</a> Erlang libraries, which
	      provides a solid foundation for building reliable
	      software. The underlying system supporting the Rabbit
	      codebase has been used by Ericsson to achieve <i>nine
	      nines</i> (99.9999999%) of availability.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="feature-clustering-failover">
	  <doc:heading>Does RabbitMQ support clustering, and high-availability through live failover?</doc:heading>
	  <doc:a>
	    <p>
	      Yes. RabbitMQ brokers can be made up of an arbitrary
	      number of nodes, each of which is available for AMQP
	      clients to connect to and interact with. RabbitMQ's
	      routing tables are shared across the entire cluster, and
	      delivery of messages published at one node to a queue
	      residing at another node is seamless. For details see
	      the <a href="clustering.html">clustering guide</a>. We
	      are currently developing further support for live
	      failover of AMQP resources within a cluster.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="smp-support">
	  <doc:heading>Will RabbitMQ use SMP, when it's available?</doc:heading>
	  <doc:a>
	    <p>
	      Yes. Erlang supports both single-node SMP configurations
	      and configurations with multiple Erlang nodes running in
	      a cluster within a single host.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="support-store-and-forward">
	  <doc:heading>Does RabbitMQ support store-and-forward?</doc:heading>
	  <doc:a>
	    <p>
	      Yes, RabbitMQ, and AMQP in general, supports
	      store-and-forward-style exchanges and queues.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="SMSstore-forward">
	  <doc:heading>Do you think RabbitMQ, as a core module, could handle real time traffic of
something like an SMSC (SMS foreward&amp;store)?</doc:heading>
	  <doc:a>
	    <p>
Absolutely. Some large telcos currently deploy Erlang/OTP-based systems
    in their SMSC infrastructure. At present these systems are not based on
    AMQP/RabbitMQ, but there is no reason why they couldn't be.

	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="support-store-and-forward">
	   <doc:heading>Can I create RabbitMQ applications using web frameworks (eg
	    Spring, or Ruby-On-Rails)?
	  </doc:heading>
	  <doc:a>
	    <p>
	      Yes. To begin with, Spring has good support for message
	      access in Java: the RabbitMQ Java client is simply a
	      POJO library. The same is true for other POJO-based
	      systems, such as <a
	      href="http://mulesource.org">Mule</a>. If you
	      specifically wish to use JavaEE EJBs as message
	      accessors, use a stateful session bean.
	    </p>
	    <p>
	      For frameworks in other languages, such as Ruby or
	      in-browser Javascript, we plan on providing both RESTful
	      HTTP access to AMQP features as well as AJAX- and
	      web-services-style interfaces, allowing rapid
	      development of web applications that take advantage of
	      AMQP messaging.
	    </p>
	  </doc:a>
	</doc:faq>

      </doc:section>

      <doc:section name="architecture">
	<doc:heading>RabbitMQ Architecture</doc:heading>

	<doc:faq name="authentication-authorization">
	  <doc:heading>How is authentication and authorization supported in RabbitMQ?</doc:heading>
	  <doc:a>
	    <p>
	      AMQP uses <a
	      href="http://tools.ietf.org/html/rfc4422">SASL</a> (see
	      also <a
	      href="http://en.wikipedia.org/wiki/Simple_Authentication_and_Security_Layer">Wikipedia
	      on SASL</a>) for authentication of AMQP clients. Our
	      current support for SASL is limited to the PLAIN
	      authentication mechanism.
	    </p>
	    <p>
	      Authorization is implemented in RabbitMQ using a
	      distributed database table mapping users to virtual
	      hosts.
	    </p>
	    <p>
	      Message authentication, for instance using <a
	      href="http://en.wikipedia.org/wiki/Message_authentication_code">cryptographic
	      message authentication codes</a>, is not defined by the
	      AMQP specification, but as for encryption, could be very
	      easily implemented within the RabbitMQ client library.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="rabbit-platforms">
	  <doc:heading>What platforms will RabbitMQ run on?</doc:heading>
	  <doc:a>
	    <p>
	      RabbitMQ is developed on Debian Linux and Mac OS X. As
	      the server component is written in Erlang, and the
	      client component in Java, it is platform-neutral. Erlang
	      runs on the following platforms (taken from <a
	      href="http://www.erlang.org/faq/faq.html#AEN903">Erlang's
	      FAQ</a>):
	    </p>
	    <p>
	      <ul class="compact">
		<li>Solaris (including 64 bit)</li>
		<li>BSD</li>
		<li>Linux</li>
		<li>OSX</li>
		<li>TRU64</li>
		<li>Windows NT/2000/2003/XP</li>
		<li>Windows 95, 98</li>
		<li>VxWorks</li>
	      </ul>
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="shared-session-clustering">
	  <doc:heading>What is shared session clustering?</doc:heading>
	  <doc:a>
	    <p>
	      For those familiar with typical tiered
	      session/application architectures such as JavaEE, it
	      might help to think of the AMQP exchanges as
	      corresponding to a logical session tier, and AMQP queues
	      as corresponding to a logical application tier. From
	      this point of view, RabbitMQ's routing tables can be seen
	      as clustered shared session state. RabbitMQ uses the OTP
	      distributed database, Mnesia, to reliably and
	      persistently replicate session state across all nodes in
	      a cluster.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="clustering-design">
	  <doc:heading>How does clustering work?</doc:heading>
	  <doc:a>
	    <p>
	      RabbitMQ's current clustering mechanisms are built around
	      Erlang's native support for reliable distributed
	      programming. This is a deeply sophisticated framework,
	      implemented at the language and virtual-machine level.
	    </p>
	    <p>
	      Some of the unique points about Erlang's networking and
	      distribution model are:
	      <ul>
		<li>
		  it scales to hundreds of thousands of parallel
		  processes ("green threads") within a single virtual
		  machine, bounded only by available memory;
		</li>
		<li>
		  the failure model for local inter-process
		  communication (IPC) is the same as that for
		  distributed IPC, making the transition from
		  non-distributed to distributed code very smooth;
		</li>
		<li>
		  binary pattern-matching constructs within the
		  language ensure straightforward and efficient
		  translation between wire-level encodings and
		  internal Erlang data structures;
		</li>
		<li>
		  finally, the OTP libraries shipped with the Erlang
		  distribution include the notion of a
		  supervisor/worker relationship, where supervisor
		  processes monitor and restart worker processes under
		  their control, making management of the entire
		  process hierarchy within a server deterministic and
		  automatic.
		</li>
	      </ul>
	    </p>
	    <p>
	      Within an Erlang node cluster, Erlang's native
	      high-speed messaging is used to provide an efficient way
	      of distributing work across the cluster. Individual AMQP
	      clients connect to machines within the cluster, and
	      Erlang's distributed routing database routes AMQP
	      messages to the appropriate endpoints.
	    </p>
	    <p>
	      For more detail on Erlang's benefits in an AMQP setting,
	      please see <a href="erlang.html">this page</a>.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="failover-ha">
	  <doc:heading>How does failover and HA work?</doc:heading>
	  <doc:a>
	    <p>
	      Currently, AMQP durable queues and their persistent
	      messages are recovered from disk at each server
	      restart. Exchange failover is handled by OTP's support
	      for clustering (see <a
	      href="#shared-session-clustering">above</a>).
	    </p>
	    <p>
	      Future releases will support live failover using, for
	      instance, a combination of the "known hosts" field in
	      <code>connection.open-ok</code> and the
	      <code>connection.redirect</code> message. Erlang's
	      built-in fault-tolerant database will ensure that
	      routing information is preserved, and the OTP supervisor
	      architecture in combination with AMQP's transactional
	      features will ensure that durable messages are not lost.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="addressing-in-amqp">
	  <doc:heading>How does addressing work in AMQP?</doc:heading>
	  <doc:a>
	    <p>
	      Like other messaging systems, AMQP and RabbitMQ provide
	      internal addressing mechanisms based on notions such as
	      routing keys, exchange addresses and queue
	      names.
	    </p>
	    <p>
	      These are managed on a per-virtual-host basis. Please
	      see the AMQP specification for details of the scoping of
	      the various names in the network. We are actively
	      investigating interoperation with other addressing
	      schemes and systems.
	    </p>
	  </doc:a>
	</doc:faq>
	
		<doc:faq name="scale-balance">
	  <doc:heading>How is RabbitMQ scaled and the load balance handled?</doc:heading>
	  <doc:a>
	    <p>
	     At the core we are relying on Erlang/OTP to distribute one logical AMQP
    broker across several physical nodes, with the necessary broker state
    being maintained in an instance of OTP's distributed database Mnesia.
    There are certain aspects of the AMQP spec that are currently undergoing
    revision that impact this area, so watch out for associated new features
    and documentation in future releases of RabbitMQ.

	    </p>
	  </doc:a>
	</doc:faq>
	
      </doc:section>

      <doc:section name="integration">
	<doc:heading>Integration</doc:heading>

	<doc:faq name="rabbit-client-support">
	  <doc:heading>What clients does RabbitMQ support?</doc:heading>
	  <doc:a>
	    <p>
	      We maintain <a href="/how.html#clients">a list of clients</a>, which is fairly complete.  If you don't
see one you want, please <a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo">email our mailing list.</a>
	    </p>
	  </doc:a>
	</doc:faq>
 
      </doc:section>

      <doc:section name="howto">
	<doc:heading>How-To</doc:heading>

	<doc:faq name="last-message-on-topic">
	  <doc:heading>"Last" message on Topic</doc:heading>
	  <doc:q>
	    <p>
	      A classic use-case for messaging systems is the example
	      of subscribing to a topic of, say, 'market prices' for
	      an asset. By that a client very often means, "send me
	      the last published one and then subscribe me to any
	      update". Sometimes it is not necessary if the asset is
	      liquid (MSFT) but if it is illiquid, the client should
	      receive the last available message, as it's possible
	      there will be a long delay before the next update.
	    </p>
	    <p>
	      Does RabbitMQ support this?
	    </p>
	  </doc:q>
	  <doc:a>
	    <p>
	      This is not something AMQP provides out-of-the-box,
	      although one can imagine a solution involving a trivial
	      service (a simple hash table, in effect) answering
	      requests for most-recent-price served via AMQP. The
	      client would subscribe to the stream as usual, and in
	      parallel ask the service for the most recent price.
	    </p>
	    <p>
	      Such a service could be implemented either inside the
	      RabbitMQ broker, in Erlang, thus taking advantage of
	      Erlang's distribution and high-availability properties,
	      or it could be implemented outside the broker, as a
	      regular AMQP client.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="channel-encryption">
	  <doc:heading>Channel Encryption</doc:heading>
	  <doc:q>
	    <p>
	      Say I want to transfer a message across the AMQP
	      network, without depending on the target being there,
	      and that the 'channel' between the message source client
	      and the message target client should be strongly
	      encrypted and authenticated. Is this something RabbitMQ
	      provides?
	    </p>
	  </doc:q>
	  <doc:a>
	    <p>
	      There are two kinds of encryption that could be
	      supported by an AMQP implementation.
	    </p>
	    <p>
	      The first is encryption of the AMQP stream. There's no
	      provision in the standard for that, yet, but wrapping
	      the stream in a TLS layer is a straightforward extension
	      (please see the <a href="api-guide.html#ssl">section on
	      SSL/TLS in our API guide</a>). The notion of addressing
	      for AMQP entities (ie. URLs for AMQP queues and
	      exchanges) is under active development at the moment. It
	      seems likely that once that settles down, it will
	      quickly be extended to standardise a TLS layering for
	      AMQP ("amqp:" -> "amqps:" ?).
	    </p>
	    <p>
	      The second kind of encryption is encryption of
	      individual messages. AMQP is silent on this front as
	      well, but using a layer of encryption in the clients is
	      very easy. Adding support for this to RabbitMQ's client
	      library would be a simple matter.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="access_control">
	  <doc:heading>How do I configure access control?</doc:heading>
	  <doc:a>
	    <p>
	      Please see the section on <a
	      href="admin-guide.html#access-control">access
	      control</a> in the RabbitMQ <a
	      href="admin-guide.html">admin guide</a>.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="instrumentation-logging-debugging">
	  <doc:heading>Instrumentation, logging and debugging</doc:heading>
	  <doc:a>
	    <p>
	      RabbitMQ uses AMQP internally to the broker to notify
	      interested parties of significant events. Administration
	      and management exchanges are provided for tools to bind
	      to.
	    </p>
	    <p>
	      In addition, there is some discussion in the AMQP
	      community of the need for replay as a built-in feature.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="testing-rabbit">
	  <doc:heading>How do I test RabbitMQ?</doc:heading>
	  <doc:a>
	    <p>
	      You can test the RabbitMQ broker by:
	    </p>
	    <p>
	      <ul class="compact">
		<li>
		  connecting to our <a
		  href="examples.html#demo-server">demo server</a>
		  using one of the RabbitMQ <a
		  href="examples.html">example programs</a>
		</li>
		<li>
		  connecting to our demo server using another AMQP
		  0-8 compatible client
		</li>
		<li>
		  <a href="download.html">Downloading</a> the broker
		  and experimenting with it on your own machine
		</li>
	      </ul>
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="public-test-server">
	  <doc:heading>Can I test my AMQP client against RabbitMQ?</doc:heading>
	  <doc:a>
	    <p>
	      Yes: you can either run your client against our <a
	      href="examples.html#demo-server">public demonstration
	      server</a>, or <a href="download.html">download</a> and
	      <a href="install.html">run</a> a server of your own to
	      experiment with.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="replication-scope">
	  <doc:heading>How do I tune the scope of replication? Will it affect performance?</doc:heading>
	  <doc:a>
	    <p>
	      Since replication is used mainly to propagate routing
	      table information between Erlang nodes within a cluster,
	      it has a low impact on performance to begin with; also,
	      it is trivial to arrange for a "queue-only" Erlang node
	      to join the cluster, only able to consume from queues,
	      which can then avoid being part of the routing-table
	      replication system.
	    </p>
	  </doc:a>
	</doc:faq>

     </doc:section>

      <doc:section name="performance">
	<doc:heading>Performance and Scalability</doc:heading>

	<doc:faq name="performance-latency">
	  <doc:heading>How low can latency be?</doc:heading>
	  <doc:a>
	    <p>
	      We have seen latencies averaging less than a
	      millisecond; for heavy, steady-state loads, latency
	      hovers around the 4-millisecond mark (including two
	      network hops).
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="performance-persistent">
	  <doc:heading>How fast is RabbitMQ in persistent mode?</doc:heading>
	  <doc:a>
	    <p>
	      From our testing, we expect easily-achievable
	      throughputs of 4000 persistent, non-transacted
	      one-kilobyte messages per second (Intel Pentium D,
	      2.8GHz, dual core, gigabit ethernet) from a single
	      RabbitMQ broker node writing to a single spindle.
	    </p>
	    <p>
	      Please let us know how RabbitMQ performs for you!
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="performance-options">
	  <doc:heading>How do I switch off persistence/transactionality?</doc:heading>
	  <doc:a>
	    <p>
	      To disable transactionality, use an AMQP channel which
	      is not in "TX" mode (ie. do not call
	      <code>tx.select</code>). To disable message persistence,
	      set the "delivery mode" field in the
	      <code>basic</code>-class properties for the message to
	      either absent or to one, as mode two enables
	      persistence.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="clustering-scalability">
	  <doc:heading>How does RabbitMQ's performance scale with clustering?</doc:heading>
	  <doc:a>
	    <p>
	      Based on typical OTP application scalability, we expect
	      close-to-linear scaling.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="general-scalability">
	  <doc:heading>How many virtual hosts can I run and where?</doc:heading>
	  <doc:a>
	    <p>
	      There is no hard limit to the number of virtual hosts
	      that can be configured within a RabbitMQ cluster, save
	      available disk and memory resources.
	    </p>
	    <p>
	      Virtual hosts within AMQP are decoupled from the
	      physical network layout: one virtual host can be
	      accessed from multiple clustered brokers, just as many
	      virtual hosts can be accessed within a single
	      broker. Virtual hosts act solely as a namespacing
	      mechanism for AMQP resources.
	    </p>
	    <p>We want to get to the point where one can dynamically add and remove
nodes to/from a cluster that represents one logical AMQP broker, for
both reliability and scalability (to very high numbers of nodes).</p>

<p>This is an important area for us, and one of the reasons we chose
Erlang/OTP as the implementation platform for RabbitMQ. </p>
	  </doc:a>
	</doc:faq>
	
		<doc:faq name="how-many-concurrent-connections">
	  <doc:heading>How many concurrent connections can RabbitMQ support?</doc:heading>
	  <doc:a>
	    <p>You mean concurrent TCP connections? In theory as many as the operating
system will give you. If there are any niggles
they can be sorted out quite easily.</p>

<p>Also note that AMQP allows you to multiplex AMQP sessions across a
single TCP connection.</p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="maximum-throughput">
	  <doc:heading>What's the maximum bytes/second throughput of an instance?  Can scaling be used to get more bytes/second through the system?</doc:heading>
	  <doc:a>
	    <p>We are discussing testing, both functional and performance, within the
AMQP working group, with the idea of defining a shared set of AMQP
tests, and the code to implement them.</p>

<p>The problem is that there are many possible configurations of the test
infrastructure, the RabbitMQ broker, the clients, and the tests
themselves (e.g. AMQP supports many different forms of message
delivery). In order to obtain meaningful performance figures one would
have to specify exactly what the setup is, to the point where anybody
can replicate it. Even then one would get just one data point in an
infinite space of possible configurations, and it is generally
impossible to extrapolate the results from one test to other scenarios.</p>
	  </doc:a>
	</doc:faq>


	<doc:faq name="how-are-connections-secured">
	  <doc:heading>How are the connections secured?  HTTPS or something else?  What about certificate management?</doc:heading>
	  <doc:a>
	    <p>The standard only defines basic username/password authentication. There
are plans to extend that with SASL or some such mechanism.</p>

<p>It should be possible to add SSL/TLS quite trivially. Certificate
management would be done in a similar fashion to most other
SSL/TLS-enable apps.</p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="is-the-wire-protocol-pure-binary">
	  <doc:heading>Is the wire protocol pure binary or is there some XML mixed in?  Slap me and point me to the documentation if the answer is obvious.</doc:heading>
	  <doc:a>
	    <p>The protocol is pure binary.</p>
	  </doc:a>
	</doc:faq>

      </doc:section>

      <doc:section name="general">
	<doc:heading>General</doc:heading>

	<doc:faq name="rabbit-pricing">
	  <doc:heading>How is RabbitMQ priced?</doc:heading>
	  <doc:a>
	    <p>
	      RabbitMQ is free software in both the gratis and libre
	      senses, licenced under the <a href="mpl.html">Mozilla
	      Public License</a>.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="support-options">
	  <doc:heading>What support options are available for RabbitMQ?</doc:heading>
	  <doc:a>
	    <p>
	      RabbitMQ will be supported, both commercially and as an
	      open-source project, by both <a
	      href="http://www.lshift.net/">LShift</a> and by <a
	      href="http://www.cohesiveft.com/">CohesiveFT</a> as
	      virtual appliances. For inquiries about support, please
	      email <a
	      href="mailto:support@rabbitmq.com">support@rabbitmq.com</a>. For
	      inquiries specifically about virtual appliances, contact
	      <a
	      href="mailto:support@cohesiveft.com">support@cohesiveft.com</a>.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="rabbit-licensing">
	  <doc:heading>How is RabbitMQ licenced (for redistribution, etc.)?</doc:heading>
	  <doc:a>
	    <p>
	      RabbitMQ is distributed under the open-source <a
	      href="mpl.html">Mozilla Public License</a>.
	    </p>
	    <p>
	      If you would like to explore other licensing options,
	      please get in touch with us by emailing <a
	      href="mailto:info@rabbitmq.com">info@rabbitmq.com</a>.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="contribution">
	  <doc:heading>How do I contribute to the RabbitMQ project?</doc:heading>
	  <doc:a>
	    <p>
	      Welcome aboard! We love contributions - here are some
	      suggestions for what you can work on:
	    </p>
	    <p>
	      <ul class="compact">
		<li>packaging for other operating systems</li>
		<li>integration with other messaging systems</li>
		<li>integration with other management systems</li>
		<li>integration with other user and permission database systems</li>
		<li>improvements to the client, and work towards other clients</li>
		<li>new services for running with RabbitMQ, either within the broker or adjacent to it</li>
		<li>... and so on!</li>
	      </ul>
	    </p>
	    <p>
	      We're happy to hear from anyone who wants to get
	      involved or is curious about how we intend to manage the
	      project.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="version-numbering">
	  <doc:heading>How should I interpret RabbitMQ's version numbering?</doc:heading>
	  <doc:a>
	    <p>
	      RabbitMQ is versioned with the scheme
	      <code><i>major</i>.<i>minor</i>.<i>patch</i></code>.
	    </p>
            <ul>
              <li>
                <code>major</code>: This number indicates the major
                version of the software. It is only changed for
                significant alterations to the software, such as (for
                instance) a total rewrite.
              </li>
              <li>
                <code>minor</code>: A change in this number indicates
                new or significantly altered features.
              </li>
              <li>
                <code>patch</code>: This number changes to make each
                distinct packaging of the software uniquely
                numbered. Small changes such as bug-fixes or packaging
                alterations may cause a change in only the
                <code>patch</code> number.
              </li>
            </ul>
            <p>
              We also label each release with a <i>status</i>. This is
              either <i>alpha</i>, <i>beta</i>, <i>rc</i> (for
              "release candidate") or <i>final</i>, and indicates the
              maturity of the release. The status is mentioned in the
              release announcement and on the download page.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="rffaq">
	  <doc:heading>I have a question!</doc:heading>
	  <doc:a>
	    <p>
	      Please <a href="http://lists.rabbitmq.com">join our mailing list</a> or 
        send questions to <a
	      href="mailto:info@rabbitmq.com">info@rabbitmq.com</a>. We'd
	      love to hear from you.
	    </p>
	  </doc:a>
	</doc:faq>

      </doc:section>
    </doc:div>
  </body>
</html>
