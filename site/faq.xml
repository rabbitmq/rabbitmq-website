<?xml-stylesheet type="text/xml" href="page.xsl"?>
<!DOCTYPE html PUBLIC "bug in xslt processor requires fake doctype" 
"otherwise css isn't included" [
<!ENTITY % entities SYSTEM "rabbit.ent" >
%entities;
]>
<html xmlns:doc="http://www.rabbitmq.com/namespaces/ad-hoc/doc">
  <head>
    <title>RabbitMQ - Frequently Asked Questions</title>
  </head>
  <body>
    <doc:div>
      <h2>Frequently Asked Questions</h2>

      <p class="intro">
 See also these other sources of information:
<ul class="plain">
<li>an <a href="/how.html">overview of information resources</a> which includes links to presentations, blog posts and community links.</li>
<li>our standard <a href="/documentation.html">documentation</a></li>
</ul>
</p>

<p>
	If you have a question not answered here,
	please <a href="http://lists.rabbitmq.com">join our mailing list</a> or
	alternatively, contact us directly at <a
	href="mailto:info@rabbitmq.com">info@rabbitmq.com</a>.
</p>
   

      <doc:faqtoc class="compact"/>

      <doc:section name="background">
	<doc:heading>Background</doc:heading>
	
	<doc:faq name="what-is-messaging">
	  <doc:heading>What is messaging?</doc:heading>
	  <doc:a>
	    <p>
	      Messaging is used to manage data in motion, unlike, say, databases, which manage data at rest. Use messaging to
	      communicate between and scale applications, within your enterprise, across the web, or in the cloud.  
	    </p>
	  </doc:a>
	</doc:faq>
	
	<doc:faq name="what-is-amqp">
	  <doc:heading>What is AMQP?</doc:heading>
	  <doc:a>
	    <p>
	      <a href="specification.html">AMQP</a> is a standard
	      wire-level protocol and semantic framework for high
	      performance enterprise messaging.
	    </p>
	    <p>
	      From the AMQP website:
	    </p>
	    <blockquote>
	      <p>
		AMQP is an Open Standard for Messaging Middleware.
	      </p>
	      <p>
		By complying to the AMQP standard, middleware products
		written for different platforms and in different
		languages can send messages to one another. AMQP
		addresses the problem of transporting value-bearing
		messages across and between organisations in a timely
		manner.
	      </p>
	      <p>
		AMQP enables complete interoperability for messaging
		middleware; both the networking protocol and the
		semantics of broker services are defined in AMQP.
	      </p>
	    </blockquote>
	    <p>
	      For more information on what AMQP is, please see the <a
	      href="https://jira.amqp.org/confluence/display/AMQP/About+AMQP">AMQP
	      Working Group's overview page</a>.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="why-amqp">
	  <doc:heading>Why use AMQP?</doc:heading>
	  <doc:a>
	    <p>
	      AMQP is specifically designed with modern messaging
	      needs in mind, including the reduction of change and
	      maintenance costs through separation of integration
	      concerns, removal of silo dependency, and freedom from
	      language and platform lock in, without compromise on
	      user experience, security, scalability and consistently
	      excellent performance.
	    </p>
	    <p>
	      For more details please see <a
	      href="https://jira.amqp.org/confluence/display/AMQP/About+AMQP">this
	      page</a>.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="why-rabbitmq">
	  <doc:heading>Why use RabbitMQ?</doc:heading>
	  <doc:a>
	    <p>
	      RabbitMQ enables developers of messaging solutions to
	      take advantage of not just AMQP but also one of the most
	      proven systems on the planet.  The Open Telecom Platform
	      (OTP) is used by multiple telecommunications companies
	      to manage switching exchanges for voice calls, VoIP and
	      now video.  These systems are designed to never go down
	      and to handle truly vast user loads.  And because the
	      systems cannot be taken offline, they have to be very
	      flexible, for instance it must be possible to 'hot
	      deploy' features and fixes on the fly whilst managing a
	      consistent user SLA.
	    </p>
	    <p>
	      Instead of creating a new messaging infrastructure, the
	      RabbitMQ team selected the best one for the need, and
	      built an AMQP layer on top.  This combines the
	      robustness and scalability of a proven platform with the
	      flexibility of AMQP's messaging model.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="what-is-otp">
	  <doc:heading>What is the Open Telecom Platform (OTP)?</doc:heading>
	  <doc:a>
	    <p>
	      The <a href="http://www.erlang.se/">Open Telecom
	      Platform</a> (OTP) is a battle-tested library of
	      management, monitoring, and support code for
	      constructing extremely high-performance, reliable,
	      scalable, available (nine nines!) distributed network
	      applications. It is written in <a
	      href="http://www.erlang.org/">Erlang</a>.
	    </p>
	    <p>
	      For good general introductions to both technological and
	      business reasons supporting the use of Erlang and OTP,
	      we recommend the following:
	      <ul>
      <li>
        An <a
        href="http://www.ericsson.com/technology/opensource/erlang/index.shtml">overview
        of Erlang and OTP</a> by Ericsson, the original
        developer of the technology and one of its major
        commercial users.
      </li>
    <li>
		  An <a
		  href="http://www.ddj.com/architect/201001928"> 
      interview with Joe Armstrong</a>, Erlang and OTP's Chief Software Architect.
		</li>
    <li>
		  A discussion of <a
		  href="http://www.algorithm.com.au/talks/concurrency-erlang/">concurrency
		  and Erlang</a>, with examples from general Erlang
		  and OO programming, plus highlights from the online
		  multiplayer game industry.
		</li>
		<li>
		  An <a href="resources/armstrong.pdf">introduction to
		  Erlang</a> with motivating examples followed by
		  business proof-points.
		</li>
		<li>
		  A <a
		  href="resources/Carrier_Class_Telephony_Over_IP.pdf">white
		  paper</a> from Ericsson and Cisco (see particularly
		  page 15), discussing Ericsson's Engine Integral
		  softswitch solution, which is implemented using OTP
		  on Erlang.
		</li>
                <li>
                  A <a
                  href="http://www.erlang.se/euc/06/proceedings/1600Nystrom.ppt">case
                  study</a> by Motorola comparing the use of C++ and
                  Erlang for telecoms software.
                </li>
	      </ul>
	    </p>
	    <p>
	      For further details on the rationale for choosing
	      Erlang, please see the FAQ entries on <a
	      href="#clustering-design">clustering technology</a> and
	      <a href="#management-monitoring-control">management
	      interfaces</a>. Finally, we've prepared a comprehensive
	      assessment of Erlang's advantages at <a
	      href="erlang.html">this page</a>.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="scenarios">
	  <doc:heading>What messaging scenarios are supported by AMQP and RabbitMQ?</doc:heading>
	  <doc:a>
	    <p>
	      AMQP is a very general system that can be configured to
	      cover a great variety of messaging middleware
	      use-cases. For example:
	    </p>
	    <p>
	      <ul>
		<li>
		  <b>Point-to-point communication</b>
		  <p>
		    One of the simplest and most common scenarios is
		    for a message producer to transmit a message
		    addressed to a particular message consumer. AMQP
		    covers this scenario by allowing queues to be
		    named and to be bound to a "direct" exchange,
		    which routes messages to queues by name.
		  </p>
		</li>
		<li>
		  <b>One-to-many broadcasting (including multicast)</b>
		  <p>
		    In this scenario, the broadcasters publish
		    messages to an AMQP "fanout" exchange, and
		    subscribers create and subscribe to their own
		    private AMQP queues, which forward published
		    messages on to them, with one copy per queue.
		  </p>
		  <p>
		    Multicast is addressed at the broker
		    implementation level. AMQP clients need not be
		    made aware of transport-level optimisations such
		    as multicast: broker clusters are free to use
		    whatever such low-level optimisations are
		    available from configuration to configuration.
		  </p>
		  <p>
		    Multiple optimisations are possible, since AMQP
		    separates routing logic (exchanges and bindings)
		    from message queueing (queues). Multicast relates
		    only to routing from message publishers to message
		    queues, and as a routing optimisation can be
		    completely physically decoupled from AMQP's
		    logical semantics. Further optimisations include
		    physical separation of exchange from queue or even
		    colocation of queue with a consumer application.
		  </p>
		</li>
		<li>
		  <b>Transactional publication and acknowledgement</b>
		  <p>
		    AMQP supports transactional publication, where an
		    AMQP channel is opened, transactional mode is
		    selected, messages are published and acknowledged,
		    and the transaction is committed. The system
		    guarantees atomicity and durability properties for
		    transactional message activity.
		  </p>
		</li>
		<li>
		  <b>High-speed transient message flows</b>
		  <p>
		    Messages are individually flagged as transient or
		    persistent in AMQP at the time of publication. By
		    sending messages outside the transactional part of
		    the protocol, in non-persistent mode, an
		    application can achieve very high throughput and
		    low latency.
		  </p>
		</li>
		<li>
		  <b>Reliable persistent message delivery</b>
		  <p>
		    Messages that are published in persistent mode are
		    logged to disk for durability. If the server is
		    restarted, the system ensures that received
		    persistent messages are not lost. The
		    transactional part of the protocol provides the
		    final piece of the puzzle, by allowing the server
		    to communicate its definite receipt of a set of
		    published messages.
		  </p>
		</li>
		<li>
		  <b>Store-and-forward</b>
		  <p>
		    Store-and-forward is implemented by delivering
		    messages marked as "persistent" to AMQP's durable
		    queues. Published, persistent messages delivered
		    to durable queues are stored on disk until a
		    consumer retrieves and deletes them.
		  </p>
		</li>
		<li>
		  <b>Wide area messaging</b>
		  <p>
		    Because routing logic is decoupled from message
		    delivery, RabbitMQ is able to support extended
		    broker clustering across WANs. Some of the
		    approaches include AJAX-style access to AMQP
		    resources, and spanning-tree pseudo-multicast
		    implemented internally to a RabbitMQ cluster.
		  </p>
		</li>
		<li>
		  <b>File streaming</b>
		  <p>
		    The AMQP protocol, version 0-8, supports file
		    streaming by way of the <code>file</code> content
		    class. Very large files are transferred to a
		    temporary area on the broker before being routed
		    to queues for download by consumers.
		  </p>
		</li>
	      </ul>
	    </p>
	  </doc:a>
	</doc:faq>

      </doc:section>

      <doc:section name="managing-concepts-exchanges">
	<doc:heading>Managing concepts: Exchanges</doc:heading>
	
	<doc:faq name="fanout-exchange">
	  <doc:heading>What is a fanout exchange</doc:heading>
	  <doc:a>
	    <p>
	    A fanout exchange is the simplest exchange type, representing a 1:N message delivery
	    pattern. No routing keys are involved – you simply bind a queue to the exchange and
	    messages sent to that exchange get delivered to <strong>all</strong> the bound queues.	
	    </p>
	  </doc:a>
	</doc:faq>
	
	<doc:faq name="direct-exchange">
	  <doc:heading>What is a direct exchange</doc:heading>
	  <doc:a>
	    <p>
	    A direct exchange is a 1:1 form of communication where a routing key directs how a broker
	    routes the message from the producer to the consumer. This is a straight match. If a queue
	    binds to an exchange requesting messages with the routing key "lady", only messages labelled
	    "lady" get delivered to that queue (not "lady.bird" or "lady.macbeth").	
	    </p>
	  </doc:a>
	</doc:faq>
	
	<doc:faq name="topic-exchange">
	  <doc:heading>What is a topic exchange</doc:heading>
	  <doc:a>
	    <p>
	    Here, the broker matches the routing key against a pattern to determine how to deliver the
	    message. Instead of binding a queue to an exchange with a simple string, the queue is bound
	    with a pattern. In the pattern, the symbol # matches one or more words and the symbol *
	    matches any single word. Typical bindings might be "uk.#" for all items in the uk, "#.weather"
	    for all weather items, or "uk.weather" for all uk weather items.	
	    </p>
	  </doc:a>
	</doc:faq>	
	
	<doc:faq name="exchange-client-or-server">
	  <doc:heading>I am using a client library, and I am wondering, do I create the exchanges on the 
	  server, or is it all done client-side?</doc:heading>
	  <doc:a>
	    <p>
	    You would use some client to issue exchange.declare, which creates the exchange on the
	    server when the server receives the command. You can do the exchange.declare at any time
	    before you need to use the exchange.	
	    </p>
	  </doc:a>
	</doc:faq>	
	
	<doc:faq name="exchange-why-client">
	  <doc:heading>I'm reading the docs, but I don't understand why the exchanges are created at the
	  client, doesn't it make sense to create them on the server?</doc:heading>
	  <doc:a>
	    <p>
	    The semantics of exchange declare that if the exchange does not already exist on the server,
	    then create a new exchange. Otherwise reuse an existing exchange.	
	    </p>
	  </doc:a>
	</doc:faq>
	
	<doc:faq name="organize-exchanges">
	  <doc:heading>How do I organize my exchanges? I want to have different parties to delivery, but
	  they will be hierarchical.</doc:heading>
	  <doc:a>
	    <p>
	    You may want to read the part in the spec about how the topic exchanges work. Like nation
	    includes sectors which include states which include regions which include counties. You could
	    use topic exchange with 'nz.northisland.wellington.arovalley.arostreet.54' and the bind with a
	    pattern of nz.# or nz.southisland.#	
	    </p>
	  </doc:a>
	</doc:faq>
	
	<doc:faq name="exchanges-routing-key-bind-pattern-hash">
	  <doc:heading>Is a topic exchange with routing-key binding pattern "#" essentially a fanout?</doc:heading>
	  <doc:a>
	    <p>
	    Yes.
	    </p>
	  </doc:a>
	</doc:faq>
	
	<doc:faq name="fanout-direct-topic-specialisations">
	  <doc:heading>Hey, fanout and direct look like simple specialisations of topic, am I right?</doc:heading>
	  <doc:a>
	    <p>
	    Yep.
	    </p>
	    <p>
	    Direct exchanges can be simulated by using topic exchanges without wildcards, and fanout
	    exchanges can be simulated by binding to topic exchanges with a full wildcard pattern.
	    </p>
	    <p>
	    The different kinds of exchange exist mainly for clarity's sake: it's easier for an observer
	    looking at a system to see the intent behind the way it's configured. Secondarily, it opens up
	    opportunities for optimising the less-general kinds of exchange.
	    </p>
	  </doc:a>
	</doc:faq>
	
	<doc:faq name="exchange-lifespan">
	  <doc:heading>When I create an exchange, does it stay created, or does the exchange disappear 
	  anytime the client disconnects?</doc:heading>
	  <doc:a>
	    <p>
	    Whether they disappear in time or not depends on the options that you set when you declare
	    an exchange. One option is durability, which means an exchange will survive a server restart.
	    Autodelete is another option that indicates that the server should remove an exchange when
	    all queues have stopped using it.
	    </p>
	  </doc:a>
	</doc:faq>
	
	<doc:faq name="which-entity-should-declare-exchanges">
	  <doc:heading>I'm interested in creating an exchange. Which entity should declare the exchange,
	  the publisher or subscriber?</doc:heading>
	  <doc:a>
	    <p>
	    Not wanting to be overly theoretical, but the AMQP working group is now moving to a more
	    formal definition of declarations that mean that they have the same semantics as an assertion.
	    </p>
	    <p>
	    So by saying declare queue q or declare exchange x, you are effectively saying "I assert the
	    existence of object o, if it does not exist, make it so".
	    </p>
	    <p>
	    Publishers need to write to somewhere.
	    </p>
	    <p>
	    Consumers need to have queues bound to something.
	    </p>
	    <p>
	    So both sides are only interested in the mere existence of the thing they need to do their job,
	    not whether they or some other guy originally initiated that object's creation.
	    </p>
	  </doc:a>
	</doc:faq>
	
	<doc:faq name="publisher-and-consumer-declare-exchanges">
	  <doc:heading>So then it makes sense for both the publisher and consumer to both declare the exchange?</doc:heading>
	  <doc:a>
	    <p>
	    Semantically yes. But don't be too dogmatic about it in every scenario, if your application
	    knows for sure that a particular queue or exchange definitely does exist, it can save a lookup
	    for the existence of that object. Just an efficiency consideration. But don't optimize
	    prematurely :-)
	    </p>
	  </doc:a>
	</doc:faq>
	
      </doc:section>
      

      <doc:section name="Binding-and-Routing">
	<doc:heading>Binding and Routing</doc:heading>

	<doc:faq name="what-are-bindings">
	  <doc:heading>What are bindings?</doc:heading>
	  <doc:a>
	    <p>
	    When you publish a message, you send a "routing key" along with it, that's used by the
	    exchange when it decides which queues to forward a copy of the message on to. The links
	    between exchanges and queues are created through binding, with a "binding pattern" that is
	    used by the exchange when comparing against routing keys.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="wildcards-in-topic-exchanges">
	  <doc:heading>How do the wildcards work when binding to topic exchanges?</doc:heading>
	  <doc:a>
	    <p>
	    Routing keys (and so binding patterns) used with topic exchanges are
	    dot.separated.strings.like.this.
	    </p>
	    <p>
	    Use "*" to match a single segment in the routing key: foo.*.zot will match foo.bar.zot, and
	    foo.quux.zot, but not foo.bar.quux.zot.
	    </p>
	    <p>
	    Use "#" to match zero or more segments in the routing key: foo.#.zot will match all three of
	    foo.bar.zot, foo.quux.zot, and foo.bar.quux.zot, as well as foo.zot.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="pattern-matching">
	  <doc:heading>I've declared a queue and then bound it to the exchange "x" on topic
	  "canada.politics". Other queues that bind on "canada.politics", publish messages
	  and it works great. If they bind to lets say "canada.sports" it also works as expected
	  in routing the messages. But if i publish to "canada.*" those clients in
	  canada.politics and canada.sports do not receive the messages. Is that expected, or
	  something wrong with the code?
	  </doc:heading>
	  <doc:a>
	    <p>
	    You've got the pattern matching around the wrong way. The routing key must be absolute
	    whilst the binding key can contain a wildcard. So "canada.*" is an opaque routing key. So to
	    fix this, use "canada.*" as the binding key instead of "canada.sports" or "canada.politics".
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="pattern-matching-with-separate-bindings">
	  <doc:heading>But what if I'm interested in "canada.politics" and "canada.sports", but not
	  "canada.entertainment"?</doc:heading>
	  <doc:a>
	    <p>
	    Then create a separate binding for each thing that you are interested in.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="declare-multiple-routing-keys-for-single-queue">
	  <doc:heading>Is it possible to declare multiple routing keys for a single queue in a direct
	  exchange?</doc:heading>
	  <doc:a>
	    <p>
	    Yes. See the previous FAQ.
	    </p>
	  </doc:a>
	</doc:faq>		

	<doc:faq name="direct-exchanges-sending-to-multiple-queues">
	  <doc:heading>What happens if a message is sent to a direct exchange which has duplicate routing
	  keys on more than one queue, is the message delivered to both queues?</doc:heading>
	  <doc:a>
	    <p>
	    Yes. In this scenario, the direct exchange becomes a little bit like a fanout exchange.
	    </p>
	  </doc:a>
	</doc:faq>		

	<doc:faq name="durable-queues-and-durable-exchanges">
	  <doc:heading>Why can durable queues only bind to durable exchanges?</doc:heading>
	  <doc:a>
	    <p>
	    This is just an artifact of the two tier model in AMQP. You either want to be 100% durable in
	    all tiers, or you don't.
	    </p>
	  </doc:a>
	</doc:faq>	
	
      </doc:section>
      
      <doc:section name="features">
	<doc:heading>RabbitMQ Features</doc:heading>

	<doc:faq name="feature-transactional">
	  <doc:heading>Is RabbitMQ transactional?</doc:heading>
	  <doc:a>
	    <p>
	      Yes. RabbitMQ implements AMQP's "TX" message class, which
	      provides atomicity and durability properties to those
	      clients that request them.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="feature-reliable">
	  <doc:heading>Is RabbitMQ reliable and highly-available?</doc:heading>
	  <doc:a>
	    <p>
	      Yes. RabbitMQ is built atop the industry-leading <a
	      href="#what-is-otp">OTP</a> Erlang libraries, which
	      provides a solid foundation for building reliable
	      software. The underlying system supporting the Rabbit
	      codebase has been used by Ericsson to achieve <i>nine
	      nines</i> (99.9999999%) of availability.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="feature-clustering-failover">
	  <doc:heading>Does RabbitMQ support clustering, and high-availability through live failover?</doc:heading>
	  <doc:a>
	    <p>
	      Yes. RabbitMQ brokers can be made up of an arbitrary
	      number of nodes, each of which is available for AMQP
	      clients to connect to and interact with. RabbitMQ's
	      routing tables are shared across the entire cluster, and
	      delivery of messages published at one node to a queue
	      residing at another node is seamless. For details see
	      the <a href="clustering.html">clustering guide</a>. We
	      are currently developing further support for live
	      failover of AMQP resources within a cluster.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="smp-support">
	  <doc:heading>Will RabbitMQ use SMP, when it's available?</doc:heading>
	  <doc:a>
	    <p>
	      Yes. Erlang supports both single-node SMP configurations
	      and configurations with multiple Erlang nodes running in
	      a cluster within a single host.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="support-store-and-forward">
	  <doc:heading>Does RabbitMQ support store-and-forward?</doc:heading>
	  <doc:a>
	    <p>
	      Yes, RabbitMQ, and AMQP in general, supports
	      store-and-forward-style exchanges and queues.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="SMSstore-forward">
	  <doc:heading>Do you think RabbitMQ, as a core module, could handle real time traffic of
something like an SMSC (SMS foreward&amp;store)?</doc:heading>
	  <doc:a>
	    <p>
Absolutely. Some large telcos currently deploy Erlang/OTP-based systems
    in their SMSC infrastructure. At present these systems are not based on
    AMQP/RabbitMQ, but there is no reason why they couldn't be.

	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="support-store-and-forward">
	   <doc:heading>Can I create RabbitMQ applications using web frameworks (eg
	    Spring, or Ruby-On-Rails)?
	  </doc:heading>
	  <doc:a>
	    <p>
	      Yes. To begin with, Spring has good support for message
	      access in Java: the RabbitMQ Java client is simply a
	      POJO library. The same is true for other POJO-based
	      systems, such as <a
	      href="http://mulesource.org">Mule</a>. If you
	      specifically wish to use JavaEE EJBs as message
	      accessors, use a stateful session bean.
	    </p>
	    <p>
	      For frameworks in other languages, such as Ruby or
	      in-browser Javascript, we plan on providing both RESTful
	      HTTP access to AMQP features as well as AJAX- and
	      web-services-style interfaces, allowing rapid
	      development of web applications that take advantage of
	      AMQP messaging.
	    </p>
	  </doc:a>
	</doc:faq>

      </doc:section>

      <doc:section name="architecture">
	<doc:heading>RabbitMQ Architecture</doc:heading>

	<doc:faq name="authentication-authorization">
	  <doc:heading>How is authentication and authorization supported in RabbitMQ?</doc:heading>
	  <doc:a>
	    <p>
	      AMQP uses <a
	      href="http://tools.ietf.org/html/rfc4422">SASL</a> (see
	      also <a
	      href="http://en.wikipedia.org/wiki/Simple_Authentication_and_Security_Layer">Wikipedia
	      on SASL</a>) for authentication of AMQP clients. Our
	      current support for SASL is limited to the PLAIN
	      authentication mechanism.
	    </p>
	    <p>
	      Authorization is implemented in RabbitMQ using a
	      distributed database table mapping users to virtual
	      hosts.
	    </p>
	    <p>
	      Message authentication, for instance using <a
	      href="http://en.wikipedia.org/wiki/Message_authentication_code">cryptographic
	      message authentication codes</a>, is not defined by the
	      AMQP specification, but as for encryption, could be very
	      easily implemented within the RabbitMQ client library.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="rabbit-platforms">
	  <doc:heading>What platforms will RabbitMQ run on?</doc:heading>
	  <doc:a>
	    <p>
	      RabbitMQ is developed on Debian Linux and Mac OS X. As
	      the server component is written in Erlang, and the
	      client component in Java, it is platform-neutral. Erlang
	      runs on the following platforms (taken from <a
	      href="http://www.erlang.org/faq/faq.html#AEN903">Erlang's
	      FAQ</a>):
	    </p>
	    <p>
	      <ul class="compact">
		<li>Solaris (including 64 bit)</li>
		<li>BSD</li>
		<li>Linux</li>
		<li>OSX</li>
		<li>TRU64</li>
		<li>Vista/Windows 7</li>
		<li>Windows NT/2000/2003/XP</li>
		<li>Windows 95, 98</li>
		<li>VxWorks</li>
	      </ul>
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="shared-session-clustering">
	  <doc:heading>What is shared session clustering?</doc:heading>
	  <doc:a>
	    <p>
	      For those familiar with typical tiered
	      session/application architectures such as JavaEE, it
	      might help to think of the AMQP exchanges as
	      corresponding to a logical session tier, and AMQP queues
	      as corresponding to a logical application tier. From
	      this point of view, RabbitMQ's routing tables can be seen
	      as clustered shared session state. RabbitMQ uses the OTP
	      distributed database, Mnesia, to reliably and
	      persistently replicate session state across all nodes in
	      a cluster.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="clustering-design">
	  <doc:heading>How does clustering work?</doc:heading>
	  <doc:a>
	    <p>
	      RabbitMQ's current clustering mechanisms are built around
	      Erlang's native support for reliable distributed
	      programming. This is a deeply sophisticated framework,
	      implemented at the language and virtual-machine level.
	    </p>
	    <p>
	      Some of the unique points about Erlang's networking and
	      distribution model are:
	      <ul>
		<li>
		  it scales to hundreds of thousands of parallel
		  processes ("green threads") within a single virtual
		  machine, bounded only by available memory;
		</li>
		<li>
		  the failure model for local inter-process
		  communication (IPC) is the same as that for
		  distributed IPC, making the transition from
		  non-distributed to distributed code very smooth;
		</li>
		<li>
		  binary pattern-matching constructs within the
		  language ensure straightforward and efficient
		  translation between wire-level encodings and
		  internal Erlang data structures;
		</li>
		<li>
		  finally, the OTP libraries shipped with the Erlang
		  distribution include the notion of a
		  supervisor/worker relationship, where supervisor
		  processes monitor and restart worker processes under
		  their control, making management of the entire
		  process hierarchy within a server deterministic and
		  automatic.
		</li>
	      </ul>
	    </p>
	    <p>
	      Within an Erlang node cluster, Erlang's native
	      high-speed messaging is used to provide an efficient way
	      of distributing work across the cluster. Individual AMQP
	      clients connect to machines within the cluster, and
	      Erlang's distributed routing database routes AMQP
	      messages to the appropriate endpoints.
	    </p>
	    <p>
	      For more detail on Erlang's benefits in an AMQP setting,
	      please see <a href="erlang.html">this page</a>.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="failover-ha">
	  <doc:heading>How does failover and HA work?</doc:heading>
	  <doc:a>
	    <p>
	      Currently, AMQP durable queues and their persistent
	      messages are recovered from disk at each server
	      restart. Exchange failover is handled by OTP's support
	      for clustering (see <a
	      href="#shared-session-clustering">above</a>).
	    </p>
	    <p>
	      Future releases will support live failover using, for
	      instance, a combination of the "known hosts" field in
	      <code>connection.open-ok</code> and the
	      <code>connection.redirect</code> message. Erlang's
	      built-in fault-tolerant database will ensure that
	      routing information is preserved, and the OTP supervisor
	      architecture in combination with AMQP's transactional
	      features will ensure that durable messages are not lost.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="addressing-in-amqp">
	  <doc:heading>How does addressing work in AMQP?</doc:heading>
	  <doc:a>
	    <p>
	      Like other messaging systems, AMQP and RabbitMQ provide
	      internal addressing mechanisms based on notions such as
	      routing keys, exchange addresses and queue
	      names.
	    </p>
	    <p>
	      These are managed on a per-virtual-host basis. Please
	      see the AMQP specification for details of the scoping of
	      the various names in the network. We are actively
	      investigating interoperation with other addressing
	      schemes and systems.
	    </p>
	  </doc:a>
	</doc:faq>
	
		<doc:faq name="scale-balance">
	  <doc:heading>How is RabbitMQ scaled and the load balance handled?</doc:heading>
	  <doc:a>
	    <p>
	     At the core we are relying on Erlang/OTP to distribute one logical AMQP
    broker across several physical nodes, with the necessary broker state
    being maintained in an instance of OTP's distributed database Mnesia.
    There are certain aspects of the AMQP spec that are currently undergoing
    revision that impact this area, so watch out for associated new features
    and documentation in future releases of RabbitMQ.

	    </p>
	  </doc:a>
	</doc:faq>
	
    <doc:faq name="server-api">
	<doc:heading>Is there an API doc of the RabbitMQ server?</doc:heading>
	<doc:a>
	  <p>
	  No, the Rabbit server API is not designed for public consumption, but the contract that Rabbit
	  obeys over time is AMQP.
	   </p>
	  <p>
	  We do, however, have API guides for
	  </p>
	  <ul>
	      <li>Java (<a href="api-guide.html">API guide proper</a> and 
	      <a href="&dir-current-javadoc;">javadoc</a>), and</li>
	      <li>.NET (<a href="releases/&dir-dotnet-client;/&nameVersion-dotnet-client;-user-guide.pdf">API guide proper (PDF)</a> and 
	      <a href="releases/&dir-dotnet-client;/&nameVersion-dotnet-client;-client-htmldoc/html/index.html">javadoc-like</a>)</li>
	  </ul>    
	  <p>
	  Also, please refer to the extensive server documentation which may contain the answer to
	  your question.
	  </p>
	</doc:a>
    </doc:faq>
	
      </doc:section>

      <doc:section name="integration">
	<doc:heading>Integration</doc:heading>

	<doc:faq name="rabbit-client-support">
	  <doc:heading>What clients does RabbitMQ support?</doc:heading>
	  <doc:a>
	    <p>
	      We maintain <a href="/how.html#clients">a list of clients</a>, which is fairly complete.  If you don't
see one you want, please <a href="http://lists.rabbitmq.com/cgi-bin/mailman/listinfo">email our mailing list.</a>
	    </p>
	  </doc:a>
	</doc:faq>
 
      </doc:section>

      <doc:section name="howto">
	<doc:heading>How-To</doc:heading>

	<doc:faq name="last-message-on-topic">
	  <doc:heading>How can I retrieve the last message published to a particular topic
</doc:heading>
	  <doc:q>
	    <p>
	      A classic use-case for messaging systems is the example
	      of subscribing to a topic of, say, 'market prices' for
	      an asset. By that a client very often means, "send me
	      the last published one and then subscribe me to any
	      update". Sometimes it is not necessary if the asset is
	      liquid (MSFT) but if it is illiquid, the client should
	      receive the last available message, as it's possible
	      there will be a long delay before the next update.
	    </p>
	    <p>
	      Does RabbitMQ support this?
	    </p>
	  </doc:q>
	  <doc:a>
	    <p>
	      This is not something AMQP provides out-of-the-box,
	      although one can imagine a solution involving a trivial
	      service (a simple hash table, in effect) answering
	      requests for most-recent-price served via AMQP. The
	      client would subscribe to the stream as usual, and in
	      parallel ask the service for the most recent price.
	    </p>
	    <p>
	      Such a service could be implemented either inside the
	      RabbitMQ broker, in Erlang, thus taking advantage of
	      Erlang's distribution and high-availability properties,
	      or it could be implemented outside the broker, as a
	      regular AMQP client.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="channel-encryption">
	  <doc:heading>Does RabbitMQ support channel encryption?</doc:heading>
	  <doc:q>
	    <p>
	      Say I want to transfer a message across the AMQP
	      network, without depending on the target being there,
	      and that the 'channel' between the message source client
	      and the message target client should be strongly
	      encrypted and authenticated. Is this something RabbitMQ
	      provides?
	    </p>
	  </doc:q>
	  <doc:a>
	    <p>
	      There are two kinds of encryption that could be
	      supported by an AMQP implementation.
	    </p>
	    <p>
	      The first is encryption of the AMQP stream. There's no
	      provision in the standard for that, but it is possible to
	      use <a href="ssl.html">SSL with RabbitMQ</a> 
	      as of Release 1.7.0.</p>
	    <p>
	      The second kind of encryption is encryption of
	      individual messages. AMQP is silent on this front as
	      well, but using a layer of encryption in the clients is
	      very easy. Adding support for this to RabbitMQ's client
	      library would be a simple matter.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="access_control">
	  <doc:heading>How do I configure access control?</doc:heading>
	  <doc:a>
	    <p>
	      Please see the section on <a
	      href="admin-guide.html#access-control">access
	      control</a> in the RabbitMQ <a
	      href="admin-guide.html">admin guide</a>.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="instrumentation-logging-debugging">
	  <doc:heading>Instrumentation, logging and debugging</doc:heading>
	  <doc:a>
	    <p>
	      RabbitMQ uses AMQP internally to the broker to notify
	      interested parties of significant events. Administration
	      and management exchanges are provided for tools to bind
	      to.
	    </p>
	    <p>
	      In addition, there is some discussion in the AMQP
	      community of the need for replay as a built-in feature.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="testing-rabbit">
	  <doc:heading>How do I test RabbitMQ?</doc:heading>
	  <doc:a>
	    <p>
	      You can test the RabbitMQ broker by:
	    </p>
	    <ul class="compact">
	      <li>
		connecting to our <a
		href="examples.html#demo-server">demo server</a>
		using one of the RabbitMQ <a
		href="examples.html">example programs</a>
	      </li>
	      <li>
		connecting to our demo server using another AMQP
		0-8 compatible client
	      </li>
	      <li>
		<a href="download.html">Downloading</a> the broker
		and experimenting with it on your own machine
	      </li>
	    </ul>
	  </doc:a>
	</doc:faq>

	<doc:faq name="public-test-server">
	  <doc:heading>Can I test my AMQP client against RabbitMQ?</doc:heading>
	  <doc:a>
	    <p>
	      Yes: you can either run your client against our <a
	      href="examples.html#demo-server">public demonstration
	      server</a>, or <a href="download.html">download</a> and
	      <a href="install.html">run</a> a server of your own to
	      experiment with.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="replication-scope">
	  <doc:heading>How do I tune the scope of replication? Will it affect performance?</doc:heading>
	  <doc:a>
	    <p>
	      Since replication is used mainly to propagate routing
	      table information between Erlang nodes within a cluster,
	      it has a low impact on performance to begin with; also,
	      it is trivial to arrange for a "queue-only" Erlang node
	      to join the cluster, only able to consume from queues,
	      which can then avoid being part of the routing-table
	      replication system.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="public-demonstration-broker">
	  <doc:heading>Is there a publicly available demonstration broker that I can use to experiment with
	  WAN AMQP connections?</doc:heading>
	  <doc:a>
	    <p>
	  Glad you asked – yes there is! <a href="http://www.lshift.net/">LShift</a> are hosting a demonstration RabbitMQ server that is freely
	  available for people to try out, perhaps for testing interoperation or experimenting with WAN
	  AMQP connections.
	    </p>
	    <p>
	  All supported RabbitMQ features are available on the server, including persistent storage.
	  While we intend to keep the server running for long stretches, we will be tracking RabbitMQ
	  development, so reserve the right to restart it, possibly erasing its database in the process
	  from time to time.
	    </p>
	    <p>
	  Here are the connection details:
	    </p>
	  <ul>	    
	  <li>Host: dev.rabbitmq.com</li>
	  <li>Port: 5672</li>
	  <li>Username: "guest"</li>
	  <li>Password: "guest"</li>
	  <li>Virtual Host: "/"</li>
	  </ul>	    
	    <p>
	  During debugging, you may wish to monitor the messages that are being sent through the
	  amq.rabbitmq.log topic exchange. One way of doing this is to make use of the 
	  <a href="http://hg.rabbitmq.com/rabbitmq-xmpp/raw-file/default/doc/index.html">XMPP IM
	  gateway</a> we run on dev.rabbitmq.com, by adding amq.rabbitmq.log@dev.rabbitmq.com to
	  your XMPP roster.
	    </p>
	  </doc:a>
	</doc:faq>
	
	<doc:faq name="migrate-to-another-machine">
	  <doc:heading>How do you migrate a instance of RabbitMQ to another machine?</doc:heading>
	  <doc:a>
	    <p>
	  Rabbit uses mnesia to replicate information about a broker (excluding messages), so you may
	  want to read the relevant sections about administration in the mnesia guide before doing
	  anything. Don't just copy the data directory and hope that mnesia will just magically recover
	  this, because it could well contain inode references. Also, taking Rabbit offline to do this may
	  be a good idea.
	    </p>
	    <p>
	  There is also the issue of persistent messages, which are not stored in mnesia. This needs to
	  handled separately.
	    </p>
	    <p>
	  And be aware that queue processes will not automatically be migrated.
	    </p>
	    <p>
	  And as always, if this is production data, then taking a backup is generally a prudent idea.
	    </p>
	    <p>
	  If you have done this already, then send a message to the list because I'd like to write more
	  about this question, but don't have any time.
	    </p>
	  </doc:a>
	</doc:faq>
	
	
	
     </doc:section>

      <doc:section name="configuration">
	<doc:heading>RabbitMQ Configuration</doc:heading>

	<doc:faq name="which-ports-to-open">
	  <doc:heading>When running rabbitmq behind a firewall, which ports do I need to open?</doc:heading>
	  <doc:a>
	    <p>
	 5672:tcp
	    </p>
	  </doc:a>
	</doc:faq>	

	<doc:faq name="listen-specific-port">
	  <doc:heading>How do you make Rabbit listen on a specific port or interface?</doc:heading>
	  <doc:a>
	    <p>
	    In the shell you can override the defaults specified in the rabbit.app file. For example, to get
	    Rabbit to listen at the address 10.66.23.117 on port 3876, you could start Rabbit in the
	    following way:
	    </p>
	    <p>
	    <code>
	    erl -mnesia dir DIR -boot start_sasl -rabbit tcp_listeners
	    '[{10.66.23.117, 3876}]' -s rabbit]
	    </code>
	    </p>
	  </doc:a>
	</doc:faq>	
	
     </doc:section>

      <doc:section name="performance">
	<doc:heading>Performance, Scalability &amp; Clustering</doc:heading>

	<doc:faq name="performance-latency">
	  <doc:heading>How low can latency be?</doc:heading>
	  <doc:a>
	    <p>
	      We have seen latencies averaging less than a
	      millisecond; for heavy, steady-state loads, latency
	      hovers around the 4-millisecond mark (including two
	      network hops).
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="performance-persistent">
	  <doc:heading>How fast is RabbitMQ in persistent mode?</doc:heading>
	  <doc:a>
	    <p>
	      From our testing, we expect easily-achievable
	      throughputs of 4000 persistent, non-transacted
	      one-kilobyte messages per second (Intel Pentium D,
	      2.8GHz, dual core, gigabit ethernet) from a single
	      RabbitMQ broker node writing to a single spindle.
	    </p>
	    <p>
	      Please let us know how RabbitMQ performs for you!
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="performance-options">
	  <doc:heading>How do I switch off persistence/transactionality?</doc:heading>
	  <doc:a>
	    <p>
	      To disable transactionality, use an AMQP channel which
	      is not in "TX" mode (ie. do not call
	      <code>tx.select</code>). To disable message persistence,
	      set the "delivery mode" field in the
	      <code>basic</code>-class properties for the message to
	      either absent or to one, as mode two enables
	      persistence.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="multiple-instances">
	  <doc:heading>How you do run multiple instances of RabbitMQ?</doc:heading>
	  <doc:a>
	    <p>
	      Have you read the <a href="clustering.html">clustering guide</a>?
	    </p>
	  </doc:a>
	</doc:faq>
	
	<doc:faq name="clustering-scalability">
	  <doc:heading>How does RabbitMQ's performance scale with clustering?</doc:heading>
	  <doc:a>
	    <p>
	      Based on typical OTP application scalability, we expect
	      close-to-linear scaling.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="if-RabbitMQ-instance-dies">
	  <doc:heading>What do I do if a RabbitMQ instance dies?</doc:heading>
	  <doc:a>
	    <p>
	    It depends how and why it died, of course. Please differentiate between a dead machine and a
	    partitioned network. One quick fix for a truly dead node may be to get a backup machine,
	    reinstall the OS and Rabbit and then just restart Rabbit with the contents of the old mnesia
	    data directory (if the disk is still ok, then you could just try slotting it in the new machine).
	    Make sure that the backup machine has the same name as the machine that died. If this
	    works, you are in luck. If not, i.e. mnesia does not seem to be recovering itself (it hangs will
	    the waiting_for_tables error message), then what you can try is to nuke the mnesia directory
	    and bring this node as part of the cluster and let it replicate itself from the other cluster
	    members. Note that this will not restart queue processes that were running on this node
	    before it crashed. But you can just re-declare the queues.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="does-clustering-replicate-messages-to-both-servers">
	  <doc:heading>Just to be sure on the clustering side of things, when I cluster RabbitMQ nodes they
	  messages gets replicated to both servers, right?
	  </doc:heading>
	  <doc:a>
	    <p>
	  Although we could do this, we don't, because it's too expensive. This would mean replicating
	  every message across the network in a synchronous fashion. And not too many people really
	  need it, in the event of a Rabbit node crashing, they just replay the log for that node.
	    </p>
	    <p>
	  BBHoss started a discussion about this on IRC (look for 
	  <a href="http://dev.rabbitmq.com/irclog/index.php?date=2008-08-27">the discussion about HA and DR
	  between BBHoss and hal</a>).
	    </p>
	    <p>
	  Having said that, this may be a use case for pluggable queues, for the avail-o-nados out there
	  :-)
	    </p>
	  </doc:a>
	</doc:faq>
	
	<doc:faq name="general-scalability">
	  <doc:heading>How many virtual hosts can I run and where?</doc:heading>
	  <doc:a>
	    <p>
	      There is no hard limit to the number of virtual hosts
	      that can be configured within a RabbitMQ cluster, save
	      available disk and memory resources.
	    </p>
	    <p>
	      Virtual hosts within AMQP are decoupled from the
	      physical network layout: one virtual host can be
	      accessed from multiple clustered brokers, just as many
	      virtual hosts can be accessed within a single
	      broker. Virtual hosts act solely as a namespacing
	      mechanism for AMQP resources.
	    </p>
	    <p>We want to get to the point where one can dynamically add and remove
nodes to/from a cluster that represents one logical AMQP broker, for
both reliability and scalability (to very high numbers of nodes).</p>

<p>This is an important area for us, and one of the reasons we chose
Erlang/OTP as the implementation platform for RabbitMQ. </p>
	  </doc:a>
	</doc:faq>
	
		<doc:faq name="how-many-concurrent-connections">
	  <doc:heading>How many concurrent connections can RabbitMQ support?</doc:heading>
	  <doc:a>
	    <p>You mean concurrent TCP connections? In theory as many as the operating
system will give you. If there are any niggles
they can be sorted out quite easily.</p>

<p>Also note that AMQP allows you to multiplex AMQP sessions across a
single TCP connection.</p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="maximum-throughput">
	  <doc:heading>What's the maximum bytes/second throughput of an instance?  Can scaling be used to get more bytes/second through the system?</doc:heading>
	  <doc:a>
	    <p>We are discussing testing, both functional and performance, within the
AMQP working group, with the idea of defining a shared set of AMQP
tests, and the code to implement them.</p>

<p>The problem is that there are many possible configurations of the test
infrastructure, the RabbitMQ broker, the clients, and the tests
themselves (e.g. AMQP supports many different forms of message
delivery). In order to obtain meaningful performance figures one would
have to specify exactly what the setup is, to the point where anybody
can replicate it. Even then one would get just one data point in an
infinite space of possible configurations, and it is generally
impossible to extrapolate the results from one test to other scenarios.</p>
	  </doc:a>
	</doc:faq>


	<doc:faq name="how-are-connections-secured">
	  <doc:heading>How are the connections secured?  HTTPS or something else?  What about certificate management?</doc:heading>
	  <doc:a>
	    <p>The standard only defines basic username/password authentication. There
are plans to extend that with SASL or some such mechanism.</p>

<p>It should be possible to add SSL/TLS quite trivially. Certificate
management would be done in a similar fashion to most other
SSL/TLS-enable apps.</p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="is-the-wire-protocol-pure-binary">
	  <doc:heading>Is the wire protocol pure binary or is there some XML mixed in?  Slap me and point me to the documentation if the answer is obvious.</doc:heading>
	  <doc:a>
	    <p>The protocol is pure binary.</p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="erlang-says-too-many-processes">
	  <doc:heading>What does it mean when Erlang says that there are too many processes?</doc:heading>
	  <doc:a>
	    <p>
The short answer is that you have too many Erlang processes (i.e. lightweight processes, not
Unix processes). The default system limit is 32767, so if you need more, start the Erlang VM
with the +P flag to set the maximum number of allowed processes.
RabbitMQ uses Erlang processes for each channel, for each connection, and for each queue
within the broker. If you are running into the system limit, you might be running a large
system, or you might be creating unnecessary resources.
	    
	    </p>
	  </doc:a>
	</doc:faq>
	
      </doc:section>

      <doc:section name="general">
	<doc:heading>General</doc:heading>

	<doc:faq name="rabbit-pricing">
	  <doc:heading>How is RabbitMQ priced?</doc:heading>
	  <doc:a>
	    <p>
	      RabbitMQ is free software in both the gratis and libre
	      senses, licensed under the <a href="mpl.html">Mozilla
	      Public License</a>.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="support-options">
	  <doc:heading>What support options are available for RabbitMQ?</doc:heading>
	  <doc:a>
	    <p>
	      RabbitMQ will be supported, both commercially and as an
	      open-source project, by both <a
	      href="http://www.lshift.net/">LShift</a> and by <a
	      href="http://www.cohesiveft.com/">CohesiveFT</a> as
	      virtual appliances. For inquiries about support, please
	      email <a
	      href="mailto:support@rabbitmq.com">support@rabbitmq.com</a>. For
	      inquiries specifically about virtual appliances, contact
	      <a
	      href="mailto:support@cohesiveft.com">support@cohesiveft.com</a>.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="rabbit-licensing">
	  <doc:heading>How is RabbitMQ licensed (for redistribution, etc.)?</doc:heading>
	  <doc:a>
	    <p>
	      RabbitMQ is distributed under the open-source <a
	      href="mpl.html">Mozilla Public License</a>.
	    </p>
	    <p>
	      If you would like to explore other licensing options,
	      please get in touch with us by emailing <a
	      href="mailto:info@rabbitmq.com">info@rabbitmq.com</a>.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="contribution">
	  <doc:heading>How do I contribute to the RabbitMQ project?</doc:heading>
	  <doc:a>
	    <p>
	      Welcome aboard! We love contributions - here are some
	      suggestions for what you can work on:
	    </p>
	    <p>
	      <ul class="compact">
		<li>packaging for other operating systems</li>
		<li>integration with other messaging systems</li>
		<li>integration with other management systems</li>
		<li>integration with other user and permission database systems</li>
		<li>improvements to the client, and work towards other clients</li>
		<li>new services for running with RabbitMQ, either within the broker or adjacent to it</li>
		<li>... and so on!</li>
	      </ul>
	    </p>
	    <p>
	      We're happy to hear from anyone who wants to get
	      involved or is curious about how we intend to manage the
	      project.
	    </p>
	  </doc:a>
	</doc:faq>

	<doc:faq name="version-numbering">
	  <doc:heading>How should I interpret RabbitMQ's version numbering?</doc:heading>
	  <doc:a>
	    <p>
	      RabbitMQ is versioned with the scheme
	      <code><i>major</i>.<i>minor</i>.<i>patch</i></code>.
	    </p>
            <ul>
              <li>
                <code>major</code>: This number indicates the major
                version of the software. It is only changed for
                significant alterations to the software, such as (for
                instance) a total rewrite.
              </li>
              <li>
                <code>minor</code>: A change in this number indicates
                new or significantly altered features.
              </li>
              <li>
                <code>patch</code>: This number changes to make each
                distinct packaging of the software uniquely
                numbered. Small changes such as bug-fixes or packaging
                alterations may cause a change in only the
                <code>patch</code> number.
              </li>
            </ul>
	  </doc:a>
	</doc:faq>

	<doc:faq name="rffaq">
	  <doc:heading>I have a question!</doc:heading>
	  <doc:a>
	    <p>
	      Please <a href="http://lists.rabbitmq.com">join our mailing list</a> or 
        send questions to <a
	      href="mailto:info@rabbitmq.com">info@rabbitmq.com</a>. We'd
	      love to hear from you.
	    </p>
	  </doc:a>
	</doc:faq>

      </doc:section>
    </doc:div>
  </body>
</html>
