<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                              xmlns="http://www.w3.org/1999/xhtml"
                              xmlns:x="http://www.rabbitmq.com/2011/extensions"
                              xmlns:c="http://www.rabbitmq.com/namespaces/ad-hoc/conformance"
                              exclude-result-prefixes="x c">

  <xsl:import href="page.xsl" />

  <xsl:output method="html" indent="yes"/>

  <xsl:variable name="spec-doc" select="document('resources/specs/amqp0-9-1.xml')"/>
  <xsl:variable name="specification" select="document('specification.xml')" />
  <xsl:key name="method-key" match="c:method" use="@name" />
  <xsl:variable name="decorations" select="document('')/xsl:stylesheet/x:decorations" />
  <xsl:variable name="class-decorations" select="$decorations/x:decorate[@target='class']"/>
  <xsl:variable name="method-decorations" select="$decorations/x:decorate[@target='method']"/>
  <xsl:variable name="javadoc-root">http://www.rabbitmq.com/releases/rabbitmq-java-client/current-javadoc/com/rabbitmq/client/impl/</xsl:variable>
  <xsl:variable name="dotnetdoc-root">http://www.rabbitmq.com/releases/rabbitmq-dotnet-client/v2.2.0/rabbitmq-dotnet-client-2.2.0-client-htmldoc/html/</xsl:variable>

  <xsl:key name="domain-key" match="domain" use="@name"/>

  <xsl:template match="x:insert-spec-here">
    <div id="container">
      <h2>AMQP 0-9-1 Quick Reference</h2>
      <!-- switch context from source file to spec doc -->
      <xsl:for-each select="$spec-doc/amqp">
            <xsl:comment>
          <xsl:value-of select="concat(' autogenerated from ', @comment)" />
        </xsl:comment>

        <div id="toc">
          <h3>ToC</h3>
          <xsl:call-template name="render-toc" />
        </div>
        <div id="content-pane">
          <xsl:apply-templates select="class[not(@name = 'connection')]">
            <xsl:sort select="@name" data-type="text" order="ascending" />
          </xsl:apply-templates>
        </div>
      </xsl:for-each>
      <xsl:if test="not($spec-doc/amqp)">
        <p/>
        <em>Oops! Failed to load amqp-0-9-1.xml source file</em>
      </xsl:if>
    </div>
  </xsl:template>

  <xsl:template name="render-toc">
    <ul>
      <xsl:apply-templates select="class[not(@name = 'connection')]" mode="toc">
        <xsl:sort select="@name" data-type="text" order="ascending"/>
      </xsl:apply-templates>
    </ul>
  </xsl:template>

  <xsl:template match="class" mode="toc">
    <li>
      <a href="{concat('#class.', @name)}">
        <xsl:value-of select="@name"/>
      </a>
      <ul class="plain">
        <xsl:apply-templates select="method[not(contains(@name, '-ok'))] | $class-decorations[@name = current()/@name]/method" mode="toc">
          <xsl:sort select="@name" data-type="text" order="ascending"/>
        </xsl:apply-templates>
      </ul>
    </li>
  </xsl:template>

  <xsl:template match="method" mode="toc">
    <li>
      <xsl:variable name="method-qname" select="concat(../@name, '.', @name)"/>
      <a href="{concat('#', $method-qname)}">
        <xsl:value-of select="$method-qname" />
      </a>
    </li>
  </xsl:template>

  <xsl:template match="class">
    <!-- note: connection class is omitted completely -->
    <!-- note: class fields (i.e. basic) omitted -->
    <!-- note: -ok methods (e.g. basic.get-ok) omitted for clarity -->
    <h3 id="{concat('class.', @name)}" class="class">
      <xsl:call-template name="capitalise">
        <xsl:with-param name="s" select="@name"/>
      </xsl:call-template>
    </h3>
    <xsl:apply-templates select="method[not(contains(@name, '-ok'))] | $class-decorations[@name = current()/@name]/method">
      <xsl:sort select="@name" data-type="text" order="ascending" />
    </xsl:apply-templates>
  </xsl:template>

  <xsl:template match="method">
    <div class="method-box">
      <xsl:variable name="qname" select="concat(../@name, '.', @name)" />
      <h4 class="method" id="{$qname}">
        <span title="{@label}">
          <span class="class-name">
            <xsl:value-of select="concat(../@name, '.')"/>
          </span>
          <span class="method-name">
            <xsl:value-of select="@name"/>
          </span>
        </span>
        <xsl:text>(</xsl:text>
        <xsl:apply-templates select="field" mode="render-method-sig"/>
        <xsl:text>)</xsl:text>
      </h4>
      <xsl:if test="parent::x:decorate">
        <h5 class="extension-method">THIS METHOD IS A RABBITMQ-SPECIFIC EXTENSION OF AMQP</h5>
      </xsl:if>
      <xsl:for-each select="$specification">
        <xsl:for-each select="key('method-key', $qname)">
          <p style="float: right; margin: 0"><em>Support: </em>
            <xsl:variable name="status" select="current()/c:status/@value"/>
            <a href="{concat('specification.html#method-status-', $qname)}">
              <xsl:choose>
                <xsl:when test="$status = 'ok'">full</xsl:when>
                <xsl:otherwise><xsl:value-of select="$status" /></xsl:otherwise>
              </xsl:choose>
            </a>
          </p>
        </xsl:for-each>
      </xsl:for-each>
      <p>
        <xsl:call-template name="capitalise">
          <xsl:with-param name="s" select="@label"/>
        </xsl:call-template>
      </p>
      <p>
        <xsl:value-of select="doc[1][not(@type)]"/>
      </p>
      <!-- apply method decorations -->
      <xsl:apply-templates select="x:* | $method-decorations[@name=$qname]"/>
      <xsl:if test="parent::class">
        <a href="{concat('amqp-0-9-1-reference.html#', $qname)}" class="amqp-doc">[amqpdoc]</a>
      </xsl:if>
      <xsl:call-template name="render-back-to-top"/>
    </div>
  </xsl:template>

  <xsl:template match="field" mode="render-method-sig">
    <span class="parameter">
      <xsl:if test="@domain">
        <a href="{concat('amqp-0-9-1-reference.html#domain.', @domain)}">
          <span class="data-type" title="{key('domain-key', @domain)/@type}">
            <xsl:value-of select="@domain"/>
          </span>
        </a>
        <xsl:text> </xsl:text>
      </xsl:if>
      <span class="param-name" title="{@label}">
        <xsl:value-of select="@name"/>
      </span>
    </span>
    <xsl:if test="position() != last()">
      <xsl:text>, </xsl:text>
    </xsl:if>
  </xsl:template>

  <xsl:template name="render-back-to-top">
    <a href="#top" class="back">(back to top)</a>
  </xsl:template>

  <xsl:template name="capitalise">
    <xsl:param name="s"/>
    <xsl:variable name="first" select="translate(substring($s, 1, 1), 'abcdefghijklmnopqrstuvwxyz', 'ABCDEFGHIJKLMNOPQRSTUVWXYZ')"/>
    <xsl:value-of select="concat($first, substring($s, 2))"/>
  </xsl:template>

  <!-- templates to process 'decorations' to the specification -->

  <xsl:template match="x:javadoc">
    <a href="{concat($javadoc-root, @href)}" class="javadoc">[javadoc]</a>
  </xsl:template>

  <xsl:template match="x:dotnetdoc">
    <a href="{concat($dotnetdoc-root, @href)}" class="dotnetdoc">[dotnetdoc]</a>
  </xsl:template>

  <xsl:template match="x:url">
    <a href="{@href}" class="doc">
      <xsl:value-of select="@label"/>
    </a>
  </xsl:template>

  <xsl:template match="x:doc">
    <div class="doc">
      <xsl:apply-templates/>
    </div>
  </xsl:template>

  <xsl:template match="x:doc/*[namespace-uri() = 'http://www.w3.org/1999/xhtml']">
    <xsl:element name="{local-name()}">
      <xsl:copy-of select="@*"/>
      <xsl:apply-templates />
    </xsl:element>
  </xsl:template>

  <x:decorations>
    <x:decorate target="class" name="exchange">
      <method xmlns="" name="bind" label="bind an exchange to an exchange">
        <field name="destination" domain="exchange-name" label="name of the exchange to bind to"/>
        <field name="source" domain="exchange-name" label="name of the exchange to bind from" />
        <field name="routing-key" domain="shortstr" label="message routing key"/>
        <field name="no-wait" domain="no-wait"/>
        <field name="arguments" domain="table" label="arguments for binding"/>
        <x:url href="http://www.rabbitmq.com/extensions.html#exchange-bindings" label="Documentation"/>
        <x:url href="http://www.rabbitmq.com/blog/2010/10/19/exchange-to-exchange-bindings/" label="RabbitMQ blog post"/>
        <x:javadoc href="AMQImpl.Exchange.Bind.html"/>
        <x:dotnetdoc href="type-RabbitMQ.Client.IModel.html#method-M:RabbitMQ.Client.IModel.ExchangeBind(System.String,System.String,System.String,System.Boolean,System.Collections.IDictionary)"/>
      </method>
    </x:decorate>
    <x:decorate target="class" name="exchange">
      <method xmlns="" name="unbind" label="unbind an exchange from an exchange">
        <field name="destination" domain="exchange-name" label="name of the exchange to bind to"/>
        <field name="source" domain="exchange-name" label="name of the exchange to bind from" />
        <field name="routing-key" domain="shortstr" label="message routing key"/>
        <field name="no-wait" domain="no-wait"/>
        <field name="arguments" domain="table" label="arguments for binding"/>
        <x:javadoc href="AMQImpl.Exchange.Unbind.html"/>
        <x:dotnetdoc href="type-RabbitMQ.Client.IModel.html#method-M:RabbitMQ.Client.IModel.ExchangeUnbind(System.String,System.String,System.String,System.Boolean,System.Collections.IDictionary)"/>
      </method>
    </x:decorate>
    <x:decorate target="method" name="basic.ack">
      <x:javadoc href="AMQImpl.Basic.Ack.html"/>
      <x:dotnetdoc href="type-RabbitMQ.Client.IModel.html#method-M:RabbitMQ.Client.IModel.BasicAck(System.UInt64,System.Boolean)"/>
    </x:decorate>
    <x:decorate target="method" name="basic.cancel">
      <x:javadoc href="AMQImpl.Basic.Cancel.html"/>
      <x:dotnetdoc href="type-RabbitMQ.Client.IModel.html#method-M:RabbitMQ.Client.IModel.BasicCancel(System.String)"/>
    </x:decorate>
    <x:decorate target="method" name="basic.consume">
      <x:javadoc href="AMQImpl.Basic.Consume.html" />
      <x:dotnetdoc href="type-RabbitMQ.Client.IModel.html#method-M:RabbitMQ.Client.IModel.BasicConsume(System.String,System.Collections.IDictionary,RabbitMQ.Client.IBasicConsumer)" />
    </x:decorate>
    <x:decorate target="method" name="basic.deliver">
      <x:javadoc href="AMQImpl.Basic.Deliver.html"/>
      <!-- x:dotnetdoc ***not impl*** -->
    </x:decorate>
    <x:decorate target="method" name="basic.get">
      <x:javadoc href="AMQImpl.Basic.Get.html"/>
      <x:dotnetdoc href="type-RabbitMQ.Client.IModel.html#method-M:RabbitMQ.Client.IModel.BasicGet(System.String,System.Boolean)"/>
    </x:decorate>
    <x:decorate target="method" name="basic.get-empty">
      <x:javadoc href="AMQImpl.Basic.GetEmpty.html"/>
      <!-- x:dotnetdoc ***not impl*** -->
    </x:decorate>
    <x:decorate target="method" name="basic.publish">
      <x:javadoc href="AMQImpl.Basic.Publish.html"/>
      <x:dotnetdoc href="type-RabbitMQ.Client.IModel.html#method-M:RabbitMQ.Client.IModel.BasicPublish(System.String,System.String,System.Boolean,System.Boolean,RabbitMQ.Client.IBasicProperties,System.Byte%5B%5D)"/>
    </x:decorate>
    <x:decorate target="method" name="basic.qos">
      <x:javadoc href="AMQImpl.Basic.Qos.html"/>
      <x:dotnetdoc href="type-RabbitMQ.Client.IModel.html#method-M:RabbitMQ.Client.IModel.BasicQos(System.UInt32,System.UInt16,System.Boolean)"/>
    </x:decorate>
    <x:decorate target="method" name="basic.recover">
      <x:javadoc href="AMQImpl.Basic.Recover.html"/>
      <x:dotnetdoc href="type-RabbitMQ.Client.IModel.html#method-M:RabbitMQ.Client.IModel.BasicRecover(System.Boolean)"/>
    </x:decorate>
    <x:decorate target="method" name="basic.recover-async">
      <x:javadoc href="AMQImpl.Basic.RecoverAsync.html"/>
      <x:dotnetdoc href="type-RabbitMQ.Client.IModel.html#method-M:RabbitMQ.Client.IModel.BasicRecoverAsync(System.Boolean)"/>
    </x:decorate>
    <x:decorate target="method" name="basic.reject">
      <x:url href="http://www.rabbitmq.com/blog/2010/08/03/well-ill-let-you-go-basicreject-in-rabbitmq/" label="RabbitMQ blog post"/>
      <x:javadoc href="AMQImpl.Basic.Reject.html"/>
      <x:dotnetdoc href="type-RabbitMQ.Client.IModel.html#method-M:RabbitMQ.Client.IModel.BasicReject(System.UInt64,System.Boolean)"/>
    </x:decorate>
    <x:decorate target="method" name="basic.return">
      <x:javadoc href="AMQImpl.Basic.Return.html"/>
      <!-- x:dotnetdoc ***not impl*** -->
    </x:decorate>
    <x:decorate target="method" name="channel.close">
      <x:javadoc href="AMQImpl.Channel.Close.html"/>
      <x:dotnetdoc href="type-RabbitMQ.Client.IModel.html#method-M:RabbitMQ.Client.IModel.Close(System.UInt16,System.String)"/>
    </x:decorate>
    <x:decorate target="method" name="channel.flow">
      <x:javadoc href="AMQImpl.Channel.Flow.html"/>
      <x:dotnetdoc href="type-RabbitMQ.Client.IModel.html#method-M:RabbitMQ.Client.IModel.ChannelFlow(System.Boolean)"/>
    </x:decorate>
    <x:decorate target="method" name="channel.open">
      <x:javadoc href="AMQImpl.Channel.Open.html"/>
      <!-- x:dotnetdoc ***not impl*** -->
    </x:decorate>
    <x:decorate target="method" name="exchange.declare">
      <x:doc>
        <p>
          RabbitMQ implements an extension to the AMQP specification that allows for unroutable messages
          to be delivered to an <em>Alternate Exchange</em> (AE). The AE feature helps to detect when clients
          are publishing messages that cannot be routed and can provide "or else" routing semantics where
          some messages are handled specifically and the remainder are processed by a generic handler.
        </p>
      </x:doc>
      <x:url href="http://www.rabbitmq.com/extensions.html#alternate-exchange" label="AE documention" />
      <x:javadoc href="AMQImpl.Exchange.Declare.html" />
      <x:dotnetdoc href="type-RabbitMQ.Client.IModel.html#method-M:RabbitMQ.Client.IModel.ExchangeDeclare(System.String,System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Collections.IDictionary)" />
    </x:decorate>
    <x:decorate target="method" name="exchange.delete">
      <x:javadoc href="AMQImpl.Exchange.Delete.html" />
      <x:dotnetdoc href="type-RabbitMQ.Client.IModel.html#method-M:RabbitMQ.Client.IModel.ExchangeDelete(System.String,System.Boolean,System.Boolean)" />
    </x:decorate>
    <x:decorate target="method" name="queue.bind">
      <x:javadoc href="AMQImpl.Queue.Bind.html" />
      <x:dotnetdoc href="type-RabbitMQ.Client.IModel.html#method-M:RabbitMQ.Client.IModel.QueueBind(System.String,System.String,System.String,System.Boolean,System.Collections.IDictionary)" />
    </x:decorate>
    <x:decorate target="method" name="queue.declare">
      <x:doc>
        <p>
          RabbitMQ implements extensions to the AMQP specification that permits the creator of
          a queue to control various aspects of its behaviour.
        </p>
        <h5>Per-Queue Message TTL</h5>
        <p>
          This extension determines for how long a message published to a queue can live before it is
          discarded by the server. The time-to-live is configured with the <em>x-message-ttl</em>
          argument to the arguments parameter of this method.
        </p>
        <h5>Queue Expiry</h5>
        <p>
          Queues can be declared with an optional lease time. The lease time determines how long a queue
          can remain unused before it is automatically deleted by the server. The lease time is provided
          as an <em>x-expires</em> argument in the the arguments parameter to this method.
        </p>
      </x:doc>
      <x:url href="http://www.rabbitmq.com/extensions.html#queue-ttl" label="x-message-ttl documentation"/>
      <x:url href="http://www.rabbitmq.com/extensions.html#queue-leases" label="x-expires documentation"/>
      <x:javadoc href="AMQImpl.Queue.Declare.html" />
      <x:dotnetdoc href="type-RabbitMQ.Client.IModel.html#method-M:RabbitMQ.Client.IModel.QueueDeclare(System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Collections.IDictionary)" />
    </x:decorate>
    <x:decorate target="method" name="queue.delete">
      <x:javadoc href="AMQImpl.Queue.Delete.html" />
      <x:dotnetdoc href="type-RabbitMQ.Client.IModel.html#method-M:RabbitMQ.Client.IModel.QueueDelete(System.String,System.Boolean,System.Boolean,System.Boolean)" />
    </x:decorate>
    <x:decorate target="method" name="queue.purge">
      <x:javadoc href="AMQImpl.Queue.Purge.html" />
      <x:dotnetdoc href="type-RabbitMQ.Client.IModel.html#method-M:RabbitMQ.Client.IModel.QueuePurge(System.String,System.Boolean)" />
    </x:decorate>
    <x:decorate target="method" name="queue.unbind">
      <x:javadoc href="AMQImpl.Queue.Unbind.html" />
      <x:dotnetdoc href="type-RabbitMQ.Client.IModel.html#method-M:RabbitMQ.Client.IModel.QueueUnbind(System.String,System.String,System.String,System.Collections.IDictionary)" />
    </x:decorate>
    <x:decorate target="method" name="tx.commit">
      <x:javadoc href="AMQImpl.Tx.Commit.html" />
      <x:dotnetdoc href="type-RabbitMQ.Client.IModel.html#method-M:RabbitMQ.Client.IModel.TxCommit" />
    </x:decorate>
    <x:decorate target="method" name="tx.rollback">
      <x:javadoc href="AMQImpl.Tx.Rollback.html" />
      <x:dotnetdoc href="type-RabbitMQ.Client.IModel.html#method-M:RabbitMQ.Client.IModel.TxRollback" />
    </x:decorate>
    <x:decorate target="method" name="tx.select">
      <x:javadoc href="AMQImpl.Tx.Select.html" />
      <x:dotnetdoc href="type-RabbitMQ.Client.IModel.html#method-M:RabbitMQ.Client.IModel.TxSelect" />
    </x:decorate>
  </x:decorations>

</xsl:stylesheet>
