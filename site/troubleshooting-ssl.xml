<?xml-stylesheet type="text/xml" href="page.xsl"?>
<!DOCTYPE html [
<!ENTITY % entities SYSTEM "rabbit.ent" >
%entities;
]>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:doc="http://www.rabbitmq.com/namespaces/ad-hoc/doc"
      xmlns:x="http://www.rabbitmq.com/2011/extensions">
  <head>
    <title>SSL Troubleshooting</title>
  </head>
  <body>
       <doc:subsection name="erlang-support">
       <doc:heading>SSL support in Erlang</doc:heading>
       <p>
         Confirm that your Erlang VM has support for SSL by running the
         <code>erl</code> (or <code>werl.exe</code> on Windows) shell and
         entering <pre class="sourcecode">ssl:versions().</pre>
         The output should look similar to this (with version number differences possible):
         <pre>[{ssl_app,"5.0"},
 {supported,[tlsv1,sslv3]},
 {available,[tlsv1,sslv3]}]</pre>
       </p>
       <p>
         If you receive an error instead, confirm that Erlang was built
         with OpenSSL. On Debian-based systems you may need to install the
         <code>erlang-ssl</code> package.
       </p>
       </doc:subsection>

       <doc:subsection name="keys-and-certs">
       <doc:heading>Verify keys and certificates with OpenSSL</doc:heading>
       <p>
         The certificates and keys specified in <code>rabbitmq.config</code> can be verified
         separately using OpenSSL <a href="http://www.openssl.org/docs/apps/s_client.html">s_client</a>
         and <a href="http://www.openssl.org/docs/apps/s_server.html">s_server</a>.
         For the examples that follow, we will assume you have the following:
       </p>
         <table>
          <tr>
           <td>Item</td>
           <td>Location</td>
          </tr>
          <tr>
           <td>CA certificate</td>
           <td><code>testca/cacert.pem</code></td>
          </tr>
          <tr>
           <td>Server certificate</td>
           <td><code>server/cert.pem</code></td>
          </tr>
          <tr>
           <td>Server key</td>
           <td><code>server/key.pem</code></td>
          </tr>
          <tr>
           <td>Client certificate</td>
           <td><code>client/cert.pem</code></td>
          </tr>
          <tr>
           <td>Client key</td>
           <td><code>client/key.pem</code></td>
          </tr>
         </table>
       <p>
         In one terminal window execute the following command:
         <pre class="sourcecode">openssl s_server -accept 8443 -cert server/cert.pem -key server/key.pem \
  -CAfile testca/cacert.pem</pre>
         In another terminal window execute
         <pre class="sourcecode">openssl s_client -connect localhost:8443 -cert client/cert.pem -key client/key.pem \
  -CAfile testca/cacert.pem</pre>
         If the certificates and keys have been correctly created, an SSL connection establishment
         sequence will appear and the terminals will be linked. Input from either terminal will appear
         on the other. If the trust chain could be established, the second terminal will display
         this confirmation: <pre>Verify return code: 0 (ok)</pre>
       </p>
       <p>
         If you receive an error, confirm that the certificates and keys were
         generated correctly.
       </p>
       </doc:subsection>

       <doc:subsection name="broker-listens">
       <doc:heading>Broker listening</doc:heading>
       <p>
         When you start the broker with a valid SSL configuration file, broker
         will report the SSL listening address in the logfile. You should see an entry
         similar to this:<pre>=INFO REPORT==== 8-Aug-2011::11:51:47 ===
started SSL Listener on 0.0.0.0:5671</pre>
         If you included an "ssl_listeners" configuration directive and you don't see
         this message, it is possible that your configuration file was not read by
         the broker. Confirm that the configuration file quoted in the broker startup
         banner contain SSL configuration options. See the
         <a href="/configure.html#introduction">configuration page</a> for details.
       </p>
       </doc:subsection>

       <doc:subsection name="broker-listens-ssl">
       <doc:heading>SSL connection to broker</doc:heading>
       <p>
         Once you have a RabbitMQ broker listening on an SSL port you can again use
         the OpenSSL s_client to verify SSL connection establishment, this time against the broker.
         The example assumes a broker with an "ssl_listeners" configuration directive set to listen for
         SSL connections on localhost port 5671:
         <pre class="sourcecode">openssl s_client -connect localhost:5671 -cert client/cert.pem -key client/key.pem \
  -CAfile testca/cacert.pem</pre>
         The output should appear similar to the case where port 8443 was used. The broker logfile
         should contain a new entry when the connection is established:
         <pre>=INFO REPORT==== 8-Aug-2011::11:55:13 ===
accepting AMQP connection &lt;0.223.0> (127.0.0.1:58954 -> 127.0.0.1:5671)</pre>
       </p>
       <p>
         It should now be possible to present the broker with an AMQP connection
         establishment sequence over the SSL connection. If you present the broker
         with eight random bytes, the broker will respond with the string "AMQP"
         followed by an encoded version number. If you recognise the "AMQP" string,
         you can be confident that you are connected to an AMQP broker.
       </p>
      </doc:subsection>

      <doc:subsection>
       <doc:heading>stunnel (client mode)</doc:heading>
       <p>
         Making use of an intermediary to provide SSL can help diagnosing SSL
         errors by producing more verbose logging. <a href="http://www.stunnel.org/">stunnel</a>
         is often used in this context, but any SSL-capable redirector (such as <a href="http://www.dest-unreach.org/socat/">socat</a>)
         can be used.
       </p>
       <p>
         stunnel can be used as in client-mode and then typically runs on the same host as the client.
         In this mode it can be used to help diagnose SSL errors in the broker. In the following example
         we see stunnel connecting to the AMQP-over-SSL (AMQPS) port 5671 of a remote broker and making
         an unencrypted AMQP port (5678) available to a local client.
         <pre  class="sourcecode">stunnel -c -r brokerhost:5671 -d 5678 -f -D 7</pre>
         Notice that stunnel is not providing any certificates. For this to succeed the broker must not
         require verification:
         <pre>    {ssl_options, [{verify, verify_none}, ...]}</pre>
       </p>
       <p>
         Verbose diagnostics are obtained by supplying the <code>-D</code> flag.
         Continuing with the example here, stunnel may log the following to the console as soon as a
         connection is established to port 5678:
         <pre>   Negotiated ciphers: AES256-SHA SSLv3 Kx=RSA Au=RSA Enc=AES(256) Mac=SHA1</pre>
       </p>
      </doc:subsection>

      <doc:subsection>
       <doc:heading>stunnel (daemon mode)</doc:heading>
       <p>
         stunnel can also be used in daemon (or server) mode, which is the default. In this case
         stunnel typically runs on the same host as the broker. In the discussion that follows it is
         assumed that stunnel will only be used temporarily. It is of course possible to use stunnel to
         provide SSL capability more permanently, but the lack of integration with the broker
         means that management reporting features and authentication plugins that use SSL
         information will not be able to do so.
       </p>
       <p>
         In this example, stunnel will connect to the unencrypted AMQP port of the broker and accept
         AMQPS connections from SSL-capable clients on port 5679:
         <pre  class="sourcecode">cat client/key.pem client/cert.pem > client/key-cert.pem
stunnel -r localhost:5672 -d 5679 -f -p client/key-cert.pem -D 7</pre>
         In this case stunnel requires a certificate. The generated client certificate should be used.
         stunnel requires that the key not require a password and precede the certificate, as shown
         above with the <code>cat</code> command.
       </p>
       <p>
         SSL-capable clients should now be able to connect to port 5679 and any SSL errors will appear
         on the console where stunnel was started.
       </p>
      </doc:subsection>

      <doc:subsection>
       <doc:heading>ssldump</doc:heading>
       <p>
        While not available on as many platforms as stunnel, <a href="http://www.rtfm.com/ssldump/">ssldump</a>
        can be a valuable source of information where availability and permissions allow. It works in a similar
        way to <a href="http://www.tcpdump.org/">tcpdump</a>, but includes support for inspecting SSL handshaking.
        The following commandline can be used together with the previous example to inspect SSL connection
        establishment:
        <pre  class="sourcecode">$ ssldump -i lo port 5679  -k client/key.pem</pre>
        When an SSL-capable client connects on port 5679 this will display information about cipher and compression
        method advertisements from the server side and selections made by the client.
       </p>

      <doc:subsection>
       <doc:heading>Log diagnostics</doc:heading>
        <dl>
            <dt>
               The broker log has entries that contain <code>{ssl_upgrade_error, ekeyfile}</code>
               (or <code>{ssl_upgrade_error, ecertfile}</code>)
            </dt>
            <dd>
               <p>
                 This means the broker keyfile (or certificate file) is invalid.
                 Confirm that the keyfile matches the certificate and that both are in PEM format.
                 PEM format is a printable encoding with recognisable delimiters. The certificate
                 will start and end with <code>-----BEGIN CERTIFICATE-----</code> and
                 <code>-----END CERTIFICATE-----</code> respectively. The keyfile will likewise
                 start and end with <code>-----BEGIN RSA PRIVATE KEY-----</code> and
                 <code>-----END RSA PRIVATE KEY-----</code> respectively.
               </p>
            </dd>
            <dt>The broker log has entries that contain <code>{ssl_upgrade_failure, ... certify ...}</code></dt>
            <dd>
               <p>
                 This error is related to client verification. The client is presenting an invalid
                 certificate or no certificate. If the ssl_options has the <code>verify</code> option
                 set to <code>verify_peer</code> then try using the value <code>verify_none</code>
                 temporarily. Ensure that the client certificate has been generated correctly, and that
                 the client is presenting the correct certificate.
               </p>
            </dd>
            <dt>The broker log has entries that contain <code>{ssl_upgrade_error, ...}</code></dt>
            <dd>
               <p>
                 This is a generic error that could have many causes. Make sure you are
                 using the recommended version of Erlang.
               </p>
            </dd>
        </dl>
      </doc:subsection>

  </body>
</html>
