<?xml-stylesheet type="text/xml" href="page.xsl"?>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:doc="http://www.rabbitmq.com/namespaces/ad-hoc/doc"
      xmlns:x="http://www.rabbitmq.com/2011/extensions">
  <head>
    <title>Flow Control</title>
  </head>
  <body>
    <!--
       To avoid terminology soup:
       - "memory threshold" always refers to the configured fraction
       - "memory limit" always refers to the computed absolute limit
    -->
    <p>
      There are two flow control mechanisms in RabbitMQ. Both work by
      exerting TCP backpressure on connections that are publishing too
      fast. They are:
    </p>
    <ul>
      <li>
        A per-connection mechanism that prevents messages being
        published faster than they can be routed to queues.
      </li>
      <li>
        A global mechanism that prevents any messages from being
        published when the memory usage exceeds a configured
        threshold or free disk space drops below a configured
        threshold.
      </li>
    </ul>

    <p>
      Both mechanisms will temporarily <em>block</em> connections -
      the server will pause reading from the sockets of connected
      clients which send content-bearing methods (such
      as <code>basic.publish</code>) which have been
      blocked. Connection heartbeat monitoring will be disabled too.
    </p>

    <p>
      The intent here is to introduce a flow control mechanism
      that throttles producers but lets consumers continue
      unaffected. However, since AMQP permits producers and
      consumers to operate on the same channel, and on different
      channels of a single connection, this logic is necessarily
      imperfect. In practice that does not pose any problems for
      most applications since the throttling is observable merely
      as a delay. Nevertheless, other design considerations
      permitting, it is advisable to only use individual AMQP
      connections for either producing or consuming.
    </p>

    <doc:section name="per-connection">
      <doc:heading>Per-Connection Flow Control</doc:heading>
      <p>
        RabbitMQ will block connections which are publishing too
        quickly for queues to keep up. No configuration is required.
      </p>
      <p>
        A blocked connection will show a <code>state</code>
        of <code>blocked</code> in <code>rabbitmqctl</code> and the
        management plugin. Typically such fast-publishing connections
        will be blocked and unblocked several times per second, so
        inspecting a connection's <code>state</code> may not show
        per-connection flow control happening
        clearly. The <code>last_blocked_by</code>
        and <code>last_blocked_age</code> fields
        in <code>rabbitmqctl</code> and the management plugin can be
        inspected to determine whether flow control is taking
        place. The management plugin web UI unifies this information
        into a single field.
      </p>
    </doc:section>

    <doc:section name="memsup">
      <doc:heading>Memory-Based Flow Control</doc:heading>
      <p>
        The RabbitMQ server detects the total amount of
        RAM installed in the computer on startup and when
        <code>rabbitmqctl
        set_vm_memory_high_watermark <em>fraction</em></code> is
        executed. By default, when the RabbitMQ server uses above 40%
        of the installed RAM, it raises a memory alarm and blocks all
        connections. Once the memory alarm has cleared (e.g. due
        to the server paging messages to disk or delivering them to
        clients) normal service resumes.
      </p>

      <p>
        The default memory threshold is set to 40% of installed
        RAM. Note that this does not prevent the RabbitMQ server
        from using more than 40%, it is merely the point at which
        publishers are throttled. Erlang's garbage collector can, in
        the worst case, cause double the amount of memory to be used
        (by default, 80% of RAM). It is strongly recommended that OS
        swap or page files are enabled.
      </p>

      <p>
        32-bit architectures impose a per process memory limit of
        4GB, though under Windows, this is frequently further
        reduced to 2GB. Common implementations of 64-bit
        architectures (i.e. AMD64 and Intel EM64T) permit only a
        paltry 256TB per process. 64-bit Windows again further
        limits this to 8TB. However, note that even under 64-bit
        Windows, a 32-bit process frequently only has a maximum
        address space of 2GB.
      </p>
      <doc:subsection name="memsup-usage">
        <doc:heading>Configuring the Memory Threshold</doc:heading>

        <p>
          The memory threshold at which the flow control is
          triggered can be adjusted by editing the <code>rabbitmq.config</code>
          file (in the appropriate location for your platform, as discussed in the
          <a href="configure.html#configuration-file">configuration guide</a>).
          The example below sets the threshold to the
          default value of 0.4:
          <pre class="sourcecode">[{rabbit, [{vm_memory_high_watermark, 0.4}]}].</pre>
        </p>

        <p>
          The default value of 0.4 stands for 40% of installed RAM
          or 40% of available virtual address space, whichever is
          smaller. E.g. on a 32-bit Windows platform, if you have
          4GB of RAM installed, 40% of 4GB is 1.6GB, but 32-bit
          Windows normally limits processes to 2GB, so the threshold
          is actually to 40% of 2GB (which is 820MB).
        </p>

        <p>
          A value of <code>0</code> makes the memory alarm go off
          immediately and thus disables all publishing (this may be
          useful if you wish to disable publishing globally;
          use <code>rabbitmqctl set_vm_memory_high_watermark
            0</code>). To prevent the memory alarm from going off at all,
          set some high multiplier such as
          <code>100</code>.
        </p>

        <p>
          The memory limit is appended to the
          <b>RABBITMQ_NODENAME</b>.log file when the RabbitMQ server
          starts:
          <pre class="sourcecode">
=INFO REPORT==== 29-Oct-2009::15:43:27 ===
Memory limit set to 2048MB.</pre>
          The memory limit may also be queried using the
          <code>rabbitmqctl status</code> command.
        </p>

        <p>
          The threshhold can be changed while the broker is running
          using the <code>rabbitmqctl set_vm_memory_high_watermark
            <em>fraction</em></code> command. This command will take effect
          until the broker shuts down. The corresponding configuration
          setting should also be changed when the effects should survive
          a broker restart. The memory limit may change on systems with
          hot-swappable RAM when this command is executed without altering
          the threshhold, due to the fact that the total amount of system
          RAM is queried.
        </p>

        <p>
          Versions of Erlang prior to R13B had a bug that meant they
          do not reliably detect the amount of memory installed on
          Windows platforms. If RabbitMQ is running under Windows on
          a version of Erlang prior to R13B, then it does not
          attempt to automatically set a threshold. Instead, it
          behaves as if it's unable to recognise the platform: see
          below.
        </p>
      </doc:subsection>

      <doc:subsection name="memsup-unrecognised-platforms">
        <doc:heading>Unrecognised platforms</doc:heading>
        <p>
          If the RabbitMQ server is unable to recognise your system,
          or if you're using Windows and a version of Erlang prior
          to R13B, it will append a warning to the
          <b>RABBITMQ_NODENAME</b>.log file. It then assumes than
          1GB of RAM is installed:
          <pre class="sourcecode">
=WARNING REPORT==== 29-Oct-2009::17:23:44 ===
Unknown total memory size for your OS {unix,magic_homebrew_os}. Assuming memory size is 1024MB.</pre>
        </p>

        <p>
          In this case, the <code>vm_memory_high_watermark</code>
          configuration value is used to scale the assumed 1GB
          RAM. With the default value of
          <code>vm_memory_high_watermark</code> set to 0.4,
          RabbitMQ's memory threshold is set to 410MB, thus it will
          throttle producers whenever RabbitMQ is using more than
          410MB memory. Thus when RabbitMQ can't recognize your
          platform, if you actually have 8GB RAM installed and you
          want RabbitMQ to throttle producers when the server is using
          above 3GB, set <code>vm_memory_high_watermark</code> to 3.
        </p>

        <p>
          It is advised you do not set the threshold above 50% of your
          installed RAM, and to note that under Windows with a 32-bit
          Erlang VM, it is commonly the case that a maximum of 2GB
          memory is available to RabbitMQ.
        </p>
      </doc:subsection>
    </doc:section>
    <doc:section name="diskfreesup">
      <doc:heading>Disk-Based Flow Control</doc:heading>
      <p>
        Global flow control will be triggered if the amount of free disk
        space drops below a configured limit. The free space of the drive or
        partition that the broker database uses will be monitored every
        minute to determine whether the alarm should be raised or cleared.
        Monitoring will start as soon as the broker starts up, causing an entry
        in the broker logfile:
        <pre class="sourcecode">
=INFO REPORT==== 23-Mar-2012::14:52:41 ===
Disk free limit set to 21665MB</pre>
        Monitoring will be disabled on unrecognised platforms, causing an
        entry such as the one below:
        <pre class="sourcecode">
=WARNING REPORT==== 23-Mar-2012::15:45:29 ===
Disabling disk free space monitoring</pre>
      </p>

    <doc:subsection name="memsup-usage">
      <doc:heading>Configuring the Disk Free Space Limit</doc:heading>

      <p>
        The disk free space limit is configured with the <code>disk_free_limit</code>
        setting. By default 1.8 times the amount of total RAM is required
        to be free on the Mnesia partition. The example below sets the limit to
        the default value:
        <pre class="sourcecode">[{rabbit, [{disk_free_limit, {mem_relative, 1.8}}]}].</pre>
        A number of bytes may also be configured. This configuration file
        sets the disk free space limit to 25Gb:
        <pre class="sourcecode">[{rabbit, [{disk_free_limit, 26843545600}]}].</pre>
       </p>
    </doc:subsection>
    </doc:section>

  </body>
</html>
