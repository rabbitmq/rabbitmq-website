<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xml" href="page.xsl"?>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:doc="http://www.rabbitmq.com/namespaces/ad-hoc/doc"
      xmlns:x="http://www.rabbitmq.com/2011/extensions">
  <head>
    <title>Time-To-Live Extensions</title>
  </head>
  <body show-in-this-page="true">
    <p class="intro">
      RabbitMQ allows you to set Time To Live for both messages and queues.
    </p>
    <doc:section name="per-queue-message-ttl">
      <doc:heading>Per-Queue Message TTL</doc:heading>
      <p>
        The <code>x-message-ttl</code> argument to
        <code>queue.declare</code> controls for how long a message
        published to a queue can live before it is discarded. A
        message that has been in the queue for longer than the
        configured TTL is said to be <em>dead</em>. Note that a
        message routed to multiple queues can die at different
        times, or not at all, in each queue in which it resides. The
        death of a message in one queue has no impact on the life of
        the same message in other queues.
      </p>

      <p>
        The server guarantees that dead messages will not be included
        in any <code>basic.get-ok</code> or <code>basic.deliver</code>
        methods. Further, the server will try to reap messages at or
        shortly after their TTL-based expiry.
      </p>

      <p>
        The value of the <code>x-message-ttl</code> argument must be
        a non-negative integer, describing the TTL period in
        milliseconds. Thus a value of 1000 means that a message
        added to the queue will live in the queue for 1 second or
        until it is delivered to a consumer. The argument can be of
        AMQP type short-short-int, short-int, long-int, or
        long-long-int.
      </p>

      <p>
        This example in Java creates a queue in which messages may
        reside for at most 60 seconds:
      </p>
      <pre class="sourcecode">
Map&lt;String, Object&gt; args = new HashMap&lt;String, Object&gt;();
args.put("x-message-ttl", 60000);
channel.queueDeclare("myqueue", false, false, false, args);</pre>
      <p>
        The original expiry time of a message is preserved if it
        is requeued (for example due to the use of an AMQP method
        that features a requeue parameter, or due to a channel
        closure).
      </p>

      <p>
        Setting <code>x-message-ttl</code> to 0 causes messages to
        be expired upon reaching a queue unless they can be
        delivered to a consumer immediately. Thus this provides an
        alternative to <code>basic.publish</code>'s
        <code>immediate</code> flag. Unlike the latter, no
        <code>basic.return</code>s are issued, and if a dead
        letter exchange is set then messages will be
        dead-lettered. Performance is significantly better.
      </p>

    </doc:section>
    <doc:section name="per-message-ttl">
      <doc:heading>Per-Message TTL</doc:heading>
      <p>
        The TTL for a message can also be specified on a per-message basis. To
        specify a per-message TTL the <code>expiration</code> field in the
        <code>basic</code> AMQP class mus be set when sending a
        <code>basic.publish</code>. The same constraints as the per-message TTL
        apply. Since the <code>expiration</code> field must be a string, the
        broker will accept the string representation of the number, and reject
        the publish for invalid values of malformed strings. The
        <code>expiration</code> field will be ignored when used in anything but
        <code>basic.publish</code>. When both a per-queue TTL and a per-message
        TTL are specified, the lower value between the two will be chosen.
      </p>

      <p>
        This example in Java publishes a message which can reside in the queue
        for at most 60 seconds:
      </p>
      <pre class="sourcecode">
byte[] messageBodyBytes = "Hello, world!".getBytes();
AMQP.BasicProperties properties = new AMQP.BasicProperties();
properties.setExpiration("60000");
channel.basicPublish("my-exchange", "routing-key", properties, messageBodyBytes);</pre>

      <doc:subsection name="per-message-ttl-caveats">
        <doc:heading>Caveats</doc:heading>
        <p>
          While consumers will never see expired messages, only the expired
          messages at the head of the queue will actually be discarded.  When
          using a per-queue TTL this is not a problem, since expired messages
          will always be at the head of the queue. However, when using a
          per-message TTL, expired messages can queue up behind non-expired
          messages until the non-expired messages are consumed or expired. This
          means that resources used by the expired messages will not be freed,
          and they will be counted in queue statistics (e.g. the number of
          messages in the queue).
        </p>
      </doc:subsection>
    </doc:section>
    <doc:section name="queue-ttl">
      <doc:heading>Queue TTL</doc:heading>

      <p>
        The <code>x-expires</code> argument to
        <code>queue.declare</code> controls for how long a queue can
        be unused before it is automatically
        deleted. <em>Unused</em> means the queue has no consumers,
        the queue has not been redeclared, and <code>basic.get</code>
        has not been invoked for a duration of
        at least the expiration period. This can be used, for
        example, for RPC-style reply queues, where many queues can
        be created which may never be drained.
      </p>

      <p>
        The server guarantees that the queue will be deleted, if
        unused for at least the expiration period. No guarantee is
        given as to how promptly the queue will be removed after the
        expiration period has elapsed. Leases of durable queues
        restart when the server restarts.
      </p>

      <p>
        The value of the <code>x-expires</code> argument must be an
        integer, greater than zero, describing the expiration period
        in milliseconds. Thus a value of 1000 means a queue which is
        unused for 1 second will be deleted. The argument can be of
        AMQP type short-short-int, short-int, long-int, or
        long-long-int.
      </p>

      <p>
        This example in Java creates a queue which expires after
        it has been unused for 30 minutes.
      </p>
      <pre class="sourcecode">
Map&lt;String, Object&gt; args = new HashMap&lt;String, Object&gt;();
args.put("x-expires", 1800000);
channel.queueDeclare("myqueue", false, false, false, args);</pre>
    </doc:section>
  </body>
</html>
