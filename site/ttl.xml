<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xml" href="page.xsl"?>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:doc="http://www.rabbitmq.com/namespaces/ad-hoc/doc"
      xmlns:x="http://www.rabbitmq.com/2011/extensions">
  <head>
    <title>Time-To-Live Extensions</title>
  </head>
  <body show-in-this-page="true">
    <p class="intro">
      RabbitMQ allows you to set Time To Live for both messages and queues.
    </p>
    <doc:section name="message-ttl">
      <doc:heading>Message TTL</doc:heading>
      <p>
        The TTL of a message determines how long the message will live
        in a queue before it is discarded. Note that a message routed to
        multiple queues can die at different times, or not at all, in each queue
        in which it resides. The death of a message in one queue has no impact
        on the life of the same message in other queues. The TTL can be set for
        a single message or for all the queue messages.
      </p>

      <p>
        The server guarantees that dead messages will not be included
        in any <code>basic.get-ok</code> or <code>basic.deliver</code>
        methods. Further, the server will try to reap messages at or
        shortly after their TTL-based expiry.
      </p>

      <p>
        To specify a per-message TTL the <code>expiration</code> field in the
        <code>basic</code> AMQP class, when sending a
        <code>basic.publish</code>.  The TTL value must be a non-negative 32 bit
        integer (0 &lt;= n &lt;= 2^32-1), describing the TTL period in
        milliseconds. Thus a value of 1000 means that a message added to the
        queue will live in the queue for 1 second or until it is delivered to a
        consumer. Since the <code>expiration</code> field must be a string, the
        broker will accept the string representation of the number, and reject
        the publish for invalid values of malformed strings.
      </p>

      <p>
        This example in Java publishes a message which can reside in the queue
        for at most 60 seconds:
      </p>
      <pre class="sourcecode">
byte[] messageBodyBytes = "Hello, world!".getBytes();
AMQP.BasicProperties properties = new AMQP.BasicProperties();
properties.setExpiration("60000");
channel.basicPublish("my-exchange", "routing-key", properties, messageBodyBytes);</pre>

      <p>
        The <code>x-message-ttl</code> argument to <code>queue.declare</code>
        can be used to set a per-queue TTL. The argument can be of AMQP type
        short-short-int, short-int, long-int, or long-long-int. The same
        constraints as the per-message TTL apply.  Please note that per-message
        TTL always has priority on the per-queue settings.
      </p>

      <p>
        This example in Java creates a queue in which messages may
        reside for at most 60 seconds:
      </p>
      <pre class="sourcecode">
Map&lt;String, Object&gt; args = new HashMap&lt;String, Object&gt;();
args.put("x-message-ttl", 60000);
channel.queueDeclare("myqueue", false, false, false, args);</pre>

      <p>
        The original expiry time of a message is preserved if it
        is requeued (for example due to the use of an AMQP method
        that features a requeue parameter, or due to a channel
        closure).
      </p>

      <p>
        Setting TTL to 0 causes messages to
        be expired upon reaching a queue unless they can be
        delivered to a consumer immediately. Thus this provides an
        alternative to <code>basic.publish</code>'s
        <code>immediate</code> flag. Unlike the latter, no
        <code>basic.return</code>s are issued, and if a dead
        letter exchange is set then messages will be
        dead-lettered. Performance is significantly better.
      </p>

    </doc:section>
    <doc:section name="queue-ttl">
      <doc:heading>Queue TTL</doc:heading>

      <p>
        The <code>x-expires</code> argument to
        <code>queue.declare</code> controls for how long a queue can
        be unused before it is automatically
        deleted. <em>Unused</em> means the queue has no consumers,
        the queue has not been redeclared, and <code>basic.get</code>
        has not been invoked for a duration of
        at least the expiration period. This can be used, for
        example, for RPC-style reply queues, where many queues can
        be created which may never be drained.
      </p>

      <p>
        The server guarantees that the queue will be deleted, if
        unused for at least the expiration period. No guarantee is
        given as to how promptly the queue will be removed after the
        expiration period has elapsed. Leases of durable queues
        restart when the server restarts.
      </p>

      <p>
        The value of the <code>x-expires</code> argument must be a 32
        bit integer greater than zero (0 &lt; n &lt;= 2^32-1),
        describing the expiration period in milliseconds. Thus a value
        of 1000 means a queue which is unused for 1 second will be
        deleted. The argument can be of AMQP type short-short-int,
        short-int, long-int, or long-long-int.
      </p>

      <p>
        This example in Java creates a queue which expires after
        it has been unused for 30 minutes.
      </p>
      <pre class="sourcecode">
Map&lt;String, Object&gt; args = new HashMap&lt;String, Object&gt;();
args.put("x-expires", 1800000);
channel.queueDeclare("myqueue", false, false, false, args);</pre>
    </doc:section>
  </body>
</html>
