<?xml-stylesheet type="text/xml" href="page.xsl"?>
<html xmlns:doc="http://www.rabbitmq.com/namespaces/ad-hoc/doc">
  <head>
    <title>RabbitMQ - Administration Guide</title>
  </head>
  <body>
    <doc:div>
      <p class="intro">
        This is the RabbitMQ Server Administrator's Guide. <i>(Note: it
        is still under development. Please contact us if you have any
        suggestions or wished-for features!)</i>
      </p>
      <p>See also this <a href="/how.html#management">list of new community tools</a> have appeared for 'dashboard' access to core management functionality.</p>

      <doc:toc class="compact">
        <doc:heading>Table of Contents</doc:heading>
      </doc:toc>

      <doc:section name="installation">
        <doc:heading>Building and installation</doc:heading>
        <p>
          Please see the <a href="build-server.html">build</a> and <a
          href="install.html">installation</a> guides for instructions
          on compiling, installing, starting and shutting down the
          server. See the <a href="service-guide.html">service</a> 
          guide for instructions on running the server as a Windows
          Service.
        </p>
      </doc:section>

      <doc:section name="default-state">
        <doc:heading>Default database contents</doc:heading>

        <p>
          When the server first starts running, and detects that its
          database is uninitialised or has been deleted, it
          initialises a fresh database with the following resources:
        </p>

        <ul class="compact">
          <li>
            a virtual host named <code>/</code>
          </li>
          <li>
            a user named <code>guest</code> with a default password of
            <code>guest</code>, granted full access to the
            <code>/</code> virtual host.
          </li>
        </ul>

        <p>
          It is advisable to <a href="#change_password">change the
          password</a> of the <code>guest</code> user to something
          private, particularly if your broker is accessible publicly.
        </p>
      </doc:section>

      <doc:section name="management-overview">
        <doc:heading>Management overview</doc:heading>
        <p>
          <code>rabbitmqctl</code> is a command line tool for managing
          a RabbitMQ broker. It performs all actions by connecting to
          one of the broker's node. By default that is the node named
          "rabbit" on the local host. This can be overridden by
          explicitly specifying the node name before the command using
          the "-n" flag, e.g.
        </p>
        <pre>rabbitmqctl -n rabbit@shortstop add_user tonyg changeit</pre>
        <p>
          This command instructs the RabbitMQ broker at the Erlang
          node rabbit@shortstop to create a user named tonyg with
          (initial) password changeit.
        </p>
        <p>
          On a host named "server.example.com", the node name of the
          RabbitMQ Erlang node will usually be
          <code>rabbit@server</code> (unless <b>RABBITMQ_NODENAME</b>
          has been set to some non-default value at broker startup
          time). The output of <code>hostname -s</code> is usually the
          correct suffix to use after the "@" sign.
        </p>
        <p>
          <code>rabbitmqctl</code> produces verbose output by default. 
          Quiet mode can be selected by specifying the "-q" flag, e.g.
        </p>
        <pre>rabbitmqctl -q status</pre>
        <p>
          This option enables quiet mode and is useful when post-processing
          the results. Informational messages are suppressed when quiet mode
          is in effect.
        </p>
        <p>
          Flags must precede all other parameters to <code>rabbitmqctl</code>. 
        </p>
      </doc:section>

      <doc:section name="app-management">
        <doc:heading>Application and cluster management</doc:heading>

        <doc:subsection name="stop">
          <doc:heading>Stopping the RabbitMQ node</doc:heading>
          <pre class="sourcecode">rabbitmqctl stop</pre>
          <p>
            Stops the Erlang node on which RabbitMQ is running. To
            restart the node follow the instructions for <i>Running
            the Server</i> in the <a href="install.html">installation
            guide</a>.
          </p>
          <p>
            For example:
          </p>
          <pre>rabbitmqctl stop</pre>
          <p>
            This command instructs the RabbitMQ node to terminate.
          </p>
        </doc:subsection>

        <doc:subsection name="stop_app">
          <doc:heading>Stopping the RabbitMQ application</doc:heading>
          <pre class="sourcecode">rabbitmqctl stop_app</pre>
          <p>
            Stops the RabbitMQ application, leaving the Erlang node
            running.
          </p>
          <p>
            This command is typically run prior to performing other
            management actions that require the RabbitMQ application
            to be stopped, e.g. <a
            href="#reset"><code>reset</code></a>.
          </p>
          <p>
            For example:
          </p>
          <pre>rabbitmqctl stop_app</pre>
          <p>
            This command instructs the RabbitMQ node to stop the
            RabbitMQ application.
          </p>
        </doc:subsection>

        <doc:subsection name="start_app">
          <doc:heading>Starting the RabbitMQ application</doc:heading>
          <pre class="sourcecode">rabbitmqctl start_app</pre>
          <p>
            Starts the RabbitMQ application.
          </p>
          <p>
            This command is typically run after performing other
            management actions that required the RabbitMQ application
            to be stopped, e.g. <a
            href="#reset"><code>reset</code></a>.
          </p>
          <p>
            For example:
          </p>
          <pre>rabbitmqctl start_app</pre>
          <p>
            This command instructs the RabbitMQ node to start the
            RabbitMQ application.
          </p>
        </doc:subsection>

        <doc:subsection name="status">
          <doc:heading>Displaying the RabbitMQ broker status</doc:heading>
          <pre class="sourcecode">rabbitmqctl status</pre>
          <p>
            Displays various information about the RabbitMQ broker,
            such as whether the RabbitMQ application on the current
            node, its version number, what nodes are part of the
            broker, which of these are running.
          </p>
          <p>
            For example:
          </p>
          <pre>rabbitmqctl status</pre>
          <p>
            This command displays information about the RabbitMQ
            broker.
          </p>
        </doc:subsection>

        <doc:subsection name="reset">
          <doc:heading>Resetting a RabbitMQ node</doc:heading>
          <pre class="sourcecode">rabbitmqctl reset</pre>
          <pre class="sourcecode">rabbitmqctl force_reset</pre>
          <p>
            Return a RabbitMQ node to its virgin state.
          </p>
          <p>
            Removes the node from any cluster it belongs to, removes
            all data from the management database, such as configured
            users and vhosts, and deletes all persistent
            messages.
          </p>
          <p>
            The <code>force_reset</code> command differs from
            <code>reset</code> in that it resets the node
            unconditionally, regardless of the current management
            database state and cluster configuration. It should only
            be used as a last resort if the database or cluster
            configuration has been corrupted.
          </p>
          <p>
            For <code>reset</code> and <code>force_reset</code> to
            succeed the RabbitMQ application must have been stopped,
            e.g. with <a href="#stop_app"><code>stop_app</code></a>.
          </p>
          <p>
            For example:
          </p>
          <pre>rabbitmqctl reset</pre>
          <p>
            This command resets the RabbitMQ node.
          </p>
        </doc:subsection>
        
        <doc:subsection name="rotate_logs">
          <doc:heading>Rotating log files</doc:heading>
          <pre class="sourcecode">rabbitmqctl rotate_logs <i>[suffix]</i></pre>
          <p>
            Instruct the RabbitMQ node to rotate the log files.
          </p>
          <p>
            The RabbitMQ broker will attempt to append the current contents
            of the log file to the file with name composed of the original
            name and the suffix.
            It will create a new file if such a file does not already exist.
            When no <i>suffix</i> is specified, the empty log file is
            simply created at the original location; no rotation takes place.
          </p>
          <p>
            When an error occurs while appending the contents of the old log
            file, the operation behaves in the same way as if no <i>suffix</i> was
            specified.
          </p>
          <p>
            This command might be helpful when you are e.g. writing your
            own logrotate script and you do not want to restart the RabbitMQ
            node.
          </p>
          <p>
            Example:
          </p>
          <pre>rabbitmqctl rotate_logs .1</pre>
          <p>
            This command instructs the RabbitMQ node to append the current content
            of the log files to the files with names consisting of the original logs'
            names and ".1" suffix, e.g. rabbit.log.1. Finally, the old log files are reopened.
          </p>
        </doc:subsection>

        <doc:subsection name="cluster">
          <doc:heading>Cluster management</doc:heading>
          <pre class="sourcecode">rabbitmqctl cluster <i>clusternode</i> <i>...</i></pre>
          <dl>
            <dt>clusternode</dt>
            <dd>
              Subset of the nodes of the cluster to which this node
              should be connected.
            </dd>
          </dl>
          <p>
            Instruct the node to become member of a cluster with the
            specified nodes.
          </p>
          <p>
            Cluster nodes can be of two types: disk or ram. Disk nodes
            replicate data in ram and on disk, thus providing
            redundancy in the event of node failure and recovery from
            global events such as power failure across all nodes. Ram
            nodes replicate data in ram only and are mainly used for
            scalability. A cluster must always have at least one disk node.
          </p>
          <p>
            If the current node is to become a disk node it needs to
            appear in the cluster node list. Otherwise it becomes a
            ram node. If the node list is empty or only contains the
            current node then the node becomes a standalone,
            i.e. non-clustered, (disk) node.
          </p>
          <p>
            After executing the <code>cluster</code> command, whenever
            the RabbitMQ application is started on the current node it
            will attempt to connect to the specified nodes, thus
            becoming an active node in the cluster comprising those
            nodes (and possibly others).
          </p>
          <p>
            The list of nodes does not have to contain all the
            cluster's nodes; a subset is sufficient. Also, clustering
            generally succeeds as long as at least one of the
            specified nodes is active. Hence adjustments to the list
            are only necessary if the cluster configuration is to be
            altered radically.
          </p>
          <p>
            For this command to succeed the RabbitMQ application must
            have been stopped, e.g. with <a
            href="#stop_app"><code>stop_app</code></a>. Furthermore,
            turning a standalone node into a clustered node requires
            the node be <a href="#reset"><code>reset</code></a> first,
            in order to avoid accidental destruction of data with the
            <code>cluster</code> command.
          </p>
          <p>
            For more details see the <a
            href="clustering.html">clustering guide</a>.
          </p>
          <p>
            Example:
          </p>
          <pre>rabbitmqctl cluster rabbit@tanto hare@elena</pre>
          <p>
            This command instructs the RabbitMQ node to join the
            cluster with nodes <code>rabbit@tanto</code> and
            <code>hare@elena</code>. If the node is one of these then
            it becomes a disk node, otherwise a ram node.
          </p>
        </doc:subsection>

      </doc:section>

      <doc:section name="user-management">
        <doc:heading>User management</doc:heading>

        <doc:subsection name="add_user">
          <doc:heading>Creating a user</doc:heading>
          <pre class="sourcecode">rabbitmqctl add_user <i>username</i> <i>password</i></pre>
          <dl>
            <dt>username</dt>
            <dd>
              The name of the user to create.
            </dd>
            <dt>password</dt>
            <dd>
              The password the created user will use to log in to the
              broker.
            </dd>
          </dl>
          <p>
            For example:
          </p>
          <pre>rabbitmqctl add_user tonyg changeit</pre>
          <p>
            This command instructs the RabbitMQ broker to create a
            user named <code>tonyg</code> with (initial) password
            <code>changeit</code>.
          </p>
        </doc:subsection>
        
        <doc:subsection name="delete_user">
          <doc:heading>Deleting a user</doc:heading>
          <pre class="sourcecode">rabbitmqctl delete_user <i>username</i></pre>
          <dl>
            <dt>username</dt>
            <dd>
              The name of the user to delete.
            </dd>
          </dl>
          <p>
            For example:
          </p>
          <pre>rabbitmqctl delete_user tonyg</pre>
          <p>
            This command instructs the RabbitMQ broker to delete the
            user named <code>tonyg</code>.
          </p>
        </doc:subsection>

        <doc:subsection name="change_password">
          <doc:heading>Changing a user's password</doc:heading>
          <pre class="sourcecode">rabbitmqctl change_password <i>username</i> <i>newpassword</i></pre>
          <dl>
            <dt>username</dt>
            <dd>
              The name of the user whose password is to be changed.
            </dd>
            <dt>newpassword</dt>
            <dd>
              The new password for the user.
            </dd>
          </dl>
          <p>
            For example:
          </p>
          <pre>rabbitmqctl change_password tonyg newpass</pre>
          <p>
            This command instructs the RabbitMQ broker to change the
            password for the user named <code>tonyg</code> to
            <code>newpass</code>.
          </p>
        </doc:subsection>

        <doc:subsection name="list_users">
          <doc:heading>Listing users</doc:heading>
          <pre class="sourcecode">rabbitmqctl list_users</pre>
          <p>
            For example:
          </p>
          <pre>rabbitmqctl list_users</pre>
          <p>
            This command instructs the RabbitMQ broker to list all users.
          </p>
        </doc:subsection>
      </doc:section>

      <doc:section name="access-control">
        <doc:heading>Access control</doc:heading>

        <p>
          When an AMQP client establishes a connection to an AMQP
          server, it specifies a virtual host within which it intends
          to operate. A first level of access control is enforced at
          this point, with the server checking whether the user has
          any permissions to access the virtual hosts, and rejecting
          the connection attempt otherwise.
        </p>

        <p>
          Resources, i.e. exchanges and queues, are named entities
          inside a particular virtual host; the same name denotes a
          different resource in each virtual host. A second level of
          access control is enforced when certain operations are
          performed on resources.
        </p>

        <p>
          RabbitMQ distinguishes between <em>configure</em>,
          <em>write</em> and <em>read</em> operations on a
          resource. The <em>configure</em> operations create or
          destroy resources, or alter their behaviour. The
          <em>write</em> operations inject messages into a
          resource. And the <em>read</em> operations retrieve messages
          from a resource.
        </p>

        <p>
          In order to perform an operation on a resource the user must
          have been granted the appropriate permissions for it. The
          following table shows what permissions on what type of
          resource are required for all the AMQP commands which
          perform permission checks.
          <table>
            <tr>
              <th>AMQP command</th>
              <th>configure</th>
              <th>write</th>
              <th>read</th>
            </tr>
            <tr>
              <td>exchange.declare</td><td>exchange</td><td/><td/>
            </tr>
            <tr>
              <td>exchange.delete</td><td>exchange</td><td/><td/>
            </tr>
            <tr>
              <td>queue.declare</td><td>queue</td><td/><td/>
            </tr>
            <tr>
              <td>queue.delete</td><td>queue</td><td/><td/>
            </tr>
            <tr>
              <td>queue.bind</td><td/><td>queue</td><td>exchange</td>
            </tr>
            <tr>
              <td>basic.publish</td><td/><td>exchange</td><td/>
            </tr>
            <tr>
              <td>basic.get</td><td/><td/><td>queue</td>
            </tr>
            <tr>
              <td>basic.consume</td><td/><td/><td>queue</td>
            </tr>
            <tr>
              <td>queue.purge</td><td/><td/><td>queue</td>
            </tr>
          </table>
        </p>

        <p>
          Permissions are expressed as a triple of regular expressions
          - one each for configure, write and read - on per-vhost
          basis. The user is granted the respective permission for
          operations on all resources with names matching the regular
          expressions. <i>(Note: For convenience RabbitMQ maps AMQP's
          default exchange's blank name to 'amq.default' when
          performing permission checks.)</i>
        </p>

        <p>
          Some AMQP operations can create resources with
          server-generated names. Every user has configure, write and
          read permissions for such resources. However, the names are
          strong and not discoverable as part of the protocol, only
          through management functionality. Therefore these resources
          are in effect private to the user unless they choose to
          dilvuge their names to other users.
        </p>

        <p>
          The regular expression <code>^$</code>, i.e. matching
          nothing but the empty string, exactly covers resources with
          server-generated names. That, for example, allows an
          administrator to restrict a user to declaring private
          resources only.
        </p>

        <p>
          RabbitMQ may cache the results of access control checks on a
          per-connection or per-channel basis. Hence changes to user
          permissions may only take effect when the user reconnects.
        </p>

        <doc:subsection name="add_vhost">
          <doc:heading>Creating a virtual host</doc:heading>
          <pre class="sourcecode">rabbitmqctl add_vhost <i>vhostpath</i></pre>
          <dl>
            <dt>vhostpath</dt>
            <dd>
              The name of the virtual host entry to create.
            </dd>
          </dl>
          <p>
            For example:
          </p>
          <pre>rabbitmqctl add_vhost test</pre>
          <p>
            This command instructs the RabbitMQ broker to create a new
            virtual host called <code>test</code>.
          </p>
        </doc:subsection>

        <doc:subsection name="delete_vhost">
          <doc:heading>Deleting a virtual host</doc:heading>
          <pre class="sourcecode">rabbitmqctl delete_vhost <i>vhostpath</i></pre>
          <dl>
            <dt>vhostpath</dt>
            <dd>
              The name of the virtual host entry to delete.
            </dd>
          </dl>
          <p>
            Deleting a virtual host deletes all its exchanges,
            queues, user mappings and associated permissions.
          </p>
          <p>
            For example:
          </p>
          <pre>rabbitmqctl delete_vhost test</pre>
          <p>
            This command instructs the RabbitMQ broker to delete the
            virtual host called <code>test</code>.
          </p>
        </doc:subsection>

        <doc:subsection name="list_vhosts">
          <doc:heading>Listing virtual hosts</doc:heading>
          <pre class="sourcecode">rabbitmqctl list_vhosts</pre>
          <p>
            For example:
          </p>
          <pre>rabbitmqctl list_vhosts</pre>
          <p>
            This command instructs the RabbitMQ broker to list all
            virtual hosts.
          </p>
        </doc:subsection>

        <doc:subsection name="set_permissions">
          <doc:heading>Setting user permissions</doc:heading>
          <pre class="sourcecode">rabbitmqctl set_permissions [<i>-p vhostpath</i>] <i>username</i> <i>regexp</i> <i>regexp</i> <i>regexp</i></pre>
          <dl>
            <dt>vhostpath</dt>
            <dd>
              The name of the virtual host to which to grant the user
              access, defaulting to <code>/</code>.
            </dd>
            <dt>username</dt>
            <dd>
              The name of the user to grant access to the specified
              virtual host.
            </dd>
            <dt>regexp</dt>
            <dd>
              The regular expressions for matching resource names for
              which the user is granted configure, write and read
              permissions, respectively.
            </dd>
          </dl>
          <p>
            For example:
          </p>
          <pre>rabbitmqctl set_permissions -p /myvhost tonyg "^tonyg-.*" ".*" ".*"</pre>
          <p>
            This command instructs the RabbitMQ broker to grant the
            user named <code>tonyg</code> access to the virtual host
            called <code>/myvhost</code>, with configure permissions
            on all resources whose names starts with "tonyg-", and
            write and read permissions on all resources.
          </p>
        </doc:subsection>

        <doc:subsection name="clear_permissions">
          <doc:heading>Clearing user permissions</doc:heading>
          <pre class="sourcecode">rabbitmqctl clear_permissions [<i>-p vhostpath</i>] <i>username</i></pre>
          <dl>
            <dt>vhostpath</dt>
            <dd>
              The name of the virtual host to which to deny the user
              access, defaulting to <code>/</code>.
            </dd>
            <dt>username</dt>
            <dd>
              The name of the user to grant access to the specified
              virtual host.
            </dd>
          </dl>
          <p>
            For example:
          </p>
          <pre>rabbitmqctl clear_permissions -p /myvhost tonyg</pre>
          <p>
            This command instructs the RabbitMQ broker to deny the
            user named <code>tonyg</code> access to the virtual host
            called <code>/myvhost</code>.
          </p>
        </doc:subsection>

        <doc:subsection name="list_permissions">
          <doc:heading>Listing permissions in a virtual host</doc:heading>
          <pre class="sourcecode">rabbitmqctl list_permissions [<i>-p vhostpath</i>]</pre>
          <dl>
            <dt>vhostpath</dt>
            <dd>
              The name of the virtual host for which to list the users
              that have been granted access to it, and their
              permissions. Defaults to <code>/</code>.
            </dd>
          </dl>
          <p>
            For example:
          </p>
          <pre>rabbitmqctl list_permissions -p /myvhost</pre>
          <p>
            This command instructs the RabbitMQ broker to list all the
            users which have been granted access to the virtual host
            called <code>/myvhost</code>, and the permissions they
            have for operations on resources in that virtual host.
          </p>
        </doc:subsection>

        <doc:subsection name="list_user_permissions">
          <doc:heading>Listing user permissions</doc:heading>
          <pre class="sourcecode">rabbitmqctl list_user_permissions <i>username</i></pre>
          <dl>
            <dt>username</dt>
            <dd>
              The name of the user for which to list the permissions.
            </dd>
          </dl>
          <p>
            For example:
          </p>
          <pre>rabbitmqctl list_user_permissions tonyg</pre>
          <p>
            This command instructs the RabbitMQ broker to list all the
            virtual hosts to which the user named <code>tonyg</code>
            has been granted access, and the permissions the user has
            for operations on resources in these virtual hosts.
          </p>
        </doc:subsection>

      </doc:section>

      <doc:section name="server_status">
        <doc:heading>Server Status</doc:heading>
        <p>
          The server status queries interrogate the server and return a list of
          results with tab-delimited columns. Some queries (<code>list_queues</code>,
          <code>list_exchanges</code> and <code>list_bindings</code>) accept an
          optional <code>vhost</code> parameter. This parameter, if present,  must be 
          specified immediately after the query. 
        </p>
        <doc:subsection name="list_queues">
          <doc:heading>Listing queues of a virtual host</doc:heading>
          <pre class="sourcecode">rabbitmqctl list_queues [<i>-p vhostpath</i>] [<i>queueinfoitem</i> ...]</pre>
          <p>
            Returns queue details. Queue details of the <code>/</code> virtual host
            are returned if the "-p" flag is absent. The "-p" flag can be used to 
            override this default. 
          </p>
          <p>
            The <code>queueinfoitem</code> parameter is used to indicate which queue
            information items to include in the results. The column order in the
            results will match the order of the parameters. If no
            <code>queueinfoitem</code>s are specified then queue name and depth are 
            displayed. <code>queueinfoitem</code> can take any value from the list 
            that follows:
          </p>
          <dl>
            <dt>name</dt>
            <dd>
              The name of the queue with non-ASCII characters URL-escaped.
            </dd>
            <dt>durable</dt>
            <dd>
              Whether or not the queue survives server restarts.
            </dd>
            <dt>auto_delete</dt>
            <dd>
              Whether the queue will be deleted automatically when no longer used.
            </dd>
            <dt>arguments</dt>
            <dd>
              Queue arguments.
            </dd>
            <dt>pid</dt>
            <dd>
              Id of the Erlang process associated with the queue.
            </dd>
            <dt>messages_ready</dt>
            <dd>
              Number of messages ready to be delivered to clients.
            </dd>
            <dt>messages_unacknowledged</dt>
            <dd>
              Number of messages delivered to clients but not yet acknowledged.
            </dd>
            <dt>messages_uncommitted</dt>
            <dd>
              Number of messages published in as yet uncommitted transactions
            </dd>
            <dt>messages</dt>
            <dd>
              Sum of ready, unacknowledged and uncommitted messages 
              (queue depth).
            </dd>
            <dt>acks_uncommitted</dt>
            <dd>
              Number of acknowledgements received in as yet uncommitted
              transactions.
            </dd>
            <dt>consumers</dt>
            <dd>
              Number of consumers.
            </dd>
            <dt>transactions</dt>
            <dd>
              Number of transactions.
            </dd>
            <dt>memory</dt>
            <dd>
              Bytes of memory consumed by the Erlang process associated with the
              queue, including stack, heap and internal structures.
            </dd>
          </dl>
          <p>
            For example:
          </p>
          <pre>rabbitmqctl list_queues -p /myvhost messages consumers</pre>
          <p>
            This command displays the depth and number of consumers for each 
            queue of the virtual host named <code>/myvhost</code>.
          </p>
        </doc:subsection>
        <doc:subsection name="list_exchanges">
          <doc:heading>Listing exchanges of a virtual host</doc:heading>
          <pre class="sourcecode">rabbitmqctl list_exchanges [<i>-p vhostpath</i>] [<i>exchangeinfoitem</i> ...]</pre>
          <p>
            Returns exchange details. Exchange details of the <code>/</code> virtual host
            are returned if the "-p" flag is absent. The "-p" flag can be used to 
            override this default. 
          </p>
          <p>
            The <code>exchangeinfoitem</code> parameter is used to indicate which
            exchange information items to include in the results. The column order in the
            results will match the order of the parameters. If no
            <code>exchangeinfoitem</code>s are specified then exchange name and type are 
            displayed. <code>exchangeinfoitem</code> can take any value from the list 
            that follows:
          </p>
          <dl>
            <dt>name</dt>
            <dd>
              The name of the exchange with non-ASCII characters URL-escaped.
            </dd>
            <dt>type</dt>
            <dd>
              The exchange type (one of [<code>direct</code>,
              <code>topic</code>, <code>headers</code>,
              <code>fanout</code>]).
            </dd>
            <dt>durable</dt>
            <dd>
              Whether or not the exchange survives server restarts.
            </dd>
            <dt>auto_delete</dt>
            <dd>
              Whether the exchange will be deleted automatically when no longer used.
            </dd>
            <dt>arguments</dt>
            <dd>
              Exchange arguments.
            </dd>
          </dl>
          <p>
            For example:
          </p>
          <pre>rabbitmqctl list_exchanges -p /myvhost name type</pre>
          <p>
            This command displays the name and type for each 
            exchange of the virtual host named <code>/myvhost</code>.
          </p>
        </doc:subsection>
        <doc:subsection name="list_bindings">
          <doc:heading>Listing bindings of a virtual host</doc:heading>
          <pre class="sourcecode">rabbitmqctl list_bindings [<i>-p vhostpath</i>]</pre>
          <p>
            By default the bindings for the <code>/</code> virtual
            host are returned. The "-p" flag can be used to override
            this default.  Each result row will contain an exchange
            name, queue name, routing key and binding arguments, in
            that order. Non-ASCII characters will be URL-encoded.
          </p>
        </doc:subsection>
        <doc:subsection name="list_connections">
          <doc:heading>Listing connections of a virtual host</doc:heading>
          <pre class="sourcecode">rabbitmqctl list_connections
          [<i>connectioninfoitem</i> ...]</pre>
          <p>
            Returns TCP/IP connection statistics.
            </p> <p>
            The <code>connectioninfoitem</code> parameter is used to indicate
            which connection information items to include in the results. The
            column order in the results will match the order of the parameters. If
            no <code>connectioninfoitem</code>s are specified then  user, peer
            address, peer port and connection state are displayed.
            <code>connectioninfoitem</code> can take any value from the list
            that follows:
          </p>
          <dl>
            <dt>pid</dt> 
            <dd>
              Id of the Erlang process associated with the connection.
            </dd> 
            <dt>address</dt> 
            <dd>
              Server IP address.
            </dd> 
            <dt>port</dt> 
            <dd>
              Server port.
            </dd> 
            <dt>peer_address</dt> 
            <dd>
              Peer address.
            </dd> 
            <dt>peer_port</dt> 
            <dd>
              Peer port.
            </dd> 
            <dt>state</dt> 
            <dd>
              Connection state (one of [<code>starting</code>, <code>tuning</code>, 
              <code>opening</code>, <code>running</code>, <code>closing</code>, <code>closed</code>]).
            </dd> 
            <dt>channels</dt> 
            <dd>
              Number of channels using the connection.
            </dd> 
            <dt>user</dt> 
            <dd>
              Username associated with the connection.
            </dd> 
            <dt>vhost</dt>
            <dd>
              Virtual host name with non-ASCII characters URL-escaped.
            </dd> 
            <dt>timeout</dt>
            <dd>
              Connection timeout.
            </dd> 
            <dt>frame_max</dt> 
            <dd>
              Maximum frame size (bytes).
            </dd> 
            <dt>client_properties</dt> 
            <dd>
              Informational properties transmitted by the client
              during connection establishment.
            </dd> 
            <dt>recv_oct</dt> 
            <dd>
              Octets received.
            </dd> 
            <dt>recv_cnt</dt> 
            <dd>
              Packets received.
            </dd> 
            <dt>send_oct</dt> 
            <dd>
              Octets send.
            </dd> 
            <dt>send_cnt</dt> 
            <dd>
              Packets sent.
            </dd> 
            <dt>send_pend</dt> 
            <dd>
              Send queue size.
            </dd>
          </dl>
          <p>
            For example:
            </p> <pre>rabbitmqctl list_connections send_pend server_port</pre>
            <p>
              This command displays the send queue size and server port for each
              connection.
            </p>
        </doc:subsection>
      </doc:section>

      <doc:section name="plugins">
        <doc:heading>Plugins</doc:heading>
        
        <p>
          RabbitMQ provides a plugin mechanism allowing for additional OTP applications to be run 
          within the broker node. Plugins should not be seen as a general purpose mechanism for writing
          applications, but instead as a specialised tool when additional functionality is required
          at the broker level.
        </p>
        <p>
          The RabbitMQ plugin mechanism makes use of a custom OTP .boot file, to start additional OTP 
          applications within the broker node, and thus comes with a number of caveats:
        </p>
        <ul>
          <li>
            Custom Boot files require that all applications (including standard OTP applications) have
            explicit versions listed. This means that if your OTP installation is upgraded, then Rabbit
            will most likely not start until the plugin activation script is run again.
          </li>
          <li>
            Since the plugin runs in the same node as the broker, it should not be assumed that any access
            controls configured on the broker will be observed by the plugin. Whilst plugins can interact
            with the ACL mechanism to ensure enforcement of security mechanisms, it is also possible for
            plugins to completely ignore security configuration.
          </li>
          <li>
            <strong>
              Again, since the plugin runs in the same node as the broker, an action that results in the node
              halting will shut down the RabbitMQ broker as well. Well-written plugins can be built to avoid
              this occuring, however Administrators should be aware of the risks of installing plugins - especially
              those that are not known to have undergone a rigorous QA procedure.
            </strong>
          </li>
        </ul>

        <doc:subsection name="installing-plugins">
          <doc:heading>Plugin Installation</doc:heading>
          <ul>
            <li>
              Plugins will generally be available in two forms. The expected form for a packaged plugin
              will be a .ez erlang archive. Alternatively, more developmental plugins may be distributed
              directly from source control, whereby they will be a directory containing (at least) an ebin
              subdirectory.
            </li>
            <li>
              In both cases, the plugin archive (or directory) should be placed into the plugins subdirectory
              within the rabbitmq-server installation directory (ie, the directory that the ebin directory
              resides within). If this directory does not exist, it can be safely created.
            </li>
            <li>
              Once the desired plugins have been placed in the plugins directory, run the following as root:
              <pre>rabbitmq-activate-plugins</pre> 
              Note that on some platforms it has been observed that many spurious warnings are printed along the lines
              of:
              <pre>*WARNING* mnesia: Object code (mnesia) out of date</pre>
              It is our experience that warnings of this variety can be safely ignored.
            </li>
            <li>
              Upon successful completion of the script, restart Rabbit. All installed plugins will be started
              automatically.
            </li>
            <li>
              <strong>Note for users with RabbitMQ installed as a Windows Service:</strong>
              When first activating, or deactivating, plugins, the 
              <pre>rabbitmq-service.bat install</pre>
              command will need to be re-run to ensure that the service configuration is updated to perform
              an appropriate boot sequence.
            </li>
          </ul> 
        </doc:subsection>
       
        <doc:subsection name="uninstalling-plugins">
          <doc:heading>Plugin Un-installation</doc:heading>
          
          <p>
            To remove an installed plugin from the broker, delete the .ez file or directory from the plugins
            directory, and re-run the rabbitmq-activate-plugins script. When the broker is restarted, the deleted
            plugin will no longer be started.
          </p>
        </doc:subsection>

        <doc:subsection name="disabling-all-plugins">
          <doc:heading>Disabling all Plugins</doc:heading>

          <p>
            In the event of broker mis-behaviour, it is recommended that all plugins be disabled as a first
            port-of-call. Instead of manually removing all files from the plugins directory, the deactivate
            plugins script can be used to disable all plugins until rabbitmq-activate-plugins is next run. To do this,
            execute:
            <pre>rabbitmq-deactivate-plugins</pre>
            
            When Rabbit is restarted, no custom plugins will be loaded.
          </p>
        </doc:subsection> 
      </doc:section>
    </doc:div>
  </body>
</html>
