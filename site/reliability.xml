<?xml-stylesheet type="text/xml" href="page.xsl"?>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:doc="http://www.rabbitmq.com/namespaces/ad-hoc/doc"
      xmlns:x="http://www.rabbitmq.com/2011/extensions">
  <head>
    <title>Reliability Guide</title>
  </head>
  <body show-in-this-page="true">
      <doc:section name="overview">
        <p>
          Learn how the different levels of message delivery guarantee
          in RabbitMQ work, the trade-offs available and how they can
          affect the system.
        </p>
      </doc:section>
      <doc:section name="background-info">
        <doc:heading>Pre-requisites and Recommended Reading</doc:heading>
        <p>
          We assume a solid grounding in AMQP concepts and constructs.
          If you're new to AMQP then we recommended you read the
          <a href="/tutorials/amqp-concepts.html">
            RabbitMQ Guide to AMQP Concepts
          </a>,
          <a href="http://www.rabbitmq.com/how.html">How To</a> pages
          and take the time to work through the
          <a href="/getstarted.html">RabbitMQ Tutorials</a>.
        </p>
      </doc:section>
      <doc:section name="concepts">
        <doc:subsection name="durability">
          <doc:heading>Durability and Persistence</doc:heading>
          <p>
            RabbitMQ implements a number of features to handle server restarts
            without data loss.
            The AMQP standard has a notion of durability (or persistence) for
            Exchanges, Queues and Messages. In essense this attribute has the
            same meaning for each: that the specified object will survive a
            restart of the broker. Whether a broker restart was deliberate (e.g.,
            a controlled restart issued via <code>rabbitmqctl stop</code> or some
            operating system supplied interface to the broker) or due to a node
            failure; The outcome is intended to be the same regardless of the
            reason the node fails. For queues and exchanges, when the
            <code>durable</code> flag is set upon sending the initial
            <code>queue.declare</code> or <code>exchange.declare</code> method to
            the server, the standard requires that these objects continue to
            be available after a server restart. For messages sent with the
            <code>delivery-mode</code> set to <i>persistent</i>, the standard
            requires the broker to
            "<i>make a best-effort to hold persistent basic messages on
            a reliable storage mechanism</i>."
          </p>
          <p>
            More details about specific flags pertaining to durability and
            persistence can be found in the
            <a href="/tutorials/amqp-concepts.html">AMQP Concepts Guide</a>.
          </p>
          <p>
            Due to the primarily asynchronous nature of AMQP, whilst a
            <code>{queue|exchange}.declare</code> command is on the wire,
            there is no way of knowing if the server has fulfilled the request
            until a <code>declare-ok</code> reply is received. Once this has
            arrived at the client, we can then be certain that the object
            exists and will be maintained by the broker accordingly.
            The AMQP declare method for both the exchange and queue classes is a
            declarative command. If the queue/exchange already exists, then we
            still receive <code>declare-ok</code> providing that the arguments
            given for subsequent invocations of this method are the same. As the
            spec puts it, this method will "verify the exchange exists, create
            if needed." The obvious solution to writing clients is, therefore,
            to declare exchanges/queues when the applications first connects to
            the broker. This operation will only fail if the object declaration
            fails the equivalence check; See the
            <a href="/amqp-0-9-1-reference.html">AMQP Reference</a> and RabbitMQ's
            <a href="/amqp-0-9-1-errata.html">list of AMQP 0-9-1 errata</a> for
            more details.
          </p>
          <h4>Handling Server Errors</h4>
          <p>
            If a <code>{queue|exchange}.declare</code> is rejected by the server,
            a channel error will be raised. Client libraries will represent this
            using whichever mechanism makes sense for the target language/platform.
            If the client library does not implement <code>{queue|exchange}.declare</code>
            synchronously, it is sensible  to wait for the relevant
            <code>declare-ok</code> reply before proceeding to use an object.

            TODO: <em>passive declarations</em>
          </p>
          <h4>Persistent Messages</h4>
          <p>
            When messages are marked as persistent, the broker is responsible
            for ensuring that they are safely held in stable storage once fully
            received. As an optimisation, the broker <em>might not persist
            a message if it can be delivered immediately</em> to a consumer,
            however messages will not be discarded even in this case, until
            an acknowledgement has been received.
          </p>
        </doc:subsection>
        <doc:subsection name="connectivity">
          <doc:heading>Connectivity.</doc:heading>
          <p>
            Connection failure can occur at any time. Whenever a RabbitMQ node
            is terminated for example, all client connections will be shut down.
            If the shutdown is graceful then the client will recieve a
            <code>connection.close</code> message from the broker. If not, then
            the connection may be abbruptly terminated once the operating system
            on which the client appliation is running, notices that the peer
            socket is non-responsive. Certain classes of server error can also
            lead to a <code>connection-error</code>. Errors on a connection
            (where the error code is in the >500 range) will cause the broker
            to close the connection.
          </p>
          <p>
            If the connection terminates for <i>any</i> reason, then it is up to
            the client to re-establish a connection in order to continue sending
            or receiving messages. Remember, once a connection is torn down, all
            its channels will disappear: any client code relying on these channels
            will need to create new channels once a new connection is established.
          </p>  
          <p>
            Client libraries may take various approaches to signalling channel and
            connection errors. The official Java client provides methods for adding
            a <code>ShutdownListener</code> callback on both connection and channel
            objects, and the .NET client provides the
            <code>IConnection.ConnectionShutdown</code> and
            <code>IModel.ModelShutdown</code> events for detecting connection and
            channel errors respectively.
          </p>
          <p>
            Because of the declarative nature of queue and exchange creation, after
            a connection to the broker is re-established, it is quite safe to issue
            <code>{queue|exchange}.declare</code> for objects your application expects
            to be working with, as long as the parameters passed with the declaration
            have not changed since they were first supplied.
          </p>
          <h4>Using Heartbeats</h4>
          <p>
            When the network does fail, it can take an Operating System a fairly long
            time to notice and pass this information on to listening applications.
            For example, on Linux based systems, the default kernel parameters yield
            a timeout of around 15 minutes after the first retransmission timeout.
            To disuade an application from waiting quite so long, we can enable AMQP
            heartbeats and set a lower threshold for connection timeouts. This has an
            added advantage over straight TCP keep-alives, in that both the broker and
            the client become aware of the connection failure, allow both to reclaim
            valuable operating system resources.
          </p>
          <p>
            In both the official Java and .NET clients, heartbeats are enabled by configuring
            the connection factory with the desired heartbeat interval.
          </p>
        </doc:subsection>
      </doc:section>
      <doc:section name="robust-data-flow">
          <doc:heading>Transferring Responsibility from Producer to Broker</doc:heading>
          <p>
            How can a producer application ensure that all operations are
            safely transferred to the broker in the face of server errors,
            connection failure, missing or incorrect object definitions,
            application logic errors and potential client failures?
          </p>
          <h4>Durable Entities</h4>
          <p>
            When a queue is declared as <code>exclusive</code>, it can only be
            accessed by the connection with which it was declared. Since we
            know that the connection could break at any time, if the loss of
            a queue (and the messages it contains) is unacceptable, then we
            should avoid making it <code>exclusive</code>. Since the computer
            on which the broker is running could potentially crash at any time,
            to avoid data loss we must also ensure that the queue is
            <code>durable</code>.
          </p>
          <h4>Acknowledgements</h4>
          <p>
            From the producer's perspective, the only way to guarantee that a
            message isn't lost is by using transactions. A broker failure
            after publication but before the message is persisted to disk and
            the file system synchronised can cause message loss. Transactions
            eliminate the risk of this happening, because the commit-ok reply
            is only sent to the client once those steps have been completed.
            Transactions however, are quite heavy for this purpose and come
            with a significant cost to performance. To address this, RabbitMQ
            added an extension to the AMQP standard called confirms (aka
            publisher or producer confirms). Confirms are a lightweight
            alternative to transactions, which ensure the same guarantees
            with regards message publication, but offer far superiour performance.
            Confirms are enabled by sending <code>confirm-select</code> on an
            open channel. Once the broker responds with <code>confirm-ok</code>
            then the channel is said to be <i>in confirm mode</i>.
          </p>
          <p>
            Once a message is sent to the broker, the producer will receive a
            <code>basic.ack</code> once one of the following conditions holds:
            <ul>
              <li>an un-routable mandatory message is confirmed
              right after the <code>basic.return</code> is sent</li>
              <li>a transient message is confirmed the moment it is enqueued</li>
              <li>a persistent message is confirmed when it is persisted to disk
              or when it is consumed on every queue</li>
            </ul>
            Once a <code>basic.ack</code> arrives, the message is <em>confirmed</em>
            and the publisher can be assured that the broker has taken full
            responsibility for it. In particular, for a persistent message, the
            broker ensures that a full fsync to the filesystem takes place
            before sending the <code>basic.ack</code>, ensuring that all I/O
            buffers have been flushed to disk properly.
          </p>
          <h4>Handling Lost ACKs</h4>
          <p>
            Whilst producer confirms provide stronger guarantees, it is still possible
            for a network failure to introduce failures when using producer confirms.
            Say one or more messages are sent and the producer is waiting for ACKs
            from the broker. A network error occurs and the connection is broken, forcing
            the producer to re-connect. Having not seen an ACK for these messages, we must
            re-transmit them, however it is <em>possible</em> that the broker did receive
            them <b>and</b> sent ACKs for some (or all), but all those ACKs en-route to the
            producer were lost due to the network failure. The producer has no choice but to
            re-transmit the messages, and it will be necessary for consumers to handle
            potential duplicates somehow. The application can utilise the AMQP Basic
            <code>message-id</code> field to assist with this, or use a custom header
            if the <code>shortstr</code> data type is not suitable for thier application's
            purposes. Responsibility for de-duplicating messages with the same application
            specific message-id belongs with the consumer, i.e., you will have to write this
            logic yourself, based on your application's requirements.
          </p>
          <h4>Handling un-routable messages</h4>
          <p>
            AMQP provides a neat recipe for detecting situations in which a published
            message cannot be routed. When the <code>mandatory</code> flag is set on a
            <code>basic.publish</code>, the server will send back a <code>basic.return</code>,
            which contains a reply code and text providing information about why the message
            was undeliverable.
          </p>
      </doc:section>
      <doc:section name="broker-2-consumer">
        <doc:subsection name="reliable-clients">
          <!-- TODO: move this into the xr from broker to consumer section -->
          <doc:heading>Transfered Responsibility from Broker to Consumer</doc:heading>
          <p>
            Clients, both producing and consumer, need to handle various error
            conditions at runtime. Failures can occur at various points between
            client and server, each of which requires special handling by the
            application developer.
          </p>
          TODO: waitForConfirms and batching
          TODO: storing and sequencing in producer code
          TODO: handling duplicates in consumer code
          TODO: handling errors with ShutdownListener (+ non-java examples?)
          TODO: dealing with reject
          TODO: consumer-cancel
          <p>
            Consumer cancel notifications
          </p>
        </doc:subsection>
        <doc:subsection name="failover-and-recovery">
          <doc:heading>Failover and Recovery</doc:heading>
        </doc:subsection>
      </doc:secion>
      <doc:section name="distributed">
        <doc:heading>Distributed RabbitMQ</doc:heading>
        TODO: when you've federated the same exchange on two upstreams 
             which are clustered and made the federation (internal) queues
             (on the two upstreams) HA/mirrored - Rather than having an upstream
             set containing connection definitions for both upstream nodes,
             have just one connection definition, to an upstream load balancer
             otherwise the order of messages cannot be preserved.
      </doc:section>
  </body>
</html>

