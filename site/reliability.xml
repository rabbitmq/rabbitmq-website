<?xml-stylesheet type="text/xml" href="page.xsl"?>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:doc="http://www.rabbitmq.com/namespaces/ad-hoc/doc"
      xmlns:x="http://www.rabbitmq.com/2011/extensions">
  <head>
    <title>Reliability Guide</title>
  </head>
  <body show-in-this-page="true">
      <doc:section name="overview">
        <p>
          Learn how the different levels of message delivery guarantee
          in RabbitMQ work, the trade-offs available and how they can
          affect the system. This guide also covers working with
          unreliable networks and dealing reliably and safely with
          situations that can arise in client code. Please take the time
          to check the pre-requisites (see <a href="#toc">the table of
          contents</a> below) and make sure you have a solid grounding
          in the necessary concepts before you get started.
        </p>
      </doc:section>
      <doc:section name="page-toc">
        <div class="landing-box">
          <ul>
            <li>
              <a href="#background-info">Pre-requisites and recommended reading</a>
            </li>
            <li><a href="#method">How to use this guide</a></li>
            <li><a href="#concepts">Reliable Systems: Concepts and Architecture</a>
            </li>
            <li>
              <a href="#robust-data-flow">Robust Data Flow</a>
            </li>
            <li>
              <a href="#distributed">Distributed RabbitMQ</a>
              <ul>
                <li>
                  <a href="#distributed-guarantees">
                    Availability and Partition Tolerence Guarantees
                  </a>
                </li>
                <li><a href="federated-clusters">Federated Clusters</a></li>
              </ul>
            </li>
          </ul>
        </div>
      </doc:section>
      <doc:section name="background-info">
        <doc:heading>Pre-requisites and Recommended Reading</doc:heading>
        <p>
          This guide will be much easier to follow if you already have a solid
          grasp of AMQP concepts and constructs. If you need to build this up,
          or would like a quick refresher, then it is highly recommended that
          you read the
          <a href="/tutorials/amqp-concepts.html">
            RabbitMQ Guide to AMQP Concepts
          </a> and the
          <a href="http://www.rabbitmq.com/how.html">How To</a> pages before diving
          deeply into this guide. We assume a working knowledge of AMQP throughout.
          The reader should also take the time to work through the
          <a href="/getstarted.html">RabbitMQ Tutorials</a>.
        </p>
        <p>
          We discuss the message delivery guarantees availble when using RabbitMQ
          clustering and Highly Availabile queues; A basic working knowledge of
          RabbitMQ clustering is assumed. More information about RabbitMQ
          clusters and HA is available on the website, where links to specific
          items are available via the <a href="admin-guide.html">Admin Guide</a>.
        </p>
        <p>
          Readers should be familiar with the various ways in which RabbitMQ brokers
          can be <a href="/distributed.html">run in a distributed environment</a>.
          In particular it is helpful to understand RabbitMQ federation and
          reading the <a href="/federation.html">Federation Plugin Guide</a> is
          recommended.
        </p>
        <p>
          We present <a href="#example">examples</a> throughout, using official
          <a href="/java-client.html">Java</a>, <a href="/dotnet.html">C#/.NET</a>
          and <a href="/erlang-client.html">Erlang</a> client libraries.
        </p>
      </doc:section>
      <doc:section name="method">
        <doc:heading>How to use this guide</doc:heading>
        <p>
          This guide is structured into three main sections. The first explains the
          <a href="concepts">concepts</a> (i.e., the broad areas we focus on when
          building for reliability) and gives an overview of the features
          RabbitMQ provides to address these. The second focusses on
          <a href="robust-data-flow">Robust Data Flow</a>, i.e., ensuring against
          data loss within the system at large. Examining this from the producer
          and consumer points of view, each of the conceptual areas of reliability
          from the previous section are related in turn to the design decisions
          that developers face. The third section addresses additional
          considerations when using RabbitMQ in a
          <a href="/distributed.html">distributed environment</a> (cf.
          <a href="/clustering.html">Clustering</a>,
          <a href="/ha.html">Mirror/HA Queues</a> and
          <a href="/federation.html">Federation</a>).
          Again, the overarching concepts are applied to each scenario as
          appropriate.
        </p>
        <p>
          Throughout this guide, we present a method for analysing, designing and
          building reliable messaging solutions by applying a simple principle;
          <b>Transfer of Responsibility</b> allows us to determine that, at some
          given point, a participant in the system has accepted responsibility for
          some data. Once we <i>know</i> which part of the system is responsible
          for data, we can identify which levels of safety can be applied and
          what guarantees RabbitMQ offers therein.
        </p>
        <h3>Transfer of Responsibility: Building for Reliability</h3>
        <p>
          Messaging oriented systems typically involve interactions between three
          broad classes of citizen: data producers, data consumers and brokers.
          It is entirely possible that application data reside at once with one
          <i>or more</i> parties while the system is in use. Messages sent to a
          broker may or may not be discarded after sending by producers and the
          broker may (in some circumstances) still hold on to messages it has
          successfully delivered to consumers. At any given time however, only
          one such participant should be deemed <em>responsible</em> for the data.
          AMQP and (in particular) RabbitMQ, provides tools that help us identify
          the responsible party at a given time, and we use these to design for
          reliability. The other important consideration is that in any computer
          system, no matter how well defined,
          <a href="http://en.wikipedia.org/wiki/Murphy%27s_law">Murphy's Law</a>
          is always in effect. Any one of the participating agents in the system
          can crash at any time, so we must work to understand the impact of this
          and set our expectations appropriately.
        </p>
        <p>
          In order to understand the level of reliability a given design will
          provide, we follow a simple pattern then. First, we determine which
          participant is initially (or currently) the responsibile party. Then
          we examine <em>how</em> they will discharge their responsibility,
          thus transferring it to another party. Finally, we consider the
          potential impact if either the responsible party or the transfer
          itself fails. We will follow this pattern closely throughout this
          guide, seeing how to apply it to the design decisions we make when
          configuring and using RabbitMQ.
        </p>
        <p>Consider the transfer of responsibility
          from a producer application to the broker. Once a messsage is sent,
          how can we be certain that the broker has received it? If we see
          corresponding errors in the channel this is easy to answer, but if
          we do not then how can we be certain that broker has accepted the
          message and therefore our responsibility for it is discharged?
          Even if we do deterimine this, now that the broker is responsible
          for the message what will happen to the message if the broker crashes?
          This guide aims to answer these kinds of question for a wide range of
          scenarios, but it will never be possible to describe <i>all</i> the
          potential situations. By understanding this
          <i>Transfer of Responsibility</i> principle, it should be possible to
          use your knowledge of RabbitMQ's features to meet the specific needs
          of your own applications.
        </p>
      </doc:section>
      <doc:section name="concepts">
        <doc:heading>Reliable Systems: Concepts and Architecture</doc:heading>
        <div>
          <ul>
            <li>
              <a href="#durability">Durability and Persistence</a>
            </li>
            <li>
              <a href="#connectivity">Working with unreliable networks</a>
            </li>
            <li>
              <a href="#reliable-clients">Writing reliable client code</a>
            </li>
            <li>
              <a href="#failover-and-recovery">Failover and Recovery</a>
            </li>
          </ul>
        </div>
        <doc:subsection name="durability">
          <doc:heading>Durability and Persistence</doc:heading>
          <p>
            Handling server restarts without data loss is a pre-requisite for
            reliable systems, and RabbitMQ implements a number of features to
            assist in this. These features are important for solutions built on
            an individual broker node in addition to distributed designs that
            utilse federation and clustering. Proper use of durable entities
            underpins many of the message delivery guarantees we outline
            later on.
          </p>
          <p>
            The AMQP standard has a notion of durability (or persistence) for
            Exchanges, Queues and Messages. In essense this attribute has the
            same meaning for each: that the specified object will survive a
            restart of the broker. Whether a broker restart was deliberate (e.g.,
            a controlled restart issued via <code>rabbitmqctl stop</code> or some
            operating system supplied interface to the broker) or due to a node
            failure; The outcome is intended to be the same regardless of the
            reason the node fails. For queues and exchanges, when the
            <code>durable</code> flag is set upon sending the initial
            <code>queue.declare</code> or <code>exchange.declare</code> method to
            the server, the standard requires that these objects continue to
            be available after a server restart. For messages sent with the
            <code>delivery-mode</code> set to <i>persistent</i>, the standard
            requires the broker to
            "<i>make a best-effort to hold persistent basic messages on
            a reliable storage mechanism</i>."
          </p>
          <p>
            More details about specific flags pertaining to durability and
            persistence can be found in the
            <a href="/tutorials/amqp-concepts.html">AMQP Concepts Guide</a>.
          </p>
          <h4>Durable Entities: Transfer of Responsibility</h4>
          <p>
            When a client declares queues, exchanges and bindings, it is asking
            the broker to take responsibility for creating these objects. Once
            created, the broker is responsible for maintaining them and, if the
            <code>durable</code> flag is set, for ensuring that they survive a
            restart.
          </p>
          <p>
            Due to the primarily asynchronous nature of AMQP, whilst a
            <code>{queue,exchange}.declare</code> command is on the wire,
            there is no way of knowing if the server has fulfilled the request
            until a <code>declare-ok</code> reply is received. Once this has
            arrived at the client however, we can be certain that the object
            exists and will be maintained by the broker accordingly. Until
            we have received the reply, we should assume that the client is
            <i>still in the position of responsibility</i>.
          </p>
          <p>
            How should a client act until the server has indicated that it has
            taken responsibility for an object then? The AMQP declare method for
            both the exchange and queue classes is, as its name suggests, a
            declarative command. If the queue/exchange already exists, then we
            still receive <code>declare-ok</code> providing that the arguments
            given for subsequent invocations of this method are the same. As the
            spec puts it, this method will "verify the exchange exists, create
            if needed." The obvious solution to writing clients is, therefore,
            to declare exchanges/queues when the applications first connects to
            the broker. This operation will only fail if the object declaration
            fails the equivalence check; See the
            <a href="/amqp-0-9-1-reference.html">AMQP Reference</a> and RabbitMQ's
            <a href="/amqp-0-9-1-errata.html">list of AMQP 0-9-1 errata</a> for
            more details.
          </p>
          <h4>Handling Server Errors</h4>
          <p>
            If a <code>{queue|exchange}.declare</code> is rejected by the server,
            a channel error will be raised. Client libraries will represent this
            using whichever mechanism makes sense for the target language/platform.
            Clients should be prepared to handle server errors, though the
            presense of errors for queue and exchange declaration could indicate
            an error in the client code itself. For example, if the server
            raises a channel error with precondition-failed (because some invalid
            value was presented or an equivalence check failed) then the client
            must deal with this accordinaly.
          </p>
          <p>
            TODO: <em>passive declarations</em>
          </p>
          <h4>Handling Connection Failures</h4>
          <p>
            Connectivity between the client and server can fail at any time. We
            do not find out about failures immediately, unless the client is
            put into a blocking receive pending a response from the server. Even
            then, the timing of connection error notifications is not guaranteed,
            as we will see later on. If the client library does not implement
            <code>{queue|exchange}.declare</code> synchronously, it is sensible
            to wait for the relevant <code>declare-ok</code> reply before
            proceeding to use an object.
          </p>
          <p>
            Detecting connection failures in a timely fashion can help enourmously
            here: the <a href="connectivity">section on unreliable networks</a>
            later on will cover this in detail.
          </p>
          <h4>Persistent Messages: Transfer of Responsibility</h4>
          <p>
            When messages are marked as persistent, the broker is responsible
            for ensuring that they are safely held in stable storage once fully
            received. As an optimisation, the broker <em>might not persist
            a message if it can be delivered immediately</em> to a consumer,
            however messages will not be discarded even in this case, until
            an acknowledgement has been received.
          </p>
          <p>
            From the producer's perspective, the only way to guarantee that a
            message isn't lost is by using transactions. Failure of the broker
            after publication but before the message is persisted to disk and
            the file system synchronised can cause message loss. Transactions
            eliminate the risk of this happening, because the commit-ok reply
            is only sent to the client once those steps have been completed.
            Transactions however, are quite heavy for this purpose and come
            with a significant cost to performance. To address this, RabbitMQ
            added an extension to the AMQP standard called confirms (aka
            publisher or producer confirms). Confirms are a lightweight
            alternative to transactions, which ensure the same guarantees
            with regards message publication, but offer far superiour performance.
            Confirms are enabled by sending <code>confirm-select</code> on an
            open channel. Once the broker responds with <code>confirm-ok</code>
            then the channel is said to be <i>in confirm mode</i>. A transactional
            channel cannot be set to confirm mode, nor can a channel on which
            confirms are enabled be made transactional - the two options are
            mutually exclusive.
          </p>
          <p>
            How then, do confirms enable producers to transfer responsibility for
            messages to the broker? Once a message is sent to the
            broker, the producer will receive a <code>basic.ack</code> once one
            of the following conditions holds:
            <ul>
              <li>an un-routable mandatory message is confirmed
              right after the <code>basic.return</code> is sent</li>
              <li>a transient message is confirmed the moment it is enqueued</li>
              <li>a persistent message is confirmed when it is persisted to disk
              or when it is consumed on every queue</li>
            </ul>
            Once the <code>basic.ack</code> arrives, the message is <em>confirmed</em>
            and the publisher can be assured that the broker has taken full
            responsibility for it. In particular, for a persistent message, the
            broker ensures that a full fsync of the filesystem takes place
            before sending the <code>basic.ack</code>, ensuring that all I/O
            buffers have been flushed to disk properly.
          </p>
        </doc:subsection>
        <doc:subsection name="connectivity">
          <doc:heading>Working with unreliable networks.</doc:heading>
          <p>
            <a href="http://en.wikipedia.org/wiki/Murphy%27s_law">Murphy's Law</a>
            is in full effect whenever communication between networked computers
            happens. Modern networking infrastructure is incredibly complex and
            yet intermittent delays and even complete failures are not at all
            uncommon. Network problems are complex and varied, therefore we will
            not manage to cover all the posibilities here. Instead we will focus
            on the two most common classes of error that are seen in practise:
            connection failures and unexpected delays.
          </p>
          <p>
            Connection failure can occur at any time. Whenever a RabbitMQ node
            is terminated for example, all client connections will be shut down.
            If the shutdown is graceful then the client will recieve a
            <code>connection.close</code> message from the broker. If not, then
            the connection may be abbruptly terminated once the operating system
            on which the client appliation is running, notices that the peer
            socket is non-responsive. Certain classes of server error can also
            lead to a <code>connection-error</code>. Errors on a connection
            (where the error code is in the >500 range) will cause the broker
            to close the connection.
          </p>
          <p>
            Clients are responsible for maintaining their connection to the broker
            at all times. If the connection terminates for <i>any</i> reason,
            then it is up to the client to re-establish a connection in order to
            continue sending or receiving messages. It is important to understand
            that, once a connection is torn down, all its channels are removed
            also and therefore any client code relying on them must create new
            channels once another connection has been established.

            TODO: cover these points

            - channel errors
            - reconnecting 
            - re-sending
            - delays and timeouts
          </p>
          TODO: reconnection logic and rabbitmq-ha-client (on github) as an example
        </doc:subsection>
        <doc:subsection name="reliable-clients">
          <doc:heading>Writing reliable client code</doc:heading>
          <p>
            Clients, both producing and consumer, need to handle various error
            conditions at runtime. Failures can occur at various points between
            client and server, each of which requires special handling by the
            application developer.
          </p>
          TODO: waitForConfirms and batching
          TODO: storing and sequencing in producer code
          TODO: handling duplicates in consumer code
          TODO: handling errors with ShutdownListener (+ non-java examples?)
          TODO: dealing with reject
          TODO: consumer-cancel
        </doc:subsection>
        <doc:subsection name="failover-and-recovery">
          <doc:heading>Failover and Recovery</doc:heading>
        </doc:subsection>
      </doc:section>
      <doc:section name="robust-data-flow">
        <doc:heading>Robust Data Flow</doc:heading>
        <div>
          <ul>
            <li><a href="#producer-to-broker">From Producer to Broker</a></li>
            <li><a href="#broker-to-consumer">From Broker to Consumer</a></li>
          </ul>          
        </div>
        <doc:subsection name="producer-to-broker">
          <doc:heading>Transferring Responsibility from Producer to Broker</doc:heading>
          <p>
            How can a producer application ensure that all operations are
            safely transferred to the broker in the face of server errors,
            connection failure, missing or incorrect object definitions,
            application logic errors and potential client failures?
          </p>
          <h4>The role of Durable Entities</h4>
          <p>
            When a queue is declared as <code>exclusive</code>, it can only be
            accessed by the connection with which it was declared. Since we
            know that the connection could break at any time, if the loss of
            a queue (and the messages it contains) is unacceptable, then we
            should avoid making it <code>exclusive</code>. We also know that the
            computer on which the broker is running could potentially crash at
            any time, therefore if we want to avoid data loss in this scenario
            we must ensure that the queue is also <code>durable</code>.
          </p>
          <p>
            Because exchanges do not store messages, 
          </p>
        </doc:subsection>
      </doc:section>
      <doc:section name="distributed">
        <doc:heading>Distributed RabbitMQ</doc:heading>
        TODO: when you've federated the same exchange on two upstreams 
             which are clustered and made the federation (internal) queues
             (on the two upstreams) HA/mirrored - Rather than having an upstream
             set containing connection definitions for both upstream nodes,
             have just one connection definition, to an upstream load balancer
             otherwise the order of messages cannot be preserved.
      </doc:section>
  </body>
</html>

