<?xml-stylesheet type="text/xml" href="page.xsl"?>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:doc="http://www.rabbitmq.com/namespaces/ad-hoc/doc"
      xmlns:x="http://www.rabbitmq.com/2011/extensions">
  <head>
    <title>Reliability Guide</title>
  </head>
  <body show-in-this-page="true">
    <doc:section name="background-info">
      <p class="intro">
        This page explains how to use the various features of AMQP
        and RabbitMQ to achieve <i>reliable delivery</i> - to ensure
        that messages are always delivered, even in the face of
        failure of any part of your system.
      </p>
    </doc:section>
    <doc:section name="what-can-fail">
      <doc:heading>What Can Fail?</doc:heading>
      <p>
        Network problems are probably the most common class of failure.  Not
        only can networks fail, firewalls can interrupt idle connections,
        and network failures are not always detected immediately.
      </p>
      <p>
        In addition to connectivity failures, the broker and client
        applications can experience hardware failure (or software can crash)
        at any time. Additionally, even if client applications keep running,
        logic errors can cause channel or connection errors which force the
        client to establish a new channel or connection and recover from the
        problem.
      </p>
    </doc:section>
    <doc:section name="connection-failures">
      <doc:heading>Connection Failures</doc:heading>
      <p>
        In the event of a connection failure, the client will need to
        establish a new connection to the broker.  Any channels opened on the
        previous connection will have been automatically closed and these will
        need re-opening too.
      </p>
      <p>
        The official Java client provides methods for adding a
        <code>ShutdownListener</code> callback on both connection and channel
        objects, and the .NET client provides the
        <code>IConnection.ConnectionShutdown</code> and
        <code>IModel.ModelShutdown</code> events for the same purpose.
        <!-- TODO what is this telling us? -->
      </p>
      <h3>Acknowledgements and confirms</h3>
      <p>
        When a connection fails, messages may be in transit between client and
        server - they may be in the middle of being parsed or generated, in OS
        buffers, or on the wire. Messages in transit will be lost - they will
        need to be retransmitted. <i>Acknowledgements</i> let the server and
        clients know when to do this.
      </p>
      <p>
        Acknowledgements can be used in both directions - to allow a consumer
        to indicate to the server that it has received / processed a message
        and to allow the server to indicate the same thing to the
        producer. RabbitMQ refers to the latter case as a "confirm".
      </p>
      <p>
        Of course, TCP ensures that packets have been received, and will
        retransmit until they are - but that's just the network
        layer. Acknowledgements and confirms indicate that messages have been
        received <i>and acted upon</i>. An acknowledgement signals both the
        receipt of a message, and a transfer of ownership where the receiver
        assumes full responsibility for it.
      </p>

      <p>
        Acknowledgements therefore have semantics - a consuming application
        should not acknowledge messages until it has done whatever it needs to
        do with them - recorded them in a database, forwarded them on, printed
        them onto paper or anything else. Once it does so, the broker is free
        to forget about the message.
      </p>

      <p>
        Similarly, the broker will confirm messages once:
      </p>

      <!-- TODO this duplicates confirms.html (but is maybe a bit
      clearer). Move it there. -->
      <ul>
        <li>
          it decides a message will not be routed to queues<br/>
          (if the <code>mandatory</code> flag is set then
          the <code>basic.return</code> is sent first) <b>or</b>
        </li>
        <li>
          a transient message has reached all its queues (and mirrors) <b>or</b>
        </li>
        <li>
          a persistent message has reached all its queues (and mirrors)
          and been persisted to disk (and <code>fsync</code>ed) <b>or</b>
        </li>
        <li>
          a persistent message has been consumed (and if necessary
          acknowledged) from all its queues
        </li>
      </ul>

      <p>
        Use of acknowledgements guarantees <i>at-least-once</i>
        delivery. Without acknowledgements, message loss is possible
        during publish and consume operations and
        only <i>at-most-once</i> delivery is guaranteed.
      </p>

      <h3>Heartbeats</h3>
      <p>
        In some types of network failure, packet loss can mean that disrupted
        TCP connections take some time to be detected by the operating
        system. AMQP offers a <i>heartbeat</i> feature to ensure that the
        application layer promptly finds out about disrupted connections (and
        also completely unresponsive peers). Heartbeats also defend against
        certain network equipment which may terminate "idle" TCP
        connections. In RabbitMQ versions 3.0 and higher, the broker will
        attempt to negotiate heartbeats by default (although the client can
        still veto them). Using earlier versions the client must be configured
        to request heartbeats.
      </p>
    </doc:section>

    <doc:section name="at-the-broker">
      <doc:heading>At the Broker</doc:heading>
      <p>
        In order to avoid losing messages in the broker we need to cope with
        broker restarts, broker hardware failure and <i>in extremis</i> even
        broker crashes.
      </p>
      <p>
        To ensure that messages and broker definitions survive restarts, we
        need to ensure that they are on disk. The AMQP standard has a concept
        of durability for exchanges, queues and of persistent messages,
        requiring that a durable object or persistent message will survive a
        restart. More details about specific flags pertaining to durability
        and persistence can be found in the
        <a href="/tutorials/amqp-concepts.html">AMQP Concepts Guide</a>.
      </p>
      <h3>Clustering and High Availability</h3>
      <p>
        If we need to ensure that our broker survives hardware failure, we can
        use RabbitMQ's clustering. In a RabbitMQ cluster, all definitions (of
        exchanges, bindings, users, etc) are mirrored across the entire
        cluster. Queues behave differently, by default residing only on a
        single node, but optionally being mirrored across several or all
        nodes. Queues remain visible and reachable from all nodes regardless
        of where they are located.
      </p>
      <p>
        Mirrored queues replicate their contents across all configured cluster
        nodes, tolerating node failures seamlessly and without message loss
        (although see <a href="ha.html#unsynchronised-slaves">this note on
        unsynchronised slaves</a>). However, consuming applications need to be
        aware that when queues fail their consumers will be cancelled and they
        will need to reconsume - see <a href="ha.html#behaviour">the
        documentation</a> for more details.
      </p>
    </doc:section>

    <doc:section name="producer">
      <doc:heading>At the Producer</doc:heading>
      <p>
        When using confirms, producers recovering from a channel or connection
        failure should retransmit any messages for which an acknowledgement
        has not been received from the broker. There is a possibility of
        message duplication here, because the broker might have sent a
        confirmation that never reached the producer (due to network failures,
        etc). Therefore consumer applications will need to perform
        deduplication or handle incoming messages in an idempotent manner.
      </p>
      <h3>Ensuring messages are routed</h3>
      <p>
        In some circumstances it can be important for producers to ensure that
        their messages are being routed to queues (although not always - in
        the case of a pub-sub system producers will just publish and if no
        consumers are interested it is correct for messages to be dropped).
      </p>
      <p>
        To ensure messages are routed to a single known queue, the producer
        can just declare a destination queue and publish directly to it. If
        messages may be routed in more complex ways but the producer still
        needs to know if they reached at least one queue, it can set the
        <code>mandatory</code> flag on a <code>basic.publish</code>, ensuring
        that a <code>basic.return</code> (containing a reply code and some
        textual explanation) will be sent back to the client if no queues were
        appropriately bound.
      </p>
    </doc:section>

      <doc:section name="consumer-connectivity-failures">
        <doc:heading>At the Consumer</doc:heading>
        <p>
          In the event of network failure (or a node crashing), consumers must
          be prepared to handle duplicated messages - RabbitMQ guarantees
          <em>at-least-once</em> delivery,not <em>exactly-once</em>. The client
          may utilise the <code>redelivered</code> flag if it is set on
          <code>basic.deliver</code>, but should not rely solely on this to
          determine whether or not it has seen a message before. Instead,
          clients are encouraged to utilise application specific identifiers
          (passed either in the <code>message-id</code> or some other custom
          header) to identify duplicates. Some clients may prefer to make
          message handling idempotent rather than explicitly deal with
          deduplicating inbound messages.
        </p>
        <h4>Consumer Cancel Notifications</h4>
        <p>
          A RabbitMQ extension to AMQP, consumer cancel notifications enable
          clients to detect error conditions that would otherwise go unnoticed.
          For clients that support the extension, a <code>basic.cancel</code>
          will be sent if a queue from which the client is consuming is deleted,
          or in a clustered scenario, if the node on which the queue is located
          fails. When a master fails, the promoted slave considers all previous
          consumers to have been abruptly disconnected and summarily requeues
          all messages that are still pending ACKs. Clients connected to a
          surviving node which are using Consumer Cancel Notifications should
          treat the notification that their subscription to the mirrored-queue
          has been abruptly cancelled as a signal that they should be prepared
          to handle duplicate messages if necessary.
        </p>
      </doc:section>
      <doc:section name="ap-distribution">
        <doc:heading>Distributed RabbitMQ</doc:heading>
        <p>
          Rabbit provides two plugins to assist with distributing nodes over
          unreliable networks: <em>Federation</em> and the <em>Shovel</em>.
          Both are implemented as AMQP clients, so if you configure them to
          use confirms (and avoid <code>noAck</code> mode), they will retransmit
          when necessary.
        </p>
        <p>
          When using federation, downstream nodes can still fail of course.
          If the downstream node is part of a cluster, then links to upstream
          exchanges will be recreated on a surviving node (which node is picked
          at random).
        </p>
        <p>
          Federating clusters requires special attention if you've federated
          the same exchange on two upstreams which are clustered and made the
          federation (internal) queues (on the two upstreams) HA/mirrored.
          Rather than having an upstream set containing connection definitions
          for both upstream nodes, you should aim for just one connection
          (perhaps to an upstream load balancer) otherwise the message ordering
          cannot be preserved!
          RabbitMQ Federation versions >= 3.1 provide explicit support for
          setting multiple upstream URIs, which alleviates the need to proxy the
          upstream cluster as the federation links will handle the failover
          automatically.
        </p>
      </doc:section>
  </body>
</html>
