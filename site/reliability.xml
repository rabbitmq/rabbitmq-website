<?xml-stylesheet type="text/xml" href="page.xsl"?>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:doc="http://www.rabbitmq.com/namespaces/ad-hoc/doc"
      xmlns:x="http://www.rabbitmq.com/2011/extensions">
  <head>
    <title>Reliability Guide</title>
  </head>
  <body show-in-this-page="true">
      <doc:section name="background-info">
        <doc:subsection name="pre-reqs">
          <doc:heading>Pre-requisites and Recommended Reading</doc:heading>
          <p>
            We assume a solid grounding in AMQP concepts and constructs.
            If you're new to AMQP then we recommended you read the
            <a href="/tutorials/amqp-concepts.html">
              RabbitMQ Guide to AMQP Concepts
            </a>,
            <a href="http://www.rabbitmq.com/how.html">How To</a> pages
            and take the time to work through the
            <a href="/getstarted.html">RabbitMQ Tutorials</a>.
          </p>
        </doc:subsection>
      </doc:section>
      <doc:section name="failure-classes">
        <doc:heading>Types of failure</doc:heading>
        <p>
          Network problems are probably the most common class of failure.
          Not only do networks fail, firewalls can interrupt <i>stable but idle</i>
          connections, and network failures are not always detected immediately,
          sometimes taking 15 minutes or more to signal the application.
          In addition to connectivity failures, the broker and producing/consuming
          client applications can crash at any time. Even if client applications
          are able to keep running, logic errors (e.g., queue/exchange objects missing
          on the server, equivalence checks failing during queue/exchange declare, etc)
          can cause channel and/or connection errors which force the client to
          establish a new connection/channel and recover from the problem.
        </p>
      </doc:section>
      <doc:section name="connection-failures">
        <doc:heading>Handling Connection Failures</doc:heading>
        <p>
          Connection failures come in three varieties:
          <ul>
            <li>broken network connections (not always detected immediately)</li>
            <li>closed due to broker shut down</li>
            <li>closed due to <i>connection errors</i></li>
          </ul>
          The client will need to establish a new connection to the broker. Any channels
          opened on the previous connection will have been automatically closed and
          these will need re-opening too.
        </p>
        <p>
          The official Java client provides methods for adding a <code>ShutdownListener</code>
          callback on both connection and channel objects, and the .NET client provides the
          <code>IConnection.ConnectionShutdown</code> and
          <code>IModel.ModelShutdown</code> events for the same purpose.
        </p>
        <h4>Using Heartbeats</h4>
        <p>
          Heartbeats can ensure that disrupted tcp connections get detected promptly.
          They also keep connections alive in the presence of firewalls.
          In both the official Java and .NET clients, heartbeats are enabled by configuring
          the connection factory with the desired heartbeat interval. In RabbitMQ versions 3.0
          and higher, the broker will attempt to negotiate heartbeats by default, though the
          client can still veto them.
        </p>
      </doc:section>
      <doc:section name="acknowledgements">
        <doc:heading>Acknowledgements</doc:heading>
        <p>
          Producers and consumers can take advantage of <code>basic.ack</code>
          to guarantee <i>at-least-once</i> delivery. Without acknowledgements,
          message loss is possible during publish and consume operations and the broker
          guarantees only <i>at-most-once</i> delivery to consumers.
        </p>
        <p>
          A <code>basic.ack</code> signals both the reciept of a message,
          and a transfer of ownership wherein the acknowledging party assumes full
          responsibility for it. With acknowledgements enabled, the broker will never
          dequeue a message until it has seen a <code>basic.ack</code>, providing a
          strong guarantee against message loss.         
        </p>
      </doc:section>
      <doc:section name="tx-and-confirms">
        <doc:heading>Transactions and Producer Confirms</doc:heading>
        <p>
          Transactional channels guarantee that on commit, the broker will assume full
          responsibility for all received messages before sending <code>commit-ok</code>
          to the client.
          AMQP transactions provide atomicity only in a single queue, however in RabbitMQ,
          transactions are <em>not</em> atomic even in a single queue.
          A fault during <code>tx.commit</code> can result in a sub-set of publishes
          appearing in the queue after a restart. If the <code>tx.commit-ok</code> is
          received however, Rabbit guarantees that all messages were either placed
          in a queue, or a <code>basic.return</code> was issued for them already. With
          persistent messages, the broker guarantees the messages are on disk and <code>fsync</code>
          has been invoked to synchronise the file system.
        </p>
        <p>
          Transactions have a significant impact on performance. Producer/publisher confirms
          offer a lightweight alternative that guarantees <i>at-least-once</i> delivery, but
          with far superiour performance. With confirms enabled on a channel, the producer will
          receive a <code>basic.ack</code> once one of the following holds:
          <ul>
            <li>an un-routable mandatory message is confirmed
              right after the <code>basic.return</code> is sent</li>
            <li>a transient message is confirmed the moment it is enqueued</li>
            <li>a persistent message is confirmed when it is persisted to disk
              or when it is consumed on every queue</li>
          </ul>
          Once a <code>basic.ack</code> arrives, the broker has taken full
          responsibility for the message(s). In particular, for a persistent message,
          Rabbit guarantees that a full fsync to the filesystem takes place
          before sending the <code>basic.ack</code>, ensuring that all I/O
          buffers have been flushed to disk properly. When queues are mirrored, the
          broker guarnatees all mirrors have seen the message before sending the
          acknowledgement.
        </p>
        <p>
          Despite confirms exhibiting better performance characteristics than
          transactions, there is still a cost associated with forcing an
          <code>fsync</code> to the disk, which will reduce throughput. Network
          latency also plays a role here, as the client waits for <code>confirm-ok</code>
          to be sent back by the broker. These costs can be reduced by batching
          confirms (i.e., only waiting for confirms after a batch of publishes).
        </p>
        <p>
          Note that if a disk has write caching enabled, even calling <code>fsync</code>
          cannot guarantee that data has actually made it to permanent storage,
          in which case there is a posibility of message loss in case of server
          (e.g., hardware) failure.
        </p>
      </doc:section>
      <doc:section name="at-the-broker">
        <doc:heading>Durability and Persistence</doc:heading>
        <p>
          RabbitMQ implements a number of features to handle server restarts
          without data loss. The AMQP standard has a notion of durability
          (or persistence) for Exchanges, Queues and Messages: for each, this
          implies the specified object will survive a restart.
          More details about specific flags pertaining to durability and
          persistence can be found in the
          <a href="/tutorials/amqp-concepts.html">AMQP Concepts Guide</a>.
        </p>
      </doc:section>
      <doc:section name="clustering-and-ha">
        <doc:heading>Clustering and High Availability</doc:heading>
        <p>
          In a RabbitMQ cluster, all definitions (of queues, exchanges, bindings, users, etc)
          are mirrored across the entire cluster with full atomic guarantees.
          Queues behave a little diferently from other objects, residing only on the node that
          creates them, though they remain visible and reachable from all nodes.
          Nodes can join and leave a cluster dynamically at runtime and can opt
          to maintain thier state in memory only, or to store it additionally on the disc as
          well. A RAM only node will loose all its state after a restart (or failure).
          At least one disk node should be running at all times to prevent data loss. If you
          stop and forcefully resetting all disc nodes in a cluster, data loss is quite likely. 
        </p>
        <h4>Working with HA/Mirrored Queues</h4>
        <p>
          Mirrored queues replicate queue contents across all configured slave nodes,
          tolerating node failures seamlessly and without message loss in most circumstances.
          As long as producers use channels in confirm mode and persistent messages, data
          integrity is <em>very</em> high.
          One area where message loss can occur however, is when a master fails and the
          eldest slave is not fully synchronised. Since RabbitMQ 3.1 it is possible to
          use <em>eager synchronisation</em> to guard against this possibility.
          Another consideration is that consuming from a mirrored-queue with noAck=true
          can always lead to message loss, regardless of enabling HA.
        </p>
      </doc:section>
      <doc:section name="producer-connectivity-failures">
        <doc:heading>Producer Connectivity Failures and Un-routable Messages</doc:heading>
        <p>
          With a channel set to <code>confirm</code> mode, a producer can handle connection
          failures by retransmitting any messages that have no been confirmed by the broker.
          It is possible that messages will be duplicated when doing so, because the broker
          might have sent a confirmation that never reached the producer (due to network
          failures, etc). Consumer applications will need to handle de-duplicating in this
          case; The <code>message-id</code> property can be used to convey an application
          specific unique identifier if required.
        </p>
        <h4>Handling un-routable messages</h4>
        <p>
          A simple solution to avoiding un-routable messages is to delcare the queue in the
          producer. When this is not possible, AMQP provides a neat recipe for detecting situations
          in which a published message cannot be routed. When the <code>mandatory</code> flag is
          set on a <code>basic.publish</code> which cannot be routed by the broker, a
          <code>basic.return</code>, containing a reply code and textual explanation will be sent back
          to the client.
        </p>
      </doc:section>
      <doc:section name="consumer-connectivity-failures">
        <doc:heading>Consumer Connectivity Failures and Unhandled Messages</doc:heading>
        <p>
          In the event of a network failure (or a node crashing), consumers must be able to
          code with duplicated messages - RabbitMQ guarantees <em>at-least-once</em> delivery,
          not <em>exactly-once</em>. The client may utilise the <code>redelivered</code> flag
          if it is set on <code>basic.deliver</code>, but should not rely solely on this to
          determine whether or not it has seen a message before. Instead, clients are encouraged
          to utilise application specific identifiers (passed either in the <code>message-id</code>
          or some other custom header) to identify duplicates.
          Some clients may prefer to make message handling idempotent rather than explicitly deal
          with de-duplicating inbound messages.
        </p>
        <h4>Consumer Cancel Notifications</h4>
        <p>
          A RabbitMQ extension to AMQP, consumer cancel notifications enable clients to detect
          error conditions that would otherwise go unnoticed.
          For clients that support the extension, a <code>basic.cancel</code> will be
          sent if a queue from which the client is consuming is deleted, or in a clustered
          scenario, if the node on which the queue is located fails. In the case where a master
          fails, the promoted slave considers all previous consumers to have been abruptly disconnected
          and summarily requeues all messages that are still pending ACKs. Clients connected to a surviving
          node which are using Consumer Cancel Notifications should treat the notification that their
          subscription to the mirrored-queue has been abruptly cancelled as a signal that they should
          be prepared to handle duplicate messages if necessary.
        </p>
      </doc:section>
  </body>
</html>

