<?xml-stylesheet type="text/xml" href="page.xsl"?>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:doc="http://www.rabbitmq.com/namespaces/ad-hoc/doc"
      xmlns:x="http://www.rabbitmq.com/2011/extensions">
  <head>
    <title>Reliability Guide</title>
  </head>
  <body show-in-this-page="true">
      <doc:section name="overview">
        <p>
          Learn how the different levels of message delivery guarantee
          in RabbitMQ work, the trade-offs available and how they can
          affect the system.
        </p>
      </doc:section>
      <doc:section name="background-info">
        <doc:heading>Pre-requisites and Recommended Reading</doc:heading>
        <p>
          We assume a solid grounding in AMQP concepts and constructs.
          If you're new to AMQP then we recommended you read the
          <a href="/tutorials/amqp-concepts.html">
            RabbitMQ Guide to AMQP Concepts
          </a>,
          <a href="http://www.rabbitmq.com/how.html">How To</a> pages
          and take the time to work through the
          <a href="/getstarted.html">RabbitMQ Tutorials</a>.
        </p>
      </doc:section>
      <doc:section name="concepts">
        <doc:subsection name="durability">
          <doc:heading>Durability and Persistence</doc:heading>
          <p>
            RabbitMQ implements a number of features to handle server restarts
            without data loss. The AMQP standard has a notion of durability
            (or persistence) for Exchanges, Queues and Messages. In essense, this
            attribute has the same meaning for each: that the specified object
            will survive a restart of the broker. Whether a broker restart was
            deliberate or due to a node failure; The outcome is intended to be the
            same regardless of the reason the node fails. For queues and exchanges,
            when the <code>durable</code> flag is set upon sending the initial
            <code>queue.declare</code> or <code>exchange.declare</code> method to
            the server, the standard requires that these objects continue to
            exist after a server restart. For messages sent with the <code>delivery-mode</code>
            set to <i>persistent</i>, the standard requires the broker to
            "<i>make a best-effort to hold persistent basic messages on a reliable
            storage mechanism</i>."
          </p>
          <p>
            More details about specific flags pertaining to durability and
            persistence can be found in the
            <a href="/tutorials/amqp-concepts.html">AMQP Concepts Guide</a>.
          </p>
          <p>
            Due to the primarily asynchronous nature of AMQP, whilst a
            <code>{queue|exchange}.declare</code> command is on the wire,
            there is no way of knowing if the server has fulfilled the request
            until a <code>declare-ok</code> reply is received. Once this has
            arrived at the client, we can then be certain that the object
            exists and will be maintained by the broker accordingly.
            The AMQP declare method for both the exchange and queue classes is a
            declarative command. If the queue/exchange already exists, then we
            still receive <code>declare-ok</code> providing that the arguments
            given for subsequent invocations of this method are the same. As the
            spec puts it, this method will "verify the exchange exists, create
            if needed." When writing clients it is, therefore, reasonable to declare
            exchanges/queues when the applications first connects to the broker.
            This operation will only fail if the object declaration fails the
            equivalence check; See the
            <a href="/amqp-0-9-1-reference.html">AMQP Reference</a> and RabbitMQ's
            <a href="/amqp-0-9-1-errata.html">list of AMQP 0-9-1 errata</a> for
            more details.
          </p>
          <h4>Handling Server Errors</h4>
          <p>
            If a <code>{queue|exchange}.declare</code> is rejected by the server,
            a channel error will be raised. Client libraries will represent this
            using whichever mechanism makes sense for the target language/platform.
            If the client library does not implement <code>{queue|exchange}.declare</code>
            synchronously, it is sensible  to wait for the relevant
            <code>declare-ok</code> reply before proceeding to use an object.
          </p>
          <h4>Persistent Messages</h4>
          <p>
            When messages are marked as persistent, the broker is responsible
            for ensuring that they are safely held in stable storage once fully
            received. As an optimisation, the broker <em>might not persist
            a message if it can be delivered immediately</em> to a consumer,
            however messages will not be discarded even in this case, until
            an acknowledgement has been received.
          </p>
        </doc:subsection>
        <doc:subsection name="connectivity">
          <doc:heading>Connectivity</doc:heading>
          <p>
            Connection failures can occur at any time. When a graceful shutdown occurs,
            clients will recieve a <code>connection.close</code> message from the broker.
            Under other circumstances, the connection may be abbruptly terminated once
            the operating system networking stack detects that the peer socket is non-responsive.
            Certain classes of server error can also lead to a <code>connection-error</code>.
            Errors on a connection (where the error code is in the >500 range) will cause
            the broker to close the connection.
          </p>
          <p>
            If a connection terminates for <i>any</i> reason, then it is up to
            the client to re-establish connectivity in order to continue sending
            or receiving messages. Remember, once a connection is torn down, all
            its channels will disappear: any client code relying on these channels
            will need to create new channels once a new connection is established.
          </p>  
          <p>
            Client libraries may take various approaches to signalling channel and
            connection errors. The official Java client provides methods for adding
            a <code>ShutdownListener</code> callback on both connection and channel
            objects, and the .NET client provides the
            <code>IConnection.ConnectionShutdown</code> and
            <code>IModel.ModelShutdown</code> events for detecting connection and
            channel errors respectively.
          </p>
          <p>
            Because of the declarative nature of queue and exchange creation, after
            a connection to the broker is re-established, it is quite safe to issue
            <code>{queue|exchange}.declare</code> for objects your application expects
            to be working with, as long as the parameters passed with the declaration
            have not changed since they were first supplied.
          </p>
          <h4>Using Heartbeats</h4>
          <p>
            When the network does fail, it can take the Operating System a fairly long
            time to notice and pass this information on to running applications.
            For example, on Linux based systems, the default kernel parameters yield
            a potential delay of around 15 minutes after the first retransmission timeout.
            To disuade an application from waiting quite so long, we can enable AMQP
            heartbeats and set a lower threshold for connection timeouts. This has an
            added advantage over straight TCP keep-alives, in that both the broker and
            the client become aware of the connection failure, allowing both to reclaim
            valuable operating system resources in a timely fashion.
          </p>
          <p>
            In both the official Java and .NET clients, heartbeats are enabled by configuring
            the connection factory with the desired heartbeat interval. As with any other
            connection failure, the client may attempt to re-connect and re-establish new
            channels at any time.
          </p>
          <h4>Consumer Cancel Notifications</h4>
          <p>
            A RabbitMQ extension to the AMQP spec, consumer cancel notifications enable
            clients to detect error conditions that would otherwise go unnoticed. Whilst
            this class of errors are not directly related to <em>network connectivity</em>
            between client and server, they do represent a break in the usefulness of a
            client's subscription on the current channel.
          </p>
          <p>
            For clients that support this extension, a <code>basic.cancel</code> will be
            sent if a queue from which the client is consuming is deleted, or in a clustered
            scenario, if the node on which the queue is located fails. This notification is
            particularly useful when consuming mirrored queues, which is covered later on.
          </p>
        </doc:subsection>
      </doc:section>
      <doc:section name="robust-data-flow">
          <doc:heading>Transferring Responsibility from Producer to Broker</doc:heading>
          <p>
            How can a producer application ensure that all operations are
            safely transferred to the broker in the face of server errors,
            connection failure, missing or incorrect object definitions,
            application logic errors and potential client failures?
          </p>
          <h4>Durable Entities</h4>
          <p>
            When a queue is declared as <code>exclusive</code>, it can only be
            accessed by the connection with which it was declared. Since we
            know that the connection could break at any time, if the loss of
            a queue (and the messages it contains) is unacceptable, then we
            should avoid making it <code>exclusive</code>. Since the computer
            on which the broker is running could potentially crash at any time,
            to avoid data loss we must also ensure that the queue is
            <code>durable</code>.
          </p>
          <h4>Acknowledgements</h4>
          <p>
            From the producer's perspective, the only way to guarantee that a
            message isn't lost is by using transactions. A broker failure
            after publication but before the message is persisted to disk and
            the file system synchronised can cause message loss. Transactions
            eliminate the risk of this happening, because the commit-ok reply
            is only sent to the client once those steps have been completed.
            Transactions however, are quite heavy for this purpose and come
            with a significant cost to performance. To address this, RabbitMQ
            added an extension to the AMQP standard called confirms (aka
            publisher or producer confirms). Confirms are a lightweight
            alternative to transactions, which ensure the same guarantees
            with regards message publication, but offer far superiour performance.
            Confirms are enabled by sending <code>confirm-select</code> on an
            open channel. Once the broker responds with <code>confirm-ok</code>
            then the channel is said to be <i>in confirm mode</i>.
          </p>
          <p>
            With confirms enabled, once a message is sent to the broker, the producer
            will receive a <code>basic.ack</code> once one of the following conditions
            holds:
            <ul>
              <li>an un-routable mandatory message is confirmed
              right after the <code>basic.return</code> is sent</li>
              <li>a transient message is confirmed the moment it is enqueued</li>
              <li>a persistent message is confirmed when it is persisted to disk
              or when it is consumed on every queue</li>
            </ul>
            Once a <code>basic.ack</code> arrives, the message is <em>confirmed</em>
            and the publisher can be assured that the broker has taken full
            responsibility for it. In particular, for a persistent message, the
            broker ensures that a full fsync to the filesystem takes place
            before sending the <code>basic.ack</code>, ensuring that all I/O
            buffers have been flushed to disk properly.
          </p>
          <p>
            If a <code>basic.nack</code> is received on a producer channel set to
            confirms mode, the broker is indicating that it could not handle the
            message. In this case, the producer should retransmit the message.
          </p>
          <h4>Handling Lost ACKs</h4>
          <p>
            Whilst producer confirms provide stronger guarantees, it is still possible
            for a network failure to cause clients difficulties, sometimes even resulting
            in message loss.
            If one or more messages have been sent and the producer is waiting for ACKs
            (i.e., confirms) from the broker and a network error occurs, upon which the
            connection is broken, forcing the producer to re-connect. Having not seen an 
            ACK for these messages, we must re-transmit them, however it is <em>possible</em>
            that the broker did receive them <b>and</b> sent ACKs for some (or all), but all those
            ACKs en-route to the producer were lost due to the network failure. The producer
            has no choice but to re-transmit the messages, and it will be necessary for
            consumers to handle potential duplicates somehow. The application can utilise
            the AMQP Basic <code>message-id</code> field to assist with this, or use a custom
            header if the <code>shortstr</code> data type is not suitable for the application's
            purposes. Responsibility for de-duplicating messages with the same application
            specific message-id belongs with the consumer, i.e., you will have to write this
            logic yourself, based on your application's requirements.
          </p>
          <h4>Handling un-routable messages</h4>
          <p>
            AMQP provides a neat recipe for detecting situations in which a published
            message cannot be routed. When the <code>mandatory</code> flag is set on a
            <code>basic.publish</code> which cannot be routed by the broker, a
            <code>basic.return</code>, containing a reply code and textual explanation
            will be sent back to the client.
          </p>
      </doc:section>
      <doc:section name="broker-2-consumer">
        <doc:subsection name="reliable-clients">
          <doc:heading>Transfered Responsibility from Broker to Consumer</doc:heading>
          <p>
            All clients need to be prepared to handle error conditions at runtime.
            Failures can occur at various points between client and server, each of which
            requires special handling by the application developer.
          </p>
          <p>
            Consumers should be particularly aware of the effect that ACKs have on
            message consuption. Once an ACK is sent, the broker will remove the message
            from the queue, and the consumer (which ACKed the message) is not <em>fully</em>
            responsible for it. If the consumer crashes before sending an ACK, the message
            will be redelivered to another consumer as one becomes available. If the
            <code>basic.qos</code> prefetch count is set, then however many unacknowledged
            message the consumer holds, these will all be subject to the same treatment.
          </p>
          <h4>Handling lost ACKs and requesting re-delivery</h4>
          <p>
            Consumers should always be ready to handle duplicate messages, even those for
            which they have sent acknowledgements. It's possible for a consumer to send a
            <code>basic.ack</code> and the network to fail such that the ACK is not delivered.
            It is also possible for ACKs to be lost in a clustered HA configuration, when the
            node on which a queue is located fails. In this case, a promoted slave will
            requeues all messages which it considers to be pending acknowledgements, which can
            include messages for which a client has issued an ACK if the acknowledgement was
            lost on the wire before reaching the master or lost during broadcast from the master
            to the slaves.
          </p>
          <p>
            When network failures occur, clients will need to re-connect and re-establish channels.
            The same is true for clients connected to a failed node in a clustered configuration,
            who will need to connect to a surviving node in the cluster. Once connections and
            channels are re-established, if consuming from the same queue (or an HA queue that has
            failed over to a slave node), it's quite possible you will subsequently receive messages
            that have been seen previously due to lost ACKs.
          </p>
          <h4>Client Recovery</h4>
          <p>
            <code>basic.recover</code>
            
            Clients must be aware that
            attempting to acknowledge a message on a different channel from the one it was
            received on will fail.
          </p>
          TODO: waitForConfirms and batching
          TODO: storing and sequencing in producer code
          TODO: handling duplicates in consumer code
          TODO: handling errors with ShutdownListener (+ non-java examples?)
          TODO: dealing with reject
          TODO: consumer-cancel

        </doc:subsection>
        <doc:subsection name="failover-and-recovery">
          <doc:heading>Failover and Recovery</doc:heading>
        </doc:subsection>
      </doc:secion>
      <doc:section name="distributed">
        <doc:heading>Distributed RabbitMQ</doc:heading>
        <h4>Working with HA/Mirrored Queues</h4>
        <p>
          Utilising RabbitMQ's robust HA/Mirrored queues, we can tolerate node failures
          without message loss in most circumstances. As long as producers use channels
          in confirm mode and persistent messages, data integrity is <em>very</em> high.
          One area where message loss can occur however, is when a master fails and the
          eldest slave is not fully synchronised. There's little to be done about this.

          If you are consuming from a mirrored-queue with noAck=true then messages can
          always be lost, regardless of enabling HA.

          TODO: erm, is that all we say about this!? Is there anything else!? Should we
          offer ideas about ensuring slaves are sync-ed up? In the face of policy driven
          HA, that probably makes no sense.
        </p>
        <p>
          Consumers must still be ready to handle duplicate messages when using HA queues,
          despite the fact that clustering/HA shoots for consistency and availability from
          the CAP theorem.
          In the case where a master fails, the promoted slave considers all previous consumers
          to have been abruptly disconnected and summarily requeues all messages that are
          still pending ACKs. Clients using Rabbit's Consumer Cancel Notification extension
          will receive a notification that their subscription to the mirrored-queue has
          been abruptly cancelled.
        </p>
        <h4>Federated RabbitMQ</h4>
        <p>
          When consuming from a queue bound to a federated exchange, message loss will not
          occur providing the configuration is not using <code>noAck</code> mode. Downstream
          nodes can still fail of course. If the downstream node is part of a cluster, then
          links to upstream exchanges will be recreated on a surviving node.
        </p>
        <p>
          If you've federated the same exchange on two upstreams which are clustered and
          made the federation (internal) queues (on the two upstreams) HA/mirrored, then
          rather than having an upstream set containing connection definitions for both
          upstream nodes, you should aim for just one connection (perhaps to an upstream
          load balancer) otherwise the order of messages cannot be preserved!
        </p>
        <p>
          TODO: the docs say: " If a node fails, links to upstream exchanges will be recreated on a surviving node. "
          clarify that - which node, how is it chosen?
          
        </p>
      </doc:section>
  </body>
</html>

