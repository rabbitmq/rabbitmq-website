<?xml-stylesheet type="text/xml" href="page.xsl"?>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:doc="http://www.rabbitmq.com/namespaces/ad-hoc/doc"
      xmlns:x="http://www.rabbitmq.com/2011/extensions">
  <head>
    <title>Reliability Guide</title>
  </head>
  <body show-in-this-page="true">
      <doc:section name="overview">
        <p>
          Learn how the different levels of message delivery guarantee
          in RabbitMQ work, the trade-offs available and how they can
          affect the system.
        </p>
      </doc:section>
      <doc:section name="background-info">
        <doc:heading>Pre-requisites and Recommended Reading</doc:heading>
        <p>
          We assume a solid grounding in AMQP concepts and constructs.
          If you're new to AMQP then we recommended you read the
          <a href="/tutorials/amqp-concepts.html">
            RabbitMQ Guide to AMQP Concepts
          </a>,
          <a href="http://www.rabbitmq.com/how.html">How To</a> pages
          and take the time to work through the
          <a href="/getstarted.html">RabbitMQ Tutorials</a>.
        </p>
      </doc:section>
      <doc:section name="concepts">
        <doc:subsection name="durability">
          <doc:heading>Durability and Persistence</doc:heading>
          <p>
            RabbitMQ implements a number of features to handle server restarts
            without data loss.
            The AMQP standard has a notion of durability (or persistence) for
            Exchanges, Queues and Messages. In essense this attribute has the
            same meaning for each: that the specified object will survive a
            restart of the broker. Whether a broker restart was deliberate (e.g.,
            a controlled restart issued via <code>rabbitmqctl stop</code> or some
            operating system supplied interface to the broker) or due to a node
            failure; The outcome is intended to be the same regardless of the
            reason the node fails. For queues and exchanges, when the
            <code>durable</code> flag is set upon sending the initial
            <code>queue.declare</code> or <code>exchange.declare</code> method to
            the server, the standard requires that these objects continue to
            be available after a server restart. For messages sent with the
            <code>delivery-mode</code> set to <i>persistent</i>, the standard
            requires the broker to
            "<i>make a best-effort to hold persistent basic messages on
            a reliable storage mechanism</i>."
          </p>
          <p>
            More details about specific flags pertaining to durability and
            persistence can be found in the
            <a href="/tutorials/amqp-concepts.html">AMQP Concepts Guide</a>.
          </p>
          <p>
            Due to the primarily asynchronous nature of AMQP, whilst a
            <code>{queue,exchange}.declare</code> command is on the wire,
            there is no way of knowing if the server has fulfilled the request
            until a <code>declare-ok</code> reply is received. Once this has
            arrived at the client, we can then be certain that the object
            exists and will be maintained by the broker accordingly.
            The AMQP declare method for both the exchange and queue classes is a
            declarative command. If the queue/exchange already exists, then we
            still receive <code>declare-ok</code> providing that the arguments
            given for subsequent invocations of this method are the same. As the
            spec puts it, this method will "verify the exchange exists, create
            if needed." The obvious solution to writing clients is, therefore,
            to declare exchanges/queues when the applications first connects to
            the broker. This operation will only fail if the object declaration
            fails the equivalence check; See the
            <a href="/amqp-0-9-1-reference.html">AMQP Reference</a> and RabbitMQ's
            <a href="/amqp-0-9-1-errata.html">list of AMQP 0-9-1 errata</a> for
            more details.
          </p>
          <h4>Handling Server Errors</h4>
          <p>
            If a <code>{queue|exchange}.declare</code> is rejected by the server,
            a channel error will be raised. Client libraries will represent this
            using whichever mechanism makes sense for the target language/platform.
          </p>
          <p>
            TODO: <em>passive declarations</em>
          </p>
          <h4>Handling Connection Failures</h4>
          <p>
            Connectivity between the client and server can fail at any time. We
            do not find out about failures immediately, unless the client is
            put into a blocking receive pending a response from the server. Even
            then, the timing of connection error notifications is not guaranteed,
            as we will see later on. If the client library does not implement
            <code>{queue|exchange}.declare</code> synchronously, it is sensible
            to wait for the relevant <code>declare-ok</code> reply before
            proceeding to use an object.
          </p>
          <h4>Persistent Messages</h4>
          <p>
            When messages are marked as persistent, the broker is responsible
            for ensuring that they are safely held in stable storage once fully
            received. As an optimisation, the broker <em>might not persist
            a message if it can be delivered immediately</em> to a consumer,
            however messages will not be discarded even in this case, until
            an acknowledgement has been received.
          </p>
          <p>
            From the producer's perspective, the only way to guarantee that a
            message isn't lost is by using transactions. A broker failure
            after publication but before the message is persisted to disk and
            the file system synchronised can cause message loss. Transactions
            eliminate the risk of this happening, because the commit-ok reply
            is only sent to the client once those steps have been completed.
            Transactions however, are quite heavy for this purpose and come
            with a significant cost to performance. To address this, RabbitMQ
            added an extension to the AMQP standard called confirms (aka
            publisher or producer confirms). Confirms are a lightweight
            alternative to transactions, which ensure the same guarantees
            with regards message publication, but offer far superiour performance.
            Confirms are enabled by sending <code>confirm-select</code> on an
            open channel. Once the broker responds with <code>confirm-ok</code>
            then the channel is said to be <i>in confirm mode</i>. A transactional
            channel cannot be set to confirm mode, nor can a channel on which
            confirms are enabled be made transactional - the two options are
            mutually exclusive.
          </p>
          <p>
            How then, do confirms enable producers to transfer responsibility for
            messages to the broker? Once a message is sent to the
            broker, the producer will receive a <code>basic.ack</code> once one
            of the following conditions holds:
            <ul>
              <li>an un-routable mandatory message is confirmed
              right after the <code>basic.return</code> is sent</li>
              <li>a transient message is confirmed the moment it is enqueued</li>
              <li>a persistent message is confirmed when it is persisted to disk
              or when it is consumed on every queue</li>
            </ul>
            Once the <code>basic.ack</code> arrives, the message is <em>confirmed</em>
            and the publisher can be assured that the broker has taken full
            responsibility for it. In particular, for a persistent message, the
            broker ensures that a full fsync of the filesystem takes place
            before sending the <code>basic.ack</code>, ensuring that all I/O
            buffers have been flushed to disk properly.
          </p>
        </doc:subsection>
        <doc:subsection name="connectivity">
          <doc:heading>Working with unreliable networks.</doc:heading>
          <p>
            <a href="http://en.wikipedia.org/wiki/Murphy%27s_law">Murphy's Law</a>
            is in full effect whenever communication between networked computers
            happens. Modern networking infrastructure is incredibly complex and
            yet intermittent delays and even complete failures are not at all
            uncommon. Network problems are complex and varied, therefore we will
            not manage to cover all the posibilities here. Instead we will focus
            on the two most common classes of error that are seen in practise:
            connection failures and unexpected delays.
          </p>
          <p>
            Connection failure can occur at any time. Whenever a RabbitMQ node
            is terminated for example, all client connections will be shut down.
            If the shutdown is graceful then the client will recieve a
            <code>connection.close</code> message from the broker. If not, then
            the connection may be abbruptly terminated once the operating system
            on which the client appliation is running, notices that the peer
            socket is non-responsive. Certain classes of server error can also
            lead to a <code>connection-error</code>. Errors on a connection
            (where the error code is in the >500 range) will cause the broker
            to close the connection.
          </p>
          <p>
            Clients are responsible for maintaining their connection to the broker
            at all times. If the connection terminates for <i>any</i> reason,
            then it is up to the client to re-establish a connection in order to
            continue sending or receiving messages. It is important to understand
            that, once a connection is torn down, all its channels are removed
            also and therefore any client code relying on them must create new
            channels once another connection has been established.

            TODO: cover these points

            - channel errors
            - reconnecting 
            - re-sending
            - delays and timeouts
          </p>
          TODO: reconnection logic and rabbitmq-ha-client (on github) as an example
        </doc:subsection>
        <doc:subsection name="reliable-clients">
          <doc:heading>Writing reliable client code</doc:heading>
          <p>
            Clients, both producing and consumer, need to handle various error
            conditions at runtime. Failures can occur at various points between
            client and server, each of which requires special handling by the
            application developer.
          </p>
          TODO: waitForConfirms and batching
          TODO: storing and sequencing in producer code
          TODO: handling duplicates in consumer code
          TODO: handling errors with ShutdownListener (+ non-java examples?)
          TODO: dealing with reject
          TODO: consumer-cancel
        </doc:subsection>
        <doc:subsection name="failover-and-recovery">
          <doc:heading>Failover and Recovery</doc:heading>
        </doc:subsection>
      </doc:section>
      <doc:section name="robust-data-flow">
        <doc:heading>Robust Data Flow</doc:heading>
        <div>
          <ul>
            <li><a href="#producer-to-broker">From Producer to Broker</a></li>
            <li><a href="#broker-to-consumer">From Broker to Consumer</a></li>
          </ul>          
        </div>
        <doc:subsection name="producer-to-broker">
          <doc:heading>Transferring Responsibility from Producer to Broker</doc:heading>
          <p>
            How can a producer application ensure that all operations are
            safely transferred to the broker in the face of server errors,
            connection failure, missing or incorrect object definitions,
            application logic errors and potential client failures?
          </p>
          <h4>The role of Durable Entities</h4>
          <p>
            When a queue is declared as <code>exclusive</code>, it can only be
            accessed by the connection with which it was declared. Since we
            know that the connection could break at any time, if the loss of
            a queue (and the messages it contains) is unacceptable, then we
            should avoid making it <code>exclusive</code>. We also know that the
            computer on which the broker is running could potentially crash at
            any time, therefore if we want to avoid data loss in this scenario
            we must ensure that the queue is also <code>durable</code>.
          </p>
          <p>
            Because exchanges do not store messages, 
          </p>
        </doc:subsection>
      </doc:section>
      <doc:section name="distributed">
        <doc:heading>Distributed RabbitMQ</doc:heading>
        TODO: when you've federated the same exchange on two upstreams 
             which are clustered and made the federation (internal) queues
             (on the two upstreams) HA/mirrored - Rather than having an upstream
             set containing connection definitions for both upstream nodes,
             have just one connection definition, to an upstream load balancer
             otherwise the order of messages cannot be preserved.
      </doc:section>
  </body>
</html>

