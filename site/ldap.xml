<?xml-stylesheet type="text/xml" href="page.xsl"?>
<!DOCTYPE html [
<!ENTITY % entities SYSTEM "rabbit.ent" >
%entities;
]>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:doc="http://www.rabbitmq.com/namespaces/ad-hoc/doc"
      xmlns:x="http://www.rabbitmq.com/2011/extensions">
  <head>
    <title>LDAP Plugin</title>
  </head>
  <body show-in-this-page="true">
    <doc:section name="overview">
      <p>
        The LDAP plugin provides the ability for your RabbitMQ server to
        perform authentication (determining who can log in) and
        authorisation (determining what permissions they have) by deferring
        to an external LDAP server. To use this plugin, some editing of the
        RabbitMQ configuration file is required. You must enable the plugin,
        and then configure it. You are advised to read this entire page
        before starting.
      </p>

      <p>
        The LDAP plugin is included in the RabbitMQ distribution. To
        enable it, use
        <a href="man/rabbitmq-plugins.1.man.html">rabbitmq-plugins</a>:
      </p>
      <pre class="example">rabbitmq-plugins enable rabbitmq_auth_backend_ldap</pre>
      <p>
        You will then need to set the value of the <code>auth_backends</code>
        configuration item for the <code>rabbit</code> application to include
        <code>rabbit_auth_backend_ldap</code>.  <code>auth_backends</code> is
        a list of authentication providers to try in order.
      </p>
    </doc:section>

    <doc:section name="basic">
      <doc:heading>Basic configuration</doc:heading>
      <p>
        You must then configure the plugin. This plugin has quite a few
        configuration options, but most have sensible defaults.
      </p>

      <p>
        The most complex part of configuring the plugin pertains to
        authorisation (i.e. granting permissions to your users via LDAP). This
        is documented separately below.
      </p>
      <p>
        The default configuration allows all users to access all objects in
        all vhosts, but does not make them administrators. If you're happy
        with that, there is no need to read the documentation on authorisation.
      </p>
      <p>
        The options not directly related to authorisation are:
      </p>

      <dl>
        <dt><code>servers</code></dt>
        <dd>
          List of LDAP servers to attempt to bind to, in order. You almost
          certainly want to change this. Default: <code>["ldap"]</code>
        </dd>
        <dt><code>user_dn_pattern</code></dt>
        <dd>
          <p>
            There are two ways to convert a username as provided through AMQP to
            a Distinguished Name. The simplest way is via string substitution
            with <code>user_dn_pattern</code>. To do this, set
            <code>user_dn_pattern</code> to a string containing exactly one
            instance of <code>${username}</code>.
          </p>
          <p>
            For example, setting user_dn_pattern to:
            <code>"cn=${username},ou=People,dc=example,dc=com"</code>
          </p>
          <p>
            would cause the username <code>simon</code> to be converted to the
            DN <code>cn=simon,ou=People,dc=example,dc=com</code>
          </p>
          <p>
            Default: <code>"${username}"</code>
          </p>
        </dd>
        <dt><code>dn_lookup_attribute</code> and <code>dn_lookup_base</code></dt>
        <dd>
          <p>
            The other way to convert a username to a Distinguished Name is via
            an LDAP lookup after binding. In order for this to work your LDAP
            server needs to be configured to allow binding with the unadorned
            username (Microsoft Active Directory typically does this).
          </p>
          <p>
            To do this, set dn_lookup_attribute to the name of the attribute the
            represents the user name, and dn_lookup_base to the base DN for the
            query.
          </p>
          <p>
            For example, if I set
          </p>
          <pre>{dn_lookup_attribute,   "userPrincipalName"},
{dn_lookup_base,        "DC=vmware,DC=com"}</pre>
          <p>
            I can authenticate as <code>smacmullen@vmware.com</code> and have my
            local Active Directory server return my real DN.
          </p>
          <p>
            Default: <code>'none'</code> and <code>'none'</code>
          </p>
        </dd>
        <dt><code>other_bind</code></dt>
        <dd>
          <p>
            For authentication this plugin binds to the LDAP server as the
            user it is trying to authenticate. This option controls how to
            bind for authorisation queries, and to retrieve the details of a
            user who is logging in without presenting a password (e.g. SASL
            EXTERNAL).
          </p>
          <p>
            This option must either be one of the atoms '<code>as_user</code> or
            <code>anon</code>, or a tuple <code>{UserDN,
            Password}</code>. <code>as_user</code> means to bind as the
            authenticated user.
          </p>
          <p>
            Default: <code>as_user</code>
          </p>
        </dd>
        <dt><code>use_ssl</code></dt>
        <dd>
          Whether to use LDAP over SSL. Uses the same <a href="ssl.html">SSL
          configuration</a> as elsewhere in RabbitMQ. Default:
          <code>false</code>
        </dd>
        <dt><code>port</code></dt>
        <dd>
          Port on which to connect to the LDAP servers. Default:
          <code>389</code>.
        </dd>
        <dt><code>log</code></dt>
        <dd>
          <p>
            Select <code>true</code> for verbose logging of the logic used by
            the LDAP plugin to make decisions. This is typically useful for
            debugging.
          </p>
          <p>
            Select <code>network</code> to <b>additionally</b> cause LDAP
            network traffic to be logged at a somewhat lower level. This will
            typically cause passwords to be written to the logs; exercise
            caution.
          </p>
          <p>
            Default: <code>false</code>
          </p>
        </dd>
      </dl>
    </doc:section>

    <doc:section name="authorisation">
      <doc:heading>Configuring authorisation</doc:heading>
      <p>
        Authorisation is effected by three configuration options:
      </p>
      <ul>
        <li>vhost_access_query</li>
        <li>resource_access_query</li>
        <li>tag_queries</li>
      </ul>
      <p>
        Each defines a query that will determine whether a user has access to
        a vhost, a resource (e.g. exchange, queue, binding) or is considered
        an administrator.
      </p>

      <p>
        The default values are <code>{constant, true}</code>, <code>{constant,
        true}</code> and <code>[{administrator, {constant, false}}]</code>
        respectively, granting all users access to all objects in all vhosts,
        but not making them administrators.
      </p>

      <p>
        A query can be of one of several types, defined below.
      </p>

      <doc:subsection>
        <doc:heading>Constant Query</doc:heading>
        <pre>{constant, Bool}</pre>
        <p>
          This will always return either true or false, unconditionally granting
          or denying access.
        </p>
      </doc:subsection>

      <doc:subsection>
        <doc:heading>Exists Query</doc:heading>
        <pre>{exists, Pattern}</pre>
        <p>
          This will substitute variables into the pattern, and return true if
          there exists an object with the resulting DN. Substitution occurs
          with <code>${}</code> syntax. The <code>vhost_access_query</code> in
          the example configuration below therefore allows you to control
          access to vhosts by controlling the existence of OUs in a vhosts OU.
        </p>
        <p>
          Each of the three queries allow different substitutions:
        </p>

        <p><code>vhost_access_query</code> allows</p>
        <ul>
          <li><code>${username}</code></li>
          <li><code>${user_dn}</code></li>
          <li><code>${vhost}</code></li>
        </ul>

        <p><code>resource_access_query</code> allows</p>
        <ul>
          <li><code>${username}</code></li>
          <li><code>${user_dn}</code></li>
          <li><code>${vhost}</code></li>
          <li><code>${resource}</code> (one of exchange or queue)</li>
          <li><code>${name}</code></li>
          <li><code>${permission}</code> (one of configure, write or read)</li>
        </ul>

        <p>
          The terms configure, write and read for resource access have the
          same meanings that they do for the built-in RabbitMQ permissions
          system, see http://www.rabbitmq.com/access-control.html
        </p>

        <p><code>tag_queries</code> allows</p>
        <ul>
          <li><code>${username}</code></li>
          <li><code>${user_dn}</code></li>
        </ul>

        <p>
          Note that tag_queries consists of a proplist, mapping the name of a
          tag to a query to perform to determine whether or not the user has
          that tag. You must list queries for all tags that you want your users
          to have.
        </p>
      </doc:subsection>

      <doc:subsection>
        <doc:heading>In Group Query</doc:heading>
        <pre>{in_group, Pattern}</pre>
        <pre>{in_group, Pattern, AttributeName}</pre>
        <p>
          Like the Exists Query, substitutes arguments into a pattern to look
          for an object. However, this query returns true if the logged in
          user is a member; checking either against the <code>member</code>
          attribute, or any named attribute.
        </p>
      </doc:subsection>

      <doc:subsection>
        <doc:heading>Match Query</doc:heading>
        <pre>{match, StringSubQuery, RESubQuery}</pre>
        <p>
          Takes a string and a regular expression, and checks that the one
          matches the other. Note that the string and the regular expression are
          both queries in turn.
        </p>
      </doc:subsection>

      <doc:subsection>
        <doc:heading>String Query</doc:heading>
        <pre>{string, Pattern}</pre>
        <p>
          Just substitutes arguments into a string. As this returns a string
          rather than a boolean it should be used within a match query.
        </p>
      </doc:subsection>

      <doc:subsection>
        <doc:heading>Attribute Query</doc:heading>
        <pre>{attribute, DNPattern, AttributeName}</pre>
        <p>
          Returns the value of an attribute of an object retrieved from LDAP. As
          this returns a string rather than a boolean it should be used within a
          match query.
        </p>
      </doc:subsection>

      <doc:subsection>
        <doc:heading>For Query</doc:heading>
        <pre>{for, [{Name, Value, SubQuery}, ...]}</pre>
        <p>
          This allows you to split up a query and handle different cases with
          different subqueries.
        </p>
        <p>
          Options should be a list of three-tuples, with each tuple containing
          a name, value and subquery. The name is the name of a variable
          (i.e. something that would go into a <code>${}</code>
          substitution). The value is a possible value for that variable.
        </p>
        <p>
          So the example:
        </p>

<pre>{resource_access_query,
 {for, [{resource, exchange,
         {for, [{permission, configure,
                 { in_group, "cn=wheel,ou=groups,dc=example,dc=com" }
                },
                {permission, write, {constant, true}},
                {permission, read,  {constant, true}}
               ]}},
        {resource, queue, {constant, true}} ]}}</pre>

        <p>
          would allow members of the <code>wheel</code> group to declare and
          delete exchanges, and allow all users to do everything else.
        </p>
      </doc:subsection>
    </doc:section>
    <doc:section name="example">
      <doc:heading>Example configuration</doc:heading>
<pre>[
  {rabbit, [{auth_backends, [rabbit_auth_backend_ldap]}]},
  {rabbitmq_auth_backend_ldap,
   [ {servers,               ["my-ldap-server"]},
     {user_dn_pattern,       "cn=${username},ou=People,dc=example,dc=com"},
     {vhost_access_query,    {exists,
                              "ou=${vhost},ou=vhosts,dc=example,dc=com"}},
     {resource_access_query,
      {for, [{resource, exchange,
              {for, [
                     %% Only allow "wheel" group to create exchanges
                     {permission, configure,
                      {in_group, "cn=wheel,ou=groups,dc=example,dc=com"}
                     },

                     %% Only allow publishing for people with surnames beginning
                     %% with "Mac"
                     {permission, write,
                      {match, {attribute, "${user_dn}", "sn"}, {string, "^Mac.*"}}
                     },

                     %% Anyone can bind to exchanges
                     {permission, read,  {constant, true}}
                    ]}},
             %% Anyone can do anything with queues
             {resource, queue, {constant, true}} ]}},
     {tag_queries,           [{administrator, {constant, false}}]},
     {use_ssl,               false},
     {port,                  389},
     {log,                   false} ] }
].</pre>
    </doc:section>
  </body>
</html>
