<?xml-stylesheet type="text/xml" href="page.xsl"?>
<!DOCTYPE html [
<!ENTITY % entities SYSTEM "rabbit.ent" >
%entities;
]>
<!--
Copyright (c) 2007-2019 Pivotal Software, Inc.

All rights reserved. This program and the accompanying materials
are made available under the terms of the under the Apache License,
Version 2.0 (the "License”); you may not use this file except in compliance
with the License. You may obtain a copy of the License at

https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:doc="http://www.rabbitmq.com/namespaces/ad-hoc/doc"
      xmlns:x="http://www.rabbitmq.com/2011/extensions">
  <head>
    <title>LDAP Support</title>
  </head>
  <body show-in-this-page="true">
    <doc:section name="overview">
      <doc:heading>Overview</doc:heading>

      <p>
        RabbitMQ can use LDAP to perform <a
        href="/access-control.html">authentication and
        authorisation</a> by deferring to an external LDAP
        server. This functionality is provided by a
        plugin that ships with RabbitMQ but <a href="#enabling-the-plugin">has to be enabled</a>.
        Authentication and authorisation operations are
        translated into <a href="#authorisation">LDAP queries</a> configured
        by the user.
      </p>

      <p>
        <a href="#ldap-operation-flow">LDAP Operation Flow</a> section
        provides a more detailed overview of how the plugin works.
      </p>

      <p>
        The plugin primarily targets OpenLDAP and Microsoft Active Directory. Other
        LDAP v3 implementations should work reasonably well.
      </p>

      <p>
        This guide provides a very brief overview of LDAP terms but generally
        assumes basic familiarity with LDAP. Several beginner-oriented
        LDAP primers are available elsewhere on the Web, for example, <a href="https://www.digitalocean.com/community/tutorials/understanding-the-ldap-protocol-data-hierarchy-and-entry-components">one</a>,
        <a href="https://www.ldap.com/basic-ldap-concepts">two</a>, and the <a href="https://www.ldap.com/glossary-of-ldap-terms">LDAP glossary</a>.
      </p>

      <p>
        This guide covers the <a href="#ldap-operation-flow">LDAP operation flow</a> used by RabbitMQ, how the LDAP model
        <a href="#authorisation">maps to the RabbitMQ permission model</a> and what tools are available
        for <a href="#troubleshooting">troubleshooting</a>.
      </p>
    </doc:section>

    <doc:section name="enabling-the-plugin">
      <doc:heading>Enabling the Plugin</doc:heading>
      <p>
        The LDAP plugin ships with RabbitMQ. To
        enable it, use
        <a href="man/rabbitmq-plugins.8.html">rabbitmq-plugins</a>:
        <pre class="lang-erlang">rabbitmq-plugins enable rabbitmq_auth_backend_ldap</pre>
      </p>
    </doc:section>

    <doc:section name="essential-configuration">
      <doc:heading>Enabling LDAP AuthN and AuthZ backends</doc:heading>

      <p>
        After enabling the plugin it is necessary to configure the node to use it.
        To do so, add <code>rabbit_auth_backend_ldap</code> to the list of <code>auth_backends</code>.
        See the <a href="/access-control.html">Access Control</a> guide for an overview of authentication
        and authorisation backends and how they are used.
      </p>

      <p>
        The following example
        will configure RabbitMQ to <b>only</b> check LDAP for users,
        and ignore the internal database:

<pre class="lang-init">
auth_backends.1 = ldap
</pre>

        The same can be done using the <a href="/configure.html#erlang-term-config-file">classic config format</a>:

<pre class="lang-erlang">
{rabbit, [
  {auth_backends, [rabbit_auth_backend_ldap]}
]}
</pre>
      </p>

      <p>
        The following example will instruct the node to check LDAP first and then fall back to the internal
        database if the user cannot be authenticated through LDAP:
      </p>

<pre class="lang-ini">
auth_backends.1 = ldap
auth_backends.2 = internal
</pre>

          Same example in the <a href="/configure.html#erlang-term-config-file">classic config format</a>:

<pre class="lang-erlang">
{rabbit,[
  {auth_backends, [rabbit_auth_backend_ldap, rabbit_auth_backend_internal]}
]}
</pre>

      <p>
        In example, LDAP will be used for authentication first. If the user is found in LDAP then the
        password will be checked against LDAP and subsequent authorisation
        checks will be performed against the internal database (therefore
        users in LDAP must exist in the internal database as well, but do not
        need a password there). If the user is not found in LDAP then a second
        attempt is made using only the internal database.
      </p>

<pre class="lang-ini">
auth_backends.1.authn = ldap
auth_backends.1.authz = internal
auth_backends.2 = internal
</pre>

          In the <a href="/configure.html#erlang-term-config-file">classic config format</a>:

<pre class="lang-erlang">
{rabbit,[{auth_backends, [{rabbit_auth_backend_ldap, rabbit_auth_backend_internal},
                           rabbit_auth_backend_internal]}]}
</pre>
    </doc:section>

    <doc:section name="basic">
      <doc:heading>Configuration</doc:heading>

      <p>
        Once the plugin is enabled and its backends are wired in, a number of LDAP-specific
        settings must be configured. They include LDAP server list, authentication and
        authorisation settings and more.
      </p>

      <p>
        The default configuration allows all users to access all objects in
        all vhosts, but does not make them administrators. Restricting access is possible
        by configuring LDAP queries.
      </p>

      <doc:subsection name="connectivity">
        <doc:heading>LDAP Servers</doc:heading>

        <p>
          For the plugin to be able to connect to a LDAP server, at least one server hostname or IP address must be configured
          using the `auth_ldap.servers` key. If multiple values are provided,
          List values can be hostnames or IP addresses. This value must be configured. The following
          example configures the plugin to use two LDAP servers. They will be tried
          in order until connection to one of them succeeds:

<pre class="lang-ini">
auth_ldap.servers.1 = ldap.eng.megacorp.local
auth_ldap.servers.2 = 192.168.0.100
</pre>

          The same examples using the classic config format:

<pre class="lang-erlang">
[
  {rabbitmq_auth_backend_ldap, [
    {servers, ["ldap.eng.megacorp.local", "192.168.0.100"]}
  ]}
].
</pre>
        </p>

        <p>
          LDAP servers typically use port <code>389</code> and that's the port the
          LDAP plugin will use by default. <code>auth_ldap.port</code> can be used
          to override this:

<pre class="lang-ini">
auth_ldap.servers.1 = ldap.eng.megacorp.local
auth_ldap.servers.2 = 192.168.0.100

auth_ldap.port      = 6389
</pre>

          The same examples using the classic config format:

<pre class="lang-erlang">
[
  {rabbitmq_auth_backend_ldap, [
    {servers, ["ldap.eng.megacorp.local", "192.168.0.100"]},
    {port,    6389}
  ]}
].
</pre>
        </p>

        <p>
          TCP connections to LDAP servers can be given a timeout using the <code>auth_ldap.timeout</code>
          configuration key:

<pre class="lang-ini">
auth_ldap.servers.1 = ldap.eng.megacorp.local
auth_ldap.servers.2 = 192.168.0.100

# 15 seconds in milliseconds
auth_ldap.timeout   = 15000
</pre>

          The default is `infinity`, or no timeout.
        </p>

        <p>
          LDAP server connections are pooled to avoid excessive connection churn and LDAP server
          load. By default the pool has up to 64 connections. This can be controlled using the
          <code>auth_ldap.connection_pool_size</code> setting:

<pre class="lang-ini">
auth_ldap.servers.1 = ldap.eng.megacorp.local
auth_ldap.servers.2 = 192.168.0.100

auth_ldap.connection_pool_size = 256
</pre>

          Pooled connections without activity are closed after a period of time
          configurable via <code>auth_ldap.idle_timeout</code>, in milliseconds
          or `infinity`:

<pre class="lang-ini">
auth_ldap.servers.1 = ldap.eng.megacorp.local
auth_ldap.servers.2 = 192.168.0.100

auth_ldap.connection_pool_size = 256
# 300 seconds in milliseconds
auth_ldap.idle_timeout = 300000
</pre>

          Values between 120 and 300 seconds are recommended.
        </p>
      </doc:subsection>

      <doc:subsection name="ldap-tls">
        <doc:heading>Using TLS for LDAP Connections</doc:heading>


        <p>
          It is possible to connect to LDAP servers using TLS. To instruct the
          plugin to do so, set the <code>auth_ldap.use_ssl</code> setting to <code>true</code>.
          If StartTLS is used by the LDAP server, use <code>auth_ldap.use_starttls</code> instead.
          Note that those settings are mutually exclusive (cannot be combined).
          Both values default to <code>false</code>.
        </p>

        <p>
          Client side TLS settings are configured using <code>ssl_options</code>, which
          are very similar to <a href="/ssl.html">TLS settings elsewhere in RabbitMQ</a>.
          TLS settings for LDAP connections can only be configured via the advanced config file:

<pre class="lang-ini">
auth_ldap.servers.1 = ldap.eng.megacorp.local
auth_ldap.servers.2 = 192.168.0.100

auth_ldap.use_ssl   = true
</pre>

<pre class="lang-erlang">
[
  {rabbitmq_auth_backend_ldap, [
     {ssl_options, [{cacertfile,"/path/to/testca/cacert.pem"},
                    {certfile,"/path/to/server_certificate.pem"},
                    {keyfile,"/path/to/server_key.pem"},
                    {verify, verify_peer},
                    {fail_if_no_peer_cert, true}]}
   ]}
].
</pre>


          An example that uses both of the above and uses the <a href="/configure.html">classic config format</a>:

<pre class="lang-erlang">
[
  {rabbitmq_auth_backend_ldap, [
     {use_ssl,     true},
     {ssl_options, [{cacertfile, "/path/to/testca/cacert.pem"},
                    {certfile,   "/path/to/server_certificate.pem"},
                    {keyfile,    "/path/to/server_key.pem"},
                    {verify,               verify_peer},
                    {fail_if_no_peer_cert, true}]}
   ]}
].
</pre>
        </p>
      </doc:subsection>



      <doc:subsection name="ldap-essentials-and-terminology">
        <doc:heading>LDAP Essentials and Terminology</doc:heading>

        <p>
          This section covers some basic LDAP terminology used in this document. For an LDAP primer, please
          refer to <a href="https://www.digitalocean.com/community/tutorials/understanding-the-ldap-protocol-data-hierarchy-and-entry-components">this overview</a> by Digital Ocean and the <a href="https://www.ldap.com/glossary-of-ldap-terms">LDAP glossary</a> from ldap.com.
        </p>

        <p>
          <table>
            <thead>
              <td>Term</td>
              <td>Description</td>
            </thead>
            <tr>
              <td>Bind</td>
              <td>LDAP speak for "authentication request".</td>
            </tr>
            <tr>
              <td>Distinguished Name (DN)</td>
              <td>
                A distinguished name is a unique key in an LDAP directory (tree) that identifies an object
                (like a user or a group). The plugin will translate a client-provided username into a
                distinguished name during the authentication stage (see below). One way to think of
                a DN is an absolute file path in a filesystem.
              </td>
            </tr>
            <tr>
              <td>Common Name (CN)</td>
              <td>
                A short identifier of an object in the tree. This identifier will vary between
                object classes (types) in the LDAP database. For example, a person's common name
                will be her full name. A group's common name would be the name of that group.
                One way to think of a CN is a file name in a filesystem.
              </td>
            </tr>
            <tr>
              <td>Attribute</td>
              <td>
                A property of an object (a key-value pair). Think of it as a field of an object in
                an object-oriented programming language.
              </td>
            </tr>
            <tr>
              <td>Object Class</td>
              <td>
                A set of predefined attributes. Think of it as a type (class) in an object-oriented language.
              </td>
            </tr>

            <tr>
              <td>Entry</td>
              <td>
                An LDAP database entity, for example, a person or a
                group. It has an object class associated with it and
                one or more attributes, including a common name.
                Since the entity is located somewhere in the LDAP
                database tree it also must have a distringuished name
                which uniquely identifies it. Entries is what LDAP
                plugin queries use (look up, check for membership,
                compare attributes of and so on). An LDAP database
                must have some entries (typically users, groups) in
                order to be practically useful for RabbitMQ
                authentication and authorisation.
              </td>
            </tr>
          </table>
        </p>
      </doc:subsection>


      <doc:subsection name="ldap-operation-flow">
        <doc:heading>LDAP Operation Flow</doc:heading>

        <p>
          In order to execute an LDAP query the plugin will open a connection to the first
          LDAP server on the list which is reachable. Then, depending on the credential
          configuration it will perform an anonymous bind or a "<a href="https://msdn.microsoft.com/en-us/library/cc223499.aspx">simple bind</a>"
          (authenticate the user with the LDAP server using a username/password pair).
          The credentials used to perform the bind can be derived from the client-provided username
          as explained in the following section.
        </p>

        <p>
          If vhost access query is configured it will be executed next, otherwise vhost access
          is granted unconditionally.
        </p>

        <p>
          At this point the connection can be considered successfully negotiated and established.
          It should be possible to open a channel on it, for example. All further operations
          performed on the connection will execute one of the authorisation queries. For example,
          declaring a queue will execute a resource access query (covered below). Publishing a
          message to a topic exchange will additionally execute a topic access query. Please refer
          to the <a href="/access-control.html">Access Control guide</a> to learn more.
        </p>
      </doc:subsection>


      <doc:subsection name="usernames-and-dns">
        <doc:heading>Usernames and Distinguished Names</doc:heading>

        <p>
          During the simple bind phase, the <code>user_dn_pattern</code> pattern is used to translate
          the provided username into a value to be used for the bind. By default, the pattern
          passes the provided value as-is (i.e. the pattern is <code>${username}</code>). If
          <code>user_bind_pattern</code> is specified, it takes precedence over
          <code>user_dn_pattern</code>. This can be handy if a different <code>user_dn_pattern</code>
          needs to be used during the distinguished name lookup phase. Note that the above does
          not apply to anonymous binds, nor when <code>dn_lookup_bind</code> is not set to
          <code>as_user</code>.
        </p>

        <p>
          Client connections provide usernames which are translated into Distinguished
          Names (DNs) in LDAP.
          There are two ways to do that. The simplest way is via string substitution
          with <code>user_dn_pattern</code>. To use this option, set
          <code>user_dn_pattern</code> to a string containing exactly one
          instance of <code>${username}</code>, a variable that will be
          substituited for the username value provided by the client.
        </p>
        <p>
          For example, setting user_dn_pattern to
          <code>"cn=${username},ou=People,dc=example,dc=com"</code>
          would cause the username <code>simon</code> to be converted to the
          DN <code>cn=simon,ou=People,dc=example,dc=com</code>. Default value is
          <code>"${username}"</code>, in other words, the username is used verbatim.
        </p>

        <p>
          The other way to convert a username to a Distinguished
          Name is via an LDAP lookup. To do this, set
          <code>auth_ldap.dn_lookup_attribute</code> to the name of the
          attribute that represents the user name, and
          <code>auth_ldap.dn_lookup_base</code> to the base DN for the
          query. The lookup can be done at one of two times, either
          before attempting to bind as the user in question, or
          afterwards.
        </p>
        <p>
          To do the lookup after binding, leave
          <code>auth_ldap.dn_lookup_bind</code> set to its default
          of <code>as_user</code>. The LDAP plugin will then bind
          with the user's plain (unmodified) username to do the login, then
          look up its DN. In order for this to work the LDAP server
          needs to be configured to allow binding with the plain
          username (Microsoft Active Directory typically does this).
        </p>
        <p>
          To do the lookup before binding,
          set <code>auth_ldap.dn_lookup_bind</code> to a tuple
          <code>{UserDN, Password}</code>. The LDAP plugin will then bind with
          these credentials first to do the lookup, then bind with
          the user's DN and password to do the login.
        </p>
        <p>
          Consider the following example:
        </p>
        <pre class="lang-ini">
auth_ldap.dn_lookup_attribute = userPrincipalName
auth_ldap.dn_lookup_base = DC=gopivotal,DC=com</pre>
        <p>
          With this configuration it is possible authenticate using an email address
          (<code>userPrincipalName</code> values are typically email addresses)
          and have the local Active Directory server return an actual DN to do
          the login.
        </p>
        <p>
          If both <code>auth_ldap.dn_lookup_attribute</code>
          and <code>auth_ldap.user_dn_pattern</code> are set then the approaches are
          combined: the plugin fills out the template and then
          searches for the DN.
        </p>
        <p>
          <code>auth_ldap.dn_lookup_bind</code>'s default value is <code>as_user</code>.
          For <code>auth_ldap.dn_lookup_base</code> and <code>auth_ldap.dn_lookup_attribute</code>
          it is <code>none</code>.
        </p>
      </doc:subsection>



      <doc:subsection name="logging">
        <doc:heading>LDAP Activity Logging</doc:heading>

        <p>
          The plugin makes it possible to control the verbosity of LDAP activity
          logging using the <code>auth_ldap.log</code>
          (<code>rabbitmq_auth_backend_ldap.log</code> in the classic config format) setting.
          This is essential for troubleshooting.
        </p>
        <p>
          Setting the value to <code>true</code> will enable verbose logging of the logic used by
          the LDAP plugin to make decisions. Credentials in bind request outcomes will be
          scrubbed in this mode. This mode is not recommended for production systems
          but ocassionally can be useful.
        </p>
        <p>
          The value of <code>network</code> works similarly to the above but  <b>additionally</b> causes LDAP
          network traffic to be logged at a lower (LDAP client) level, with bind
          request credentials scrubbed. This setting can result in excessive logging and should be
          used with great care.
        </p>
        <p>
          The value of <code>network_unsafe</code> causes LDAP network traffic to
          be logged at a lower (LDAP client) level, with bind request credentials such as
          passwords, written to the logs; this mode must not be used in production and will violate
          nearly every widely adopted security policy.
          It can, however, be very useful for troubleshooting in development
          and QA environments.
        </p>
        <p>
          Lastly, the value of <code>false</code> (the default) disables LDAP traffic logging.
        </p>

        <p>
          The following examples sets LDAP logging level to <code></code>:

<pre class="lang-ini">
auth_ldap.log = network
</pre>

          The same examples in the classic config format:

<pre class="lang-ini">
[
  {rabbitmq_auth_backend_ldap, [
    %% ...
    {log, network}
  ]}
]
</pre>
        </p>
      </doc:subsection>


      <doc:subsection name="other-bind">
        <doc:heading>Binding for Authorisation Queries</doc:heading>

        <p>
          For authentication this plugin binds to the LDAP server as the
          user it is trying to authenticate. The <code>other_bind</code> setting controls how to
          bind for authorisation queries, and to retrieve the details of a
          user who is logging in without presenting a password (e.g. using the
          <a href="/authentication.html">EXTERNAL authentication mechanism</a>).
        </p>
        <p>
          The accepted values are <code>as_user</code> (to bind as the authenticated
          user) or <code>anon</code> (to bind anonymously), or be presented by two
          options <code>other_bind.user_dn</code> and <code>other_bind.password</code>
          to bind with a specified username and password. For example:

<pre class="lang-ini">
auth_ldap.other_bind.user_dn = a-username
auth_ldap.other_bind.password = a-password</pre>

          Using the classic config format:

<pre class="lang-erlang">
[
  {rabbitmq_auth_backend_ldap, [
    {other_bind, {"a-username", "a-password"}}
  ]}
].
</pre>
        </p>
        <p>
          Note that it is not possible to use the
          default <code>as_user</code> configuration when users connect
          without providing a password. In that case, use
          <code>auth_ldap.other_bind.user_dn</code> and <code>auth_ldap.other_bind.password</code>
          or the <code>anon</code> option.
        </p>
        <p>
          Default value of <code>auth_ldap.other_bind</code> is <code>as_user</code>.
        </p>
      </doc:subsection>


      <doc:subsection name="group-lookups">
        <doc:heading>Group Membership Lookup</doc:heading>

        <p>
          The plugin supports several group membership lookup queries.
          The <code>group_lookup_base</code> setting controls what base DN will be used to search for nested groups. It is used by
          the <code>{in_group_nested, ...}</code> query only. For more info see the <a href="#query-reference">section on queries</a>.
        </p>
        <p>
          In the following example <code>ou=groups,dc=example,dc=com</code> is the directory that contains all groups.
          Note that it uses the <a href="/configure.html">classic config format</a>:

<pre class="lang-erlang">
[
  {rabbitmq_auth_backend_ldap, [
    %% ...
    {group_lookup_base, "ou=groups,dc=example,dc=com"}
  ]}
]
</pre>
        </p>
        <p>
          Default value is <code>'none'</code>.
        </p>
      </doc:subsection>
    </doc:section>


    <doc:section name="authorisation">
      <doc:heading>Configuring Authorisation</doc:heading>

      <doc:subsection name="authorisation-overview">
        <doc:heading>How RabbitMQ Permission Model Maps to LDAP</doc:heading>

        <p>
          RabbitMQ <a href="/access-control.html">permission model</a>
          is different from that of LDAP. In addition, the way LDAP
          schemas are used will vary from company to
          company. Therefore a mechanism that defines what LDAP
          requests are used by the RabbitMQ authorisation functions is
          needed. Authorisation is controlled by four configurable queries:

          <ul>
            <li><code>rabbitmq_auth_backend_ldap.vhost_access_query</code></li>
            <li><code>rabbitmq_auth_backend_ldap.resource_access_query</code></li>
            <li><code>rabbitmq_auth_backend_ldap.topic_access_query</code></li>
            <li><code>rabbitmq_auth_backend_ldap.tag_queries</code></li>
          </ul>

          Each defines a query that will determine whether a user has
          access to a vhost, whether they have access to a resource
          (e.g. exchange, queue, binding) and
          which <a href="management.html#permissions">tags</a> they
          have.
        </p>

        <p>
          Note the longer <code>rabbitmq_auth_backend_ldap</code> prefix.
          Queries are expressed using a domain-specific language expressed in Erlang terms (data structures),
          so they can be defined only using the
          <a href="/configure.html#erlang-term-config-file">classic config format</a>. Starting with RabbitMQ 3.7
          query definitions are commonly placed into the <config>additional.config</config> file.
        </p>
      </doc:subsection>


      <doc:subsection name="query-types">
        <doc:heading>Queries and Their Types</doc:heading>

        <p>
          Each query mentioned above is used at a different authorisation stage and must
          evaluate to either <code>true</code> or false. Specific query types (expressions,
          e.g. value comparison or group membership check) are covered later
          in this guide.
        </p>

        <p>
          A query can be of one of several types. Each type represents a boolean expression or function:
          a comparison, string match, object existence check, group membership check, and so on.
          Queries can be nested and combined using boolean operators.
        </p>

        <p>
          The default values (expressions) can be found in the table below:

          <table>
            <thead>
              <td>Query</td>
              <td>Default Expression</td>
            </thead>
            <tr>
              <td><code>rabbitmq_auth_backend_ldap.vhost_access_query</code></td>
              <td><code>{constant, true}</code></td>
            </tr>
            <tr>
              <td><code>rabbitmq_auth_backend_ldap.resource_access_query</code></td>
              <td><code>{constant, true}</code></td>
            </tr>
            <tr>
              <td><code>rabbitmq_auth_backend_ldap.topic_access_query</code></td>
              <td><code>{constant, true}</code></td>
            </tr>
            <tr>
              <td><code>rabbitmq_auth_backend_ldap.tag_queries</code></td>
              <td><code>[{administrator, {constant, false}}]</code></td>
            </tr>
          </table>
        </p>

        <p>
          This means that all users are granted access to all objects in all
          vhosts but they are not system administrators.
        </p>

        <p>
          All of the query types which take strings for arguments support string
          substitution, where variables pertaining to the query being
          made can be substituted in. Each of the queries supports
          different variables.
        </p>

        <p>
          The <code>vhost_access_query</code> supports:

          <ul>
            <li><code>${username}</code> - the user name provided at authentication</li>
            <li><code>${user_dn}</code> - the distinguished name of the user</li>
            <li><code>${vhost}</code> - the virtual host for which we are querying access</li>
          </ul>
        </p>

        <p>
          The <code>resource_access_query</code> supports:

          <ul>
            <li><code>${username}</code> - the user name provided at authentication</li>
            <li><code>${user_dn}</code> - the distinguished name of the user</li>
            <li><code>${vhost}</code> - the virtual host in which the resource resides</li>
            <li><code>${resource}</code> - one of "exchange" or "queue" for the type of resource</li>
            <li><code>${name}</code> - the name of the resource</li>
            <li><code>${permission}</code> - one of "configure", "write" or "read" for the type of access being requested to the resource</li>
          </ul>
        </p>

        <p>
          The <code>tag_queries</code> supports:

          <ul>
            <li><code>${username}</code> - the user name provided at authentication</li>
            <li><code>${user_dn}</code> - the distinguished name of the user</li>
          </ul>
        </p>

        <p>
          The <code>topic_access_query</code> supports:

          <ul>
            <li><code>${username}</code> - the user name provided at authentication</li>
            <li><code>${user_dn}</code> - the distinguished name of the user</li>
            <li><code>${vhost}</code> - the virtual host in which the resource resides</li>
            <li><code>${resource}</code> - always "topic" in this case</li>
            <li><code>${name}</code> - the name of the resource</li>
            <li><code>${permission}</code> - one of "write" (publishing) or "read" (consuming, queue and
              exchange-to-exchange binding for topic exchanges)
            </li>
            <li><code>${routing_key}</code> - the routing key of the published message ("write" permission)
              or routing key of the topic exchange to queue/exchange binding ("read" permission)
            </li>
          </ul>
        </p>

        <p>
          Finally, if the user name provided at authentication is in the form
          <code>Domain\User</code> (which is the case in some Active Directory environments),
          two <i>additional</i> variables will be made available for each of the above queries:
          <ul>
            <li><code>${ad_domain}</code> - the domain part of <code>Domain\User</code></li>
            <li><code>${ad_user}</code> - the user part of <code>Domain\User</code></li>
          </ul>
        </p>

        <p>
          The terms configure, write and read for resource access have the
          same meanings that they do for the built-in RabbitMQ permissions
          system, see http://www.rabbitmq.com/access-control.html. See
          also <a href="/access-control.html#topic-authorisation">topic authorisation</a>
          for <code>topic_access_query</code>.
        </p>

        <p>
          When first getting familiar with the query DSL, it can be
          helpful to switch on the <code>log</code> configuration
          parameter documented above. This will cause the LDAP plugin
          to write fairly verbose descriptions of the queries it
          executes and the decisions it therefore makes to the
          RabbitMQ log.
        </p>
      </doc:subsection>


      <doc:subsection name="authorisation-vhost-access">
        <doc:heading>Virtual Host Access</doc:heading>

        <p>
          <code>rabbitmq_auth_backend_ldap.vhost_access_query</code>
          is the query used to control virtual host
          access. If the query evaluates to <code>true</code> then access
          is granted.
        </p>

        <p>
          Note that before a user can access a virtual host, the
          virtualhost must have been created within RabbitMQ; unlike
          users and permissions, virtual hosts cannot live entirely
          within LDAP.
        </p>
      </doc:subsection>


      <doc:subsection name="authorisation-tag-query">
        <doc:heading>User Tags</doc:heading>

        <p>
          The <code>tag_queries</code> consists of a key-value map
          mapping the name of a tag to a query to perform to determine
          whether or not the user has that tag. It is necessary to
          list list queries for all tags that the users should to
          have.
        </p>
      </doc:subsection>
    </doc:section>


    <doc:section name="query-reference">
      <doc:heading>Authorisation Query Reference</doc:heading>

      <doc:subsection>
        <doc:heading>Constant Query</doc:heading>
        <pre>{constant, Bool}</pre>
        <p>
          This will always return either true or false, unconditionally granting
          or denying access.
        </p>
        <p>Example:</p>
        <pre class="lang-erlang">{tag_queries, [{administrator, {constant, false}},
               {management,    {constant, true}}]}</pre>
        <p>
          This grants all users the ability to use the management
          plugin, but makes none of them administrators.
        </p>
      </doc:subsection>

      <doc:subsection>
        <doc:heading>Exists Query</doc:heading>
        <pre>{exists, Pattern}</pre>
        <p>
          This will substitute variables into the pattern, and return true if
          there exists an object with the resulting DN.
        </p>
        <p>Example:</p>
        <pre class="lang-erlang">{vhost_access_query, {exists, "ou=${vhost},ou=vhosts,dc=example,dc=com"}}</pre>
        <p>
          This grants access to all virtual hosts which exist as
          organisational units
          within <code>ou=vhosts,dc=example,dc=com</code> to all
          users.
        </p>
      </doc:subsection>

      <doc:subsection>
        <doc:heading>In Group Query</doc:heading>
        <pre>{in_group, Pattern}</pre>
        <pre>{in_group, Pattern, AttributeName}</pre>
        <p>
          Like the Exists Query, substitutes arguments into a pattern to look
          for an object. However, this query returns true if the logged in
          user is a member; checking either against the <code>member</code>
          attribute, or any named attribute.
        </p>
        <p>Example:</p>
        <pre class="lang-erlang">{vhost_access_query, {in_group, "cn=${vhost}-users,ou=vhosts,dc=example,dc=com"}}</pre>
        <p>
          This grants access to virtual hosts when the user is listed
          as a <code>member</code> attribute of an appropriately named
          object (such as a <code>groupOfNames</code>)
          within <code>ou=vhosts,dc=example,dc=com</code>.
        </p>
      </doc:subsection>

      <doc:subsection>
        <doc:heading>In Nested Group Query</doc:heading>
        <pre>{in_group_nested, Pattern}</pre>
        <pre>{in_group_nested, Pattern, AttributeName}</pre>
        <pre>{in_group_nested, Pattern, AttributeName, Scope}</pre>
        <p>
          Similar to the <code>in_group</code> query but also traverses group hierarchy,
          e.g. if the logged in user is a member of the group which is a member of
          another group. Membership is checked against the <code>member</code>
          attribute or any named attribute.
          Groups are searched in the DN defined by the <code>group_lookup_base</code>
          configuration key, or the <code>dn_lookup_base</code> variable if
          former is <code>none</code>. If both lookup base variables are set to
          <code>none</code> the query will always return <code>false</code>.
          Search scope can be set to either <code>subtree</code> or <code>single_level</code>.
          <ul>
            <li><code>subtree</code> searches all objects contained under the lookup base</li>
            <li><code>single_level</code> searches for groups directly contained within the lookup base</li>
          </ul>
          Default value for scope is <code>subrtee</code> The query is
          using in-depth search up from user to target group.  Search
          process will detect and skip cyclic paths.  This query can
          be time and memory consuming if users are members of many
          groups, which are members of many groups as well. Use this
          query when groups for a membership hierarchy. It is still
          recommended to use plain <code>{in_group, ...}</code> query
          when possible: nested groups can be challenging to reason
          about.
        </p>
        <p>Example:</p>
<pre class="lang-erlang">
[
  {group_lookup_base, "ou=groups,dc=example,dc=com"},
  {vhost_access_query, {in_group_nested, "cn=${vhost}-groups,ou=groups,dc=example,dc=com"}, "member", single_level}
]
</pre>
        <p>
          This grants access to virtual hosts when the user a member in group
          hierarchy defined by the <code>member</code> attribute values and located
          in the <code>ou=groups,dc=example,dc=com</code> directory.
        </p>
      </doc:subsection>

      <doc:subsection>
        <doc:heading>For Query</doc:heading>
        <pre>{for, [{Name, Value, SubQuery}, ...]}</pre>
        <p>
          This allows you to split up a query and handle different cases with
          different subqueries.
        </p>
        <p>
          Options should be a list of three-tuples, with each tuple containing
          a name, value and subquery. The name is the name of a variable
          (i.e. something that would go into a <code>${}</code>
          substitution). The value is a possible value for that variable.
        </p>
        <p>
          Note that the values are of different Erlang types;
          <code>resource</code> and <code>permission</code> have atom
          values (e.g. <code>resource</code> could be
          <code>exchange</code>) while the other keys have binary
          values (e.g. <code>name</code> might be
          <code>&lt;&lt;"amq.fanout"&gt;&gt;</code>).
        </p>
        <p>
          Example:
        </p>
<pre class="lang-erlang">
{resource_access_query,
 {for, [{resource, exchange, {for, [{permission, configure,
                                     {in_group, "cn=wheel,dc=example,dc=com"}
                                    },
                                    {permission, write, {constant, true}},
                                    {permission, read,  {constant, true}}
                                   ]}},
                                   {resource, queue,    {constant, true}}]}}
</pre>

        <p>
          This allows members of the <code>wheel</code> group to declare and
          delete exchanges, and allow all users to do everything else.
        </p>
      </doc:subsection>

      <doc:subsection>
        <doc:heading>Boolean Queries</doc:heading>
        <pre>{'not', SubQuery}</pre>
        <pre>{'and', [SubQuery1, SubQuery2, SubQuery3, ...]}</pre>
        <pre>{'or', [SubQuery1, SubQuery2, SubQuery3, ...]}</pre>
        <p>
          These can be used to combine subqueries with boolean logic. The
          'and' and 'or' queries each take an arbitrarily long list of
          subqueries, returning true if all or any subqueries evaluate to true
          respectively.
        </p>
        <p>
          Note that 'and', 'or' and 'not' are reserved words in Erlang,
          therefore the keywords need to be quoted with single quotes in the
          configuration file, as above.
        </p>
        <p>Example:</p>
        <pre class="lang-erlang">{resource_access_query,
 {'or',
  [{'and',
    [{equals, "${name}", "test1"},
     {equals, "${username}", "user1"}]},
   {'and',
    [{equals, "${name}", "test2"},
     {'not', {equals, "${username}", "user1"}}]}
  ]}}</pre>
        <p>
          This example gives full access to objects called "test1" to "user1",
          and access to "test2" to everyone but "user1".
        </p>
      </doc:subsection>

      <doc:subsection>
        <doc:heading>Equals Query</doc:heading>
        <pre>{equals, StringSubQuery1, StringSubQuery2}</pre>
        <p>
          Takes two strings, and checks that the one matches the
          other. Note that both strings are subqueries (of the
          <code>string</code> and <code>attribute</code> types below)
          in turn.
        </p>
        <p>
          This can be useful in order to compare the value of one of
          the string substitution variables with a constant, or with
          an attribute value, etc.
        </p>
        <p>Example:</p>
        <pre class="lang-erlang">{resource_access_query,
 {for, [{permission, configure, {equals, {attribute, "${user_dn}", "description"},
                                         {string, "can-declare-${resource}s"}
                                }
        },
        {permission, write, {constant, true}},
        {permission, read,  {constant, true}}
       ]
 }</pre>
        <p>
          This grants permissions to declare and delete exchanges and
          queues based on the presence of the strings
          "can-declare-exchanges" and "can-declare-queues" in the
          user's description field, and grants permission to write and
          read exchanges to everyone.
        </p>
      </doc:subsection>

      <doc:subsection>
        <doc:heading>Match Query</doc:heading>
        <pre>{match, StringSubQuery, RESubQuery}</pre>
        <p>
          Takes a string and a regular expression, and checks that the one
          matches the other. Note that the string and the regular expression are
          both subqueries (of the <code>string</code> and <code>attribute</code>
          types below) in turn.
        </p>
        <p>Example:</p>
        <pre class="lang-erlang">{resource_access_query, {match, {string, "${name}"},
                                {string, "^${username}-"}}
}</pre>
        <p>
          This allows users to configure, read and write any object whose name
          begins with their own username followed by a hyphen.
        </p>
      </doc:subsection>

      <doc:subsection>
        <doc:heading>String Sub-query</doc:heading>
        <pre>{string, Pattern}</pre>
        <p>
          Just substitutes arguments into a string. As this returns a string
          rather than a boolean it should be used within a <code>match</code>
          or <code>equals</code> query. See above for example. As a shorthand
          you can use a plain string instead of
          <code>{string, Pattern}</code>.

        </p>
      </doc:subsection>

      <doc:subsection>
        <doc:heading>Attribute Sub-query</doc:heading>
        <pre>{attribute, DNPattern, AttributeName}</pre>
        <p>
          Returns the value of an attribute of an object retrieved from
          LDAP. As this returns a string rather than a boolean it should be
          used within a <code>match</code> or <code>equals</code> query. See
          above for example.
        </p>
      </doc:subsection>
    </doc:section>
    <doc:section name="example">
      <doc:heading>Example configuration</doc:heading>
      <p>
        Bringing it all together, here's a sample configuration. It uses both the <a href="/configure.html#config-file">standard config</a> and
        <a href="/configure.html#advanced-config-file">advanced config</a> files together. This
        makes all users able to access the management plugin, but
        makes none of them administrators. Access to virtual hosts is
        controlled by membership of a group per virtual host. Only
        members of <code>admin</code> can declare, delete or
        bind exchanges and queues, but all users can publish to
        exchanges and declare from queues. Publishing to topic-typed
        exchanges is restricted to messages with a routing key
        beginning with "a" and consuming from topics isn't restricted
        (topic authorisation).
      </p>

      The <a href="/configure.html#config-file">standard config</a>
      (rabbitmq.conf) is used to configure authentication backends and
      several LDAP plugin parameters:

<pre class="sourcecode">
auth_backends.1 = ldap

auth_ldap.servers.1  = my-ldap-server
auth_ldap.user_dn_pattern = cn=${username},ou=People,dc=example,dc=com
auth_ldap.use_ssl    = false
auth_ldap.port       = 389
auth_ldap.log        = false
</pre>

    <a href="/configure.html#advanced-config-file">Advanced config</a> is used to define LDAP queries:

<pre class="lang-erlang">
[{rabbitmq_auth_backend_ldap,[
    {vhost_access_query,    {in_group,
                              "ou=${vhost}-users,ou=vhosts,dc=example,dc=com"}},
     {resource_access_query,
      {for, [{permission, configure, {in_group, "cn=admin,dc=example,dc=com"}},
             {permission, write,
              {for, [{resource, queue,    {in_group, "cn=admin,dc=example,dc=com"}},
                     {resource, exchange, {constant, true}}]}},
             {permission, read,
              {for, [{resource, exchange, {in_group, "cn=admin,dc=example,dc=com"}},
                     {resource, queue,    {constant, true}}]}}
            ]
      }},
     {topic_access_query,
      {for, [{permission, write, {match, {string, "${routing_key}"}, {string, "^a"}}},
             {permission, read,  {constant, true}}
            ]
      }},
     {tag_queries,           [{administrator, {constant, false}},
                              {management,    {constant, true}}]}
]}].
</pre>

    Alternatively, you can use the <a href="/configure.html#erlang-term-config-file">classic config format</a>
    to configure everything in a single file:


<pre class="lang-erlang">
[
  {rabbit, [{auth_backends, [rabbit_auth_backend_ldap]}]},
  {rabbitmq_auth_backend_ldap,
   [ {servers,               ["my-ldap-server"]},
     {user_dn_pattern,       "cn=${username},ou=People,dc=example,dc=com"},
     {use_ssl,               false},
     {port,                  389},
     {log,                   false},
     {vhost_access_query,    {in_group,
                              "ou=${vhost}-users,ou=vhosts,dc=example,dc=com"}},
     {resource_access_query,
      {for, [{permission, configure, {in_group, "cn=admin,dc=example,dc=com"}},
             {permission, write,
              {for, [{resource, queue,    {in_group, "cn=admin,dc=example,dc=com"}},
                     {resource, exchange, {constant, true}}]}},
             {permission, read,
              {for, [{resource, exchange, {in_group, "cn=admin,dc=example,dc=com"}},
                     {resource, queue,    {constant, true}}]}}
            ]
      }},
     {topic_access_query,
      {for, [{permission, write, {match, {string, "${routing_key}"}, {string, "^a"}}},
             {permission, read,  {constant, true}}
            ]
     }},
     {tag_queries,           [{administrator, {constant, false}},
                              {management,    {constant, true}}]}
   ]
  }
].</pre>
    </doc:section>



    <doc:section name="troubleshooting">
      <doc:heading>Troubleshooting</doc:heading>

      <p>
        Using LDAP for authentication and/or authorisation introduces another moving
        part into the system. Since LDAP servers are accessed over the network,
        some topics covered in the <a href="/troubleshooting-networking.html">Network Troubleshooting</a>
        and <a href="/troubleshooting-ssl.html">TLS Troubleshooting</a> guides apply to LDAP.
      </p>

      <p>
        In order to troubleshoot LDAP operations performed during the authentication and authorisation
        stages, <a href="#logging">enabling LDAP traffic logging</a> is highly recommended.
      </p>

      <p>
        <a href="http://bit.ly/2GPyTmq">ldapsearch</a> is a command line tool that ships with LDAP and makes it possible to execute arbitrary
        LDAP queries against an OpenLDAP installation. This can be useful when troubleshooting complex authorisation
        queries. <a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc772839(v=ws.10)">ldp.exe</a> is the Active Directory counterpart.
      </p>
    </doc:section>
  </body>
</html>
