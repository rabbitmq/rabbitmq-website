<?xml-stylesheet type="text/xml" href="page.xsl"?>
<html xmlns:doc="http://www.rabbitmq.com/namespaces/ad-hoc/doc">
  <head>
    <title>RabbitMQ - Extensions and Experimental Features</title>
  </head>
  <body>
    <doc:div>
      <p class="intro">
        The RabbitMQ Server implements a number of extensions of the
        <a href="specification.html">AMQP specification</a>, which we
        are documenting here.  There are also some experimental
        features, not directly related to the specification, which we
        consider to be useful but require further testing.
      </p>

      <doc:toc class="compact">
        <doc:heading>Table of Contents</doc:heading>
      </doc:toc>

      <doc:section name="queue-leases">
        <doc:heading>Queue Leases</doc:heading>

        <p>
          The <code>x-expires</code> argument to
          <code>queue.declare</code> controls for how long a queue can
          be unused before it is automatically
          deleted. <em>Unused</em> means the queue has no consumers,
          and no consumer related operations (<code>basic.get</code> or
          <code>basic.cancel</code>) have occurred for
          a duration of at least the expiration period. This can be
          used, for example, for RPC-style reply queues, where many
          queues can be created which may never be drained.
        </p>

        <p>
          The server guarantees that the queue will be deleted, if
          unused for at least the expiration period. No guarantee is
          given as to how promptly the queue will be removed after the
          expiration period has elapsed. Leases of durable queues
          restart when the server restarts.
        </p>

        <p>
          The value of the <code>x-expires</code> argument must be an
          integer, greater than zero, describing the expiration period
          in milliseconds. Thus a value of 1000 means a queue which is
          unused for 1 second will be deleted. The argument can be of
          AMQP type short-short-int, short-int, long-int, or
          long-long-int.
        </p>

        <doc:subsection>
          <doc:heading>Usage</doc:heading>

          <p>
            This example in Java creates a queue which expires after
            it has been unused for 30 minutes.
          </p>
          <pre class="sourcecode">
Map&lt;String, Object&gt; args = new HashMap&lt;String, Object&gt;();
args.put("x-expires", 1800000);
channel.queueDeclare("myqueue", false, false, false, args);</pre>
        </doc:subsection>

      </doc:section>

      <doc:section name="alternate-exchange">
        <doc:heading>Alternate Exchanges</doc:heading>

        <p>
          It is sometimes desirable to let clients handle messages
          that an exchange was unable to route (i.e. either because
          there were no bound queues our no matching
          bindings). Typical examples of this are
          <ul>
            <li>detecting when clients accidentally or maliciously
            publish messages that cannot be routed</li>
            <li>"or else" routing semantics where some messages are
            handled specially and the rest by a generic handler</li>
          </ul>
        </p>
        <p>
          RabbitMQ's <em>Alternate Exchange</em> ("AE") feature
          addresses these use cases.
        </p>

        <doc:subsection>
          <doc:heading>Configuration</doc:heading>
          <p>
            When creating an exchange the name of an AE can be
            optionally supplied in the <code>exchange.declare</code>
            method's <code>arguments</code> table by specifying a key
            of 'alternate-exchange' and a value of type 'S' (string)
            containing the name.
          </p>
          <p>
            When an AE has been specified, in addition to the usual
            <em>configure</em> permissions on the declared exchange,
            the user needs to have <em>read</em> permissions on that
            exchange and <em>write</em> permissions on the AE.
          </p>
          <p>
            For example:
          </p>
          <pre class="sourcecode">
Map&lt;String, Object&gt; args = new HashMap&lt;String, Object&gt;();
args.put("alternate-exchange", "my-ae");
channel.exchangeDeclare("my-direct", "direct", false, false, args);
channel.exchangeDeclare("my-ae", "fanout");
channel.queueDeclare("routed");
channel.queueBind("routed", "my-direct", "key1");
channel.queueDeclare("unrouted");
channel.queueBind("unrouted", "my-ae", "");</pre>
          <p>
            In the above fragment of Java code we create a direct
            exchange 'my-direct' that is configured with an AE called
            'my-ae'. The latter is declared as a fanout exchange. We
            bind one queue 'routed' to 'my-direct' with a binding key
            of 'key1', and a queue 'unrouted' to 'my-ae'.
          </p>
        </doc:subsection>

        <doc:subsection>
          <doc:heading>Operation</doc:heading>
          <p>
            Whenever an exchange with a configured AE cannot route a
            message to any queue (or the message was marked as
            immediate and it cannot be delivered to any consumer) then
            it publishes the message to the specified AE instead. If
            that AE does not exist then a warning is logged.
          </p>
          <p>
            For example:
          </p>
          <pre class="sourcecode">
channel.basicPublish("my-direct", "key2", null, "test".getBytes());
GetResponse r2 = channel.basicGet("unrouted", true); //returns message
channel.basicPublish("my-direct", "key1", null, "test".getBytes());
GetResponse r1 = channel.basicGet("routed", true); //returns message</pre>
          <p>
            Here we first publish a message to 'my-direct' with a
            routing key of 'key1'. That message is routed to the
            'routed' queue, in accordance with the standard AMQP
            behaviour.  However, when publishing a message to
            'my-direct' with a routing key of 'key2', rather than
            being discarded the message is routed via our configured
            AE to the 'unrouted' queue.
          </p>
          <p>
            When an AE cannot route a message, it in turn publishes
            the message to its AE, if it has one configured. This
            process continues until either the message is successfully
            routed, the end of the chain of AEs is reached, or an AE
            is encountered which has already attempted to route the
            message.
          </p>
          <p>
            The semantics of the 'mandatory' and 'immediate' flags
            carries through to AEs. So, for example, if a sender
            specified the 'mandatory' flag on publication of a
            message, and that message could not be routed by the
            original exchange, but was then routed to a queue via an
            AE, then no <code>basic.return</code> is issued.
          </p>
          <p>
            Message properties are carried through when messages are
            routed via AEs. For example, when a message that was
            marked as persistent is routed to some queue via an AE
            then it does get persisted.
          </p>
          <p>
            The queues to which a messages is routed from an AE
            participate in AMQP's <code>tx</code> transactions,
            i.e. if an unroutable message was published inside a tx
            then it will only appear in the queues when that tx is
            committed.
          </p>

        </doc:subsection>

      </doc:section>

      <doc:section name="memsup">
        <doc:heading>Memory-based flow control</doc:heading>
        <!--
            To avoid terminology soup:
            - "memory threshold" always refers to the configured fraction
            - "memory limit" always refers to the computed absolute limit
        -->

        <p>
          The RabbitMQ server detects the total amount of RAM
          installed in the computer on startup. By default, when the
          RabbitMQ server uses above 40% of the installed RAM, it
          raises a memory alarm. In response the server pauses reading
          from the sockets of connected clients which send
          content-bearing methods (such as <code>basic.publish</code>)
          after the alarm was raised. Connection heartbeat monitoring
          gets disabled too. Once the memory alarm has cleared
          (e.g. due to the server paging messages to disk or
          delivering them to clients) normal service resumes.
        </p>
        <p>
          The intent here is to introduce a flow control mechanism
          that throttles producers but lets consumers continue
          unaffected. However, since AMQP permits producers and
          consumers to operate on the same channel, and on different
          channels of a single connection, this logic is necessarily
          imperfect. In practice that does not pose any problems for
          most applications since the throttling is observable merely
          as a delay. Nevertheless, other design considerations
          permitting, it is advisable to only use individual AMQP
          connections for either producing or consuming.
        </p>

        <p>
          The default memory threshold is set to 40% of installed
          RAM. Note that this does not prevent the RabbitMQ server
          from using more than 40%, it is merely the point at which
          publishers are throttled. Erlang's garbage collector can, in
          the worst case, cause double the amount of memory to be used
          (by default, 80% of RAM), and non-compliant AMQP clients can
          cause the RabbitMQ server to use more still. It is strongly
          recommended that OS swap or page files are enabled.
        </p>

        <p>
          32-bit architectures impose a per process memory limit of
          4GB, though under Windows, this is frequently further
          reduced to 2GB. Common implementations of 64-bit
          architectures (i.e. AMD64 and Intel EM64T) permit only a
          paltry 256TB per process. 64-bit Windows again further
          limits this to 8TB. However, note that even under 64-bit
          Windows, a 32-bit process frequently only has a maximum
          address space of 2GB.
        </p>

        <doc:subsection>
          <doc:heading>Usage</doc:heading>

          <p>
            The memory threshold at which the flow control is
            triggered can be adjusted by editing the <code><a
            href="install.html#configfile">rabbitmq.config</a></code>
            file (in the appropriate location for your platform, as
            discussed in the <a
            href="install.html#configfile">installation
            guide</a>). The example below sets the threshold to the
            default value of 0.4:
            <pre class="sourcecode">[{rabbit, [{vm_memory_high_watermark, 0.4}]}].</pre>
          </p>

          <p>
            The default value of 0.4 stands for 40% of installed RAM
            or 40% of available virtual address space, whichever is
            smaller. E.g. on a 32-bit Windows platform, if you have
            4GB of RAM installed, 40% of 4GB is 1.6GB, but 32-bit
            Windows normally limits processes to 2GB, so the threshold
            is actually to 40% of 2GB (which is 820MB).
          </p>

          <p>
            A value of 0 disables the memory monitor and throttling of
            producers via <code>channel.flow</code>.
          </p>

          <p>
            The memory limit is appended to the
            <b>RABBITMQ_NODENAME</b>.log file when the RabbitMQ server
            starts:
            <pre class="sourcecode">
=INFO REPORT==== 29-Oct-2009::15:43:27 ===
Memory limit set to 2048MB.</pre>
          </p>

          <p>
            Versions of Erlang prior to R13B had a bug that meant they
            do not reliably detect the amount of memory installed on
            Windows platforms. If RabbitMQ is running under Windows on
            a version of Erlang prior to R13B, then it does not
            attempt to automatically set a threshold. Instead, it
            behaves as if it's unable to recognise the platform: see
            below.
          </p>
        </doc:subsection>

        <doc:subsection>
          <doc:heading>Unrecognised platforms</doc:heading>
          <p>
            If the RabbitMQ server is unable to recognise your system,
            or if you're using Windows and a version of Erlang prior
            to R13B, it will append a warning to the
            <b>RABBITMQ_NODENAME</b>.log file. It then assumes than
            1GB of RAM is installed:
            <pre class="sourcecode">
=WARNING REPORT==== 29-Oct-2009::17:23:44 ===
Unknown total memory size for your OS {unix,magic_homebrew_os}. Assuming memory size is 1024MB.</pre>
          </p>

          <p>
            In this case, the <code>vm_memory_high_watermark</code>
            configuration value is used to scale the assumed 1GB
            RAM. With the default value of
            <code>vm_memory_high_watermark</code> set to 0.4,
            RabbitMQ's memory threshold is set to 410MB, thus it will
            throttle producers whenever RabbitMQ is using more than
            410MB memory. Thus when RabbitMQ can't recognize your
            platform, if you actually have 8GB RAM installed and you
            want to invoke <code>channel.flow</code> to throttle
            producers when the RabbitMQ server is using above 3GB, set
            <code>vm_memory_high_watermark</code> to 3.
          </p>

          <p>
            It is advised you do not set the threshold above 50% of
            your installed RAM, and to note that under Windows, it is
            commonly the case that a maximum of 2GB memory is
            available to RabbitMQ.
          </p>
        </doc:subsection>
      </doc:section>

    </doc:div>
  </body>
</html>
