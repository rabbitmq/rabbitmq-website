<?xml-stylesheet type="text/xml" href="page.xsl"?>
<html xmlns:doc="http://www.rabbitmq.com/namespaces/ad-hoc/doc">
  <head>
    <title>RabbitMQ - Extensions and Experimental Features</title>
  </head>
  <body>
    <doc:div>
      <p class="intro">
        The RabbitMQ Server implements a number of extensions of the
        <a href="specification.html">AMQP specification</a>, which we
        are documenting here.  There are also some experimental
        features, not directly related to the specification, which we
        consider to be useful but require further testing.
      </p>

      <doc:toc class="compact">
        <doc:heading>Table of Contents</doc:heading>
      </doc:toc>
      
      <doc:section name="alternate-exchange">
        <doc:heading>Alternate Exchanges</doc:heading>
        
        <p>
          It is sometimes desirable to let clients handle messages
          that an exchange was unable to route (i.e. either because
          there were no bound queues our no matching
          bindings). Typical examples of this are
          <ul>
            <li>detecting when clients accidentally or maliciously
            publish messages that cannot be routed</li>
            <li>"or else" routing semantics where some messages are
            handled specially and the rest by a generic handler</li>
          </ul>
        </p>
        <p>
          RabbitMQ's <em>Alternate Exchange</em> ("AE") feature
          addresses these use cases.
        </p>

        <doc:subsection>
          <doc:heading>Configuration</doc:heading>
          <p>
            When creating an exchange the name of an AE can be
            optionally supplied in the <code>exchange.declare</code>
            method's <code>arguments</code> table by specifying a key
            of 'alternate-exchange' and a value of type 'S' (string)
            containing the name.
          </p>
          <p>
            When an AE has been specified, in addition to the usual
            <em>configure</em> permissions on the declared exchange,
            the user needs to have <em>read</em> permissions on that
            exchange and <em>write</em> permissions on the AE.
          </p>
          <p>
            For example:
          </p>
          <pre class="sourcecode">
Map&lt;String, Object&gt; args = new HashMap&lt;String, Object&gt;();
args.put("alternate-exchange", "my-ae");
channel.exchangeDeclare("my-direct", "direct", false, false, false, args);
channel.exchangeDeclare("my-ae", "fanout");
channel.queueDeclare("routed");
channel.queueBind("routed", "my-direct", "key1");
channel.queueDeclare("unrouted");
channel.queueBind("unrouted", "my-ae", "");</pre>
          <p>
            In the above fragment of Java code we create a direct
            exchange 'my-direct' that is configured with an AE called
            'my-ae'. The latter is declared as a fanout exchange. We
            bind one queue 'routed' to 'my-direct' with a binding key
            of 'key1', and a queue 'unrouted' to 'my-ae'.
          </p>
        </doc:subsection>

        <doc:subsection>
          <doc:heading>Operation</doc:heading>
          <p>
            Whenever an exchange with a configured AE cannot route a
            message to any queue (or the message was marked as
            immediate and it cannot be delivered to any consumer) then
            it publishes the message to the specified AE instead. If
            that AE does not exist then a warning is logged.
          </p>
          <p>
            For example:
          </p>
          <pre class="sourcecode">
channel.basicPublish("my-direct", "key2", null, "test".getBytes());
GetResponse r2 = channel.basicGet("unrouted", true); //returns message
channel.basicPublish("my-direct", "key1", null, "test".getBytes());
GetResponse r1 = channel.basicGet("routed", true); //returns message</pre>
          <p>
            Here we first publish a message to 'my-direct' with a
            routing key of 'key1'. That message is routed to the
            'routed' queue, in accordance with the standard AMQP
            behaviour.  However, when publishing a message to
            'my-direct' with a routing key of 'key2', rather than
            being discarded the message is routed via our configured
            AE to the 'unrouted' queue.
          </p>
          <p>
            When an AE cannot route a message, it in turn publishes
            the message to its AE, if it has one configured. This
            process continues until either the message is successfully
            routed, the end of the chain of AEs is reached, or an AE
            is encountered which has already attempted to route the
            message.
          </p>
          <p>
            The semantics of the 'mandatory' and 'immediate' flags
            carries through to AEs. So, for example, if a sender
            specified the 'mandatory' flag on publication of a
            message, and that message could not be routed by the
            original exchange, but was then routed to a queue via an
            AE, then no <code>basic.return</code> is issued.
          </p>
          <p>
            Message properties are carried through when messages are
            routed via AEs. For example, when a message that was
            marked as persistent is routed to some queue via an AE
            then it does get persisted.
          </p>
          <p>
            The queues to which a messages is routed from an AE
            participate in AMQP's <code>tx</code> transactions,
            i.e. if an unroutable message was published inside a tx
            then it will only appear in the queues when that tx is
            committed.
          </p>

        </doc:subsection>

      </doc:section>

      <doc:section name="memsup">
        <doc:heading>Memory-based flow control</doc:heading>

        <p>
          In older versions of the RabbitMQ server it was possible for clients 
          to attempt to store so many messages within the server that it outgrew
          the available memory. With the current release 
          memory-pressure-detection feature has been added to the
          codebase. When the server notices that the memory footprint of the
          RabbitMQ process grows above 70% of the total memory available,
          it throttles publishers with the <code>channel.flow</code>
          AMQP command.
        </p>

        <p>
          The default memory limit is set to 70% of total system memory.
          Due to garbage collector and non-compliant AMQP
          clients, RabbitMQ virtual machine size can grow above this threshold.
          Make sure that the system has swap enabled.
        </p>
        
        <p> 
          On 32-bit architectures the memory limit can't be set to values more
          than 2GB. Depending on operating system, it leaves 1-2GB of virtual 
          address space free, reserved for garbage collector hiccups. 
          RabbitMQ can still die from out-of-memory problems if clients don't
          comply to <code>channel.flow</code> or due to fragmented virtual 
          memory address space. If the RabbitMQ server is using more
          than 1GB of memory, please consider migrating to 64-bit architecture,
          no matter how much memory you have in your system.
        </p>
        
        <doc:subsection>
          <doc:heading>Usage</doc:heading>

          <p>
            The memory threshold at which the flow control is
            triggered can be adjusted by modifying the
            <pre class="sourcecode">-os_mon vm_memory_high_watermark 0.7</pre>
            line in the <code>rabbitmq-server</code> script. 
          </p>
          
          <p>
            The default value of 0.7 stands for 70% of memory detected in your
            system. Value of 0 disables memory monitor and
            <code>channel.flow</code>. You can specify values higher than 1 
            in order to allow RabbitMQ to use swap, or in case of incorrectly
            detected memory size.
          </p>
          
          <p> 
            You can read currently set memory limit from
            <b>RABBITMQ_NODENAME</b>.log file. For example:
            <pre class="sourcecode">
=INFO REPORT==== 29-Oct-2009::15:43:27 ===
Memory limit set to 2048MB.</pre>

          </p>

	</doc:subsection>
      </doc:section>

    </doc:div>
  </body>
</html>
