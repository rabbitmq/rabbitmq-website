<?xml-stylesheet type="text/xml" href="page.xsl"?>
<!DOCTYPE html [
<!ENTITY % entities SYSTEM "rabbit.ent" >
%entities;
]>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:doc="http://www.rabbitmq.com/namespaces/ad-hoc/doc"
      xmlns:x="http://www.rabbitmq.com/2011/extensions">
  <head>
    <title>Federation Plugin</title>
  </head>
  <body show-in-this-page="true">
    <p>
      The high level goal of the federation plugin is to transmit messages
      between brokers without requiring clustering. This is useful for various
      reasons:
    </p>

    <dl class="plain">
      <dt><b>Loose coupling</b></dt>
      <dd>
        The federation plugin can transmit messages between brokers
        (or clusters) in different administrative domains:
        <ul class="plain">
          <li>
            they may have different users and virtual hosts;
          </li>
          <li>
            they may run on different versions of RabbitMQ and Erlang.
          </li>
        </ul>
      </dd>
      <dt><b>WAN-friendly</b></dt>
      <dd>
        The federation plugin uses AMQP to communicate between brokers, and is
        designed to tolerate intermittent connectivity.
      </dd>
      <dt><b>Specificity</b></dt>
      <dd>
        A broker can contain federated <i>and</i> local-only components - you
        don't need to federate everything if you don't want to.
      </dd>
      <dt><b>Scalability</b></dt>
      <dd>
        Federation does not require <i>n</i><sup>2</sup> connections between
        <i>n</i> brokers (although this is the easiest way to set
        things up), which should mean it scales better.
      </dd>
    </dl>

    <p>
      For the time being, federation is primarily useful in pub/sub scenarios.
    </p>

    <doc:section name="what-does-it-do">
      <doc:heading>What does it do?</doc:heading>

      <p>
        The federation plugin defines a new exchange type
        <code>x-federation</code>. An exchange instance of this type is called a
        <i>federated exchange</i>.
      </p>
      <dl>
        <dt>
          <b>What does a federated exchange do?</b>
        </dt>
        <dd>
          <p>
            A federated exchange links to other exchanges (called
            <i>upstream</i> exchanges). Logically (see next item), messages
            published to the upstream exchanges are copied to the federated
            exchange, as though they were published directly to it. The upstream
            exchanges do not need to be reconfigured and they do not have to be
            on the same broker or in the same cluster.
          </p>
        </dd>

        <dt>
          <b>Are <i>all</i> messages copied?</b>
        </dt>
        <dd>
          <p>
            Actually, only those messages that need to be copied are propagated.
            This is an optimisation arranged dynamically by the federation
            plugin. (See <a href="#details">below</a>.)
          </p>
        </dd>

        <dt>
          <b>How does a federated exchange link to its upstream exchanges?</b>
        </dt>
        <dd>
          <p>
            The federated exchange will connect to all its upstream
            exchanges using AMQP. When declaring or configuring the
            federated exchange each upstream exchange is listed with
            the connection properties to be used to establish the
            link.
          </p>
        </dd>

        <dt>
          <b>How does the federated exchange <i>route</i> the messages it
          receives?</b>
        </dt>
        <dd>
          <p>
            Rather than being a complete exchange type of its own (with its own
            routing strategy) the federated exchange type is a <i>modified</i>
            version of another type of exchange. The type which is modified is
            called the <i>backing-type</i>. The backing-type is specified when
            the federated exchange is declared.
          </p>
          <p>
            Messages can be published to a federated exchange like any
            other. Messages copied from upstream exchanges and locally
            published messages are routed just as the backing-type
            exchange would route them.
          </p>
          <p>
            Although not strictly correct, we often say the backing-type is the
            <i>type</i> of the federated exchange.
          </p>
          <p>
            Normally the backing-type is <code>topic</code>. This is the type of
            exchange the federation plugin was designed for. By using federated
            exchanges a topic space can be extended across a number of
            independently managed RabbitMQ servers.
          </p>
        </dd>

        <dt>
          <b>Can I federate a federated exchange?</b>
        </dt>
        <dd>
          <p>
            There is nothing to prevent a federated exchange being 'upstream'
            from another federated exchange. One can even form 'loops', for
            example, exchange A declares exchange B to be upstream from it, and
            exchange B declares exchange A to be upstream from it. More complex
            multiply-connected arrangements are allowed.
          </p>
          <p>
            To prevent messages being continually copied and re-routed (in a
            never-ending cycle) there is a limit placed on the number of times a
            message can be copied over a link (see 
            <a href="#upstream-sets"><code>max_hops</code></a> below). It is
            recommended that all the exchanges linked by federation are of the
            same type (i.e. backing-type). Mixing types will lead to strange
            routing behaviour.
          </p>
          <p>
            The backing-type cannot be <code>x-federation</code>.
          </p>
        </dd>

        <dt>
          <b>What are typical uses for federated exchanges?</b>
        </dt>
        <dd>
          <p>
            One typical use would be to have the same "logical" exchange
            distributed over many brokers. Each broker would declare a federated
            exchange with all the other federated exchanges upstream. (The links
            would form a complete bi-directional graph on <i>n</i> exchanges.)
          </p>
          <p>
            Another use would be to implement massive fanout - a single "root"
            exchange in one broker (which need not be federated) can be declared
            as upstream by many other federated exchanges in other brokers. In
            turn, each of these can be upstream for many more exchanges, and so
            on.
          </p>
        </dd>
      </dl>

      <doc:subsection name="details">
        <doc:heading>Implementation</doc:heading>
          <p>
            Inter-broker communication is implemented using AMQP (optionally
            secured with SSL). Bindings are grouped together and bind / unbind
            commands are sent to the upstream exchange. Therefore the federated
            exchange only receives messages for which it has a subscription. The
            bindings are sent upstream asynchronously - so the effect of adding
            or removing a binding is only guaranteed to be seen eventually.
          </p>
      </doc:subsection>

    </doc:section>

    <doc:section name="getting-started">
      <doc:heading>Getting Started</doc:heading>

      <p>
        The federation plugin is included in the RabbitMQ distribution. To
        enable it, use
        <a href="man/rabbitmq-plugins.1.man.html">rabbitmq-plugins</a>:
      </p>
      <pre class="example">    rabbitmq-plugins enable rabbitmq_federation</pre>

      <p>
        When using a federated exchange in a cluster, all the nodes of the
        cluster must have the federation plugin installed. Any node can declare
        a federated exchange and its properties are shared in the cluster as
        usual. If a node fails, links to upstream exchanges will be recreated on
        a surviving node.
      </p>
    </doc:section>

    <doc:section name="configuration">
      <doc:heading>Configuration</doc:heading>

      <p>
        Federated exchanges may be statically declared in the federation plugin
        configuration, requiring no further exchange set-up after the broker is
        started. Alternatively, some information may be statically configured
        and the federated exchanges themselves <a href="#over-amqp">declared
        dynamically</a> like other exchange types.
      </p>

      <p>
        The configuration for the federation plugin in the
        <a href="configure.html#configuration-file">broker configuration
        file</a> has the following structure:
      </p>
<pre class="example">
    {rabbitmq_federation,
     [ {exchanges, [[{exchange, "my-exchange"}, ... ], ... ]},
       {upstream_sets, [{"my-set", [ ... ]}, ... ]},
       {connections, [{"remote-server", [ ... ]}, ... ]},
       {local_username, "myusername"},
       {local_nodename, "my-server"}
     ]
    }
</pre>
      <p>
        It is a list of the (federated) <code>exchanges</code> to
        declare, a list of named <code>upstream-sets</code>, and a
        list of named <code>connections</code>. The
        settings <code>local_username</code>
        and <code>local_nodename</code> are explained below.
      </p>
      <p>
        The general idea is that each federated exchange links to a set of
        upstream exchanges (an <code>upstream_set</code>). Each
        exchange in the <code>exchanges</code> list names one of
        the sets defined in <code>upstream_sets</code>.
      </p>
      <p>
        The <code>upstream_sets</code> list contains <i>sets</i> of
        upstream exchanges. Each set of upstream exchanges is named in the list.
        These named sets may also be referenced on the AMQP protocol (as
        argument <code>"upstream-set"</code>) when dynamically declaring a
        federated exchange (of type <code>x-federation</code>).
      </p>
      <p>
        Each element of an upstream set is an upstream exchange, which will
        need to connect to the broker where the exchange resides. The connection
        to use is the name of one of the connections in the connections list.
      </p>
      <p>
        All of these settings are optional. If
        the <code>exchanges</code> list is present, the federated
        exchanges are declared when the broker starts. It is necessary
        to specify at least one named upstream set before any
        federated exchange can be declared, either statically
        or <a href="over-amqp">using an AMQP client</a>.
      </p>

      <p>
        We define the settings in more detail.  A (deliberately verbose) example
        configuration is given <a href="#example-config">below</a>.
      </p>

      <doc:subsection name="exchanges">
        <doc:heading>exchanges</doc:heading>
        <p>
          The list of exchanges looks like a set of
          <code>exchange.declare</code>s for the most part, but with each
          declaration including the name of an <code>upstream_set</code>,
          representing a list of exchanges whose messages should be copied to
          the local exchange. Note that the <code>type</code> parameter should
          match the type of all the upstream exchanges for routing to work
          sensibly.
        </p>

        <p>
          Here are the properties of an element in the exchanges list:
        </p>
        <dl>
          <dt><code>exchange</code>
          </dt>
          <dd>
            The name of the federated exchange to be created (exchange type
            <code>x-federation</code> assumed). Mandatory. The names in this
            list should be distinct.
          </dd>
          <dt><code>virtual_host</code></dt>
          <dd>
            The virtual host in which this exchange is created. Defaults to the
            broker's <code>default_vhost</code>.
          </dd>
          <dt><code>type</code></dt>
          <dd>
            The backing-type of this federated exchange. Mandatory. (This cannot
            be <code>x-federation</code>.)
          </dd>
          <dt><code>durable</code></dt>
          <dd>
            The <code>durable</code> property of the created federated exchange.
            Default <code>true</code>.
          </dd>
          <dt><code>auto_delete</code></dt>
          <dd>
            The <code>auto_delete</code> property of the created federated
            exchange. Default <code>false</code>.
          </dd>
          <dt><code>internal</code></dt>
          <dd>
            The <code>internal</code> property of the created federated
            exchange. Default <code>false</code>.
          </dd>
          <dt><code>upstream_set</code></dt>
          <dd>
            The name of an element of the <code>upstream_sets</code> list.
            Mandatory.
          </dd>
        </dl>

        <p>
          The static configuration will only declare federated exchanges on the
          local broker. It does not ensure the upstream exchanges exist.
        </p>
      </doc:subsection>

      <doc:subsection name="upstream-sets">
        <doc:heading>upstream_sets</doc:heading>
        <p>
          Each element of the <code>upstream_sets</code> list is a mapping from
          a name to a list of upstream exchanges. Each upstream exchange entry
          is a property list:
        </p>
<pre class="example">
  {upstream_sets, [{"set_name", [<i>property-list</i>, <i>property-list</i>, ... ]}, ... ]}
</pre>
        <p>
          where <code>"set_name"</code> is a name mentioned in an element of the
          <code>exchanges</code> list. The properties can be:
        </p>

        <dl>
          <dt><code>connection</code></dt>
          <dd>
            The name of a connection from the connection list. Mandatory.
          </dd>

          <dt><code>exchange</code></dt>
          <dd>
            <p>
              The name of the upstream exchange. Default is to use the same name
              as the federated exchange being created.
            </p>
            <p>
              If this name is omitted one <code>upstream_set</code> can be
              referenced by more than one federated exchange and still refer to
              distinct upstream exchanges. Multiple families of exchanges, with
              common names on a set of brokers, can be federated simply by this
              technique.
            </p>
          </dd>

          <dt><code>max_hops</code></dt>
          <dd>
            <p>
              The maximum number of times a message can be copied over a link,
              including this link. The default is 1.
            </p>
            <p>
              If this limit is exceeded on this link, the message is quietly
              discarded. This prevents messages from being indefinitely copied
              when there are circular topologies, and can reduce or prevent
              message duplication.
            </p>
          </dd>
        </dl>
      </doc:subsection>

      <doc:subsection name="connections">
        <doc:heading>connections</doc:heading>
        <p>
          The <code>connections</code> list specifies how to connect to brokers.
          It takes the form:
        </p>
<pre class="example">
  {connections, [{"conn_name", [<i>connection-property-list</i>]}, ... ]}
</pre>
        <p>
          where <code>"conn_name"</code> is a name mentioned in an upstream
          property list. The <code><i>connection-property-list</i></code> can
          contain the following properties:
        </p>

        <dl>
          <dt><code>host</code></dt>
          <dd>
            The hostname to connect to. Mandatory.
          </dd>

          <dt><code>protocol</code></dt>
          <dd>
            <code>"amqp"</code> or <code>"amqps"</code>. Default is
            <code>"amqp"</code>.
          </dd>

          <dt><code>port</code></dt>
          <dd>
            Port to connect to. Default is 5672 (or 5671 when using SSL).
          </dd>

          <dt><code>virtual_host</code></dt>
          <dd>
            The virtual host to connect to. Default is the virtual host
            for the federated exchange.
          </dd>

          <dt><code>username</code></dt>
          <dd>
            The user to connect as. Default is <code>"guest"</code>. This user
            will need the appropriate permissions to create exchanges and queues
            with names beginning with "federation:", and to bind to the upstream
            exchange.
          </dd>

          <dt><code>password</code></dt>
          <dd>
            The password to use when connecting as <code>username</code>.
            Default is <code>"guest"</code>.
          </dd>

          <dt><code>mechanism</code></dt>
          <dd>
            The <a href="authentication.html">SASL mechanism</a> to use. One of:
            <ul>
              <li>
                <code>default</code> - to use PLAIN or AMQPLAIN by negotiation
                (this is the default),
              </li>
              <li>
                <code>'EXTERNAL'</code> - to use SASL EXTERNAL authentication,
                that is, <code>rabbitmq-auth-mechanism-ssl</code>.
              </li>
            </ul>
            (Note the single quotes here.)
          </dd>

          <dt><code>prefetch_count</code></dt>
          <dd>
            The maximum number of unacknowledged messages copied over a link at
            any one time. Default is <code>'none'</code>, meaning there is no
            limit.
          </dd>

          <dt><code>reconnect_delay</code></dt>
          <dd>
            The duration (in seconds) to wait before reconnecting to the broker
            after being disconnected. Default is 1.
          </dd>

          <dt><code>heartbeat</code></dt>
          <dd>
            The AMQP heartbeat interval (in seconds) on the connection. Default
            is <code>'none'</code>, meaning there are no heartbeats.
          </dd>

          <dt><code>expires</code></dt>
          <dd>
            <p>
              The expiry time (in milliseconds) after which an <i>upstream
              queue</i> may be deleted, if the connection is lost. The default
              is <code>'none'</code>, meaning the queue should never expire.
            </p>
            <p>
              Messages are buffered in a queue in the upstream exchange's broker
              before being federated. This is called the <i>upstream queue</i>.
              This setting controls how long the queue will last before it is
              eligible for deletion if the connection is lost.
            </p>
            <p>
              This value is used to set the <code>"x-expires"</code> argument
              for the upstream queue.
            </p>
          </dd>

          <dt><code>message_ttl</code></dt>
          <dd>
            <p>
              The expiry time for messages in the <i>upstream queue</i> (see
              <code>expires</code>), in milliseconds. Default is
              <code>'none'</code>, meaning messages should never expire.
            </p>
            <p>
              This value is used to set the <code>"x-message-ttl"</code>
              argument for the upstream queue.
            </p>
          </dd>

          <dt><code>ha_policy</code></dt>
          <dd>
            Determines the <code>"x-ha-policy"</code> argument for the
            <i>upstream queue</i> (see <code>expires</code>). Default is
            <code>'none'</code>, meaning the queue is not HA.
          </dd>

          <dt><code>ssl_options</code></dt>
          <dd>
            The client SSL connection options. See the Erlang client
            documentation for more details. Default is that there are no
            options.
          </dd>
        </dl>
      </doc:subsection>

      <doc:subsection name="other-config">
        <doc:heading>local_username</doc:heading>
        <p>
          The <code>local_username</code> setting specifies the user under which
          to publish messages to the (local) federated exchanges. The default is
          <code>"guest"</code>. This user will need the appropriate permissions
          to publish messages to these exchanges.
        </p>

        <doc:heading>local_nodename</doc:heading>
        <p>
          The <code>local_nodename</code> setting specifies the name this node
          should use to identify itself to other nodes in the federation graph.
          (The default is constructed from the Erlang node and the machine's
          fully-qualified domain name.)
        </p>
        <p>
          You should only have to specify this explicitly if your DNS
          will not give the relevant machines distinct names.
        </p>
      </doc:subsection>

    </doc:section>

    <doc:section name="over-amqp">
      <doc:heading>Declaring Federated Exchanges Over AMQP</doc:heading>

      <p>
        In order to declare federated exchanges dynamically, using an AMQP
        client, it is still necessary to <a href="#configuration">statically
        configure</a> <code>upstream_sets</code> and the
        <code>connections</code> to support them.
      </p>
      <p>
        A federated exchange can then be declared as follows:
      </p>

      <ul>
        <li>
          Declare the downstream exchange with type <code>x-federation</code>.
        </li>
        <li>
          On the declare exchange method supply <i>arguments</i> named
          <code>"type"</code> and <code>"upstream-set"</code>, both of type
          <code>"long string"</code>. The value of the <code>"type"</code>
          argument should be the <i>backing-type</i>; the value of the
          <code>"upstream-set"</code> argument should be the name of an
          <i>upstream set</i> from the static configuration. (Note that over
          AMQP <code>upstream-set</code> uses a hyphen, but in the static
          <code>exchanges</code> configuration <code>upstream_set</code>
          uses an underscore.)
        </li>
      </ul>

      <p>
        Here is an example using the Java client:
      </p>

<pre class="example">
  Map&lt;String, Object> args = new HashMap&lt;String, Object>();
  args.put("type", "topic");
  args.put("upstream-set", "my-upstream-set");

  <i>// Channel ch = ...;</i>
  ch.exchangeDeclare("my-federated-exchange", "x-federation", true, false, args);
</pre>
    </doc:section>

    <doc:section name="example-config">
      <doc:heading>Example Configuration</doc:heading>

      <p>
        A verbose configuration might look like this:
      </p>

<pre class="example">
  {rabbitmq_federation,
   [ {exchanges, [[{exchange,     "my-exchange"},
                   {virtual_host, "/"},
                   {type,         "topic"},
                   {durable,      true},
                   {auto_delete,  false},
                   {internal,     false},
                   {upstream_set, "my-upstreams"}]
                 ]},
     {upstream_sets, [{"my-upstreams", [[{connection, "upstream-server"},
                                         {exchange,   "my-upstream-x"},
                                         {max_hops,   2}],
                                        [{connection, "another-server"}]
                                       ]}
                     ]},
     {connections, [{"upstream-server", [{host,            "upstream-server"},
                                         {protocol,        "amqps"},
                                         {port,            5671},
                                         {virtual_host,    "/"},
                                         {username,        "myusername"},
                                         {password,        "secret"},
                                         {mechanism,       default},
                                         {prefetch_count,  1000},
                                         {reconnect_delay, 5},
                                         {heartbeat,       1},
                                         {expires,         30000},
                                         {message_ttl,     10000},
                                         {ha_policy,       "all"},
                                         {ssl_options,
                                          [{cacertfile, "/path/to/cacert.pem"},
                                           {certfile,   "/path/to/cert.pem"},
                                           {keyfile,    "/path/to/key.pem"},
                                           {verify,     verify_peer},
                                           {fail_if_no_peer_cert, true}
                                          ]}
                                        ]},
                    {"another-server", [{host, "another-server"}]}
                   ]},
     {local_username, "myusername"},
     {local_nodename, "my-server"}
   ]
  }
</pre>
      <p>
        The configuration above declares one federated (topic) exchange (called
        <code>"my-exchange"</code>). This exchange links to <i>two</i> upstream
        exchanges (defined in the upstream set called
        <code>"my-upstreams"</code>).
      </p>
      <p>
        One upstream exchange is called <code>"my-upstream-x"</code> and is on a
        server on host <code>"upstream-server"</code>, and the other is called
        <code>"my-exchange"</code> (it takes its default name from the local
        federated exchange) and is on a server on the host
        <code>"another-server"</code>.
      </p>
      <p>
        The local federation plugin actions are taken under the user
        <code>"myusername"</code>, which is also the user used to link to the
        host <code>"upstream-server"</code> on an SSL connection. The host
        <code>"another-server"</code> is linked to with user name
        <code>"guest"</code> on an unsecured connection.
      </p>
    </doc:section>

  </body>
</html>
