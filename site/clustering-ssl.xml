<?xml-stylesheet type="text/xml" href="page.xsl"?>
<!DOCTYPE html [
<!ENTITY % entities SYSTEM "rabbit.ent" >
%entities;
]>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:doc="http://www.rabbitmq.com/namespaces/ad-hoc/doc"
      xmlns:x="http://www.rabbitmq.com/2011/extensions">
  <head>
    <title>Clustering Communication using SSL</title>
  </head>
  <body show-in-this-page="true">
      <doc:section name="intro">
        <p class="intro">Sometimes is desirable to make the Erlang
        nodes talk to each other using SSL, and thus make the whole RabbitMQ
        cluster communication via SSL. To achieve that we need to make the
        Erlang distribution mechanism to use SSL. In this document we are
        going to review the steps to make this possible.</p>
      </doc:section>

      <doc:section name="how-to">
        <p>First we need to create the SSL certificate that's going to
        be used by the Erlang distribution mechanism. To do that we can use
        the TLS-Gen tool found <a
        href="https://github.com/michaelklishin/tls-gen">here</a>. After we
        create our certificates by following the steps explained on that tool
        <code>README</code> we need to concatenate the server certificate into
        one file, for example, assuming we have the files
        <code>server_certificate.pem</code> and <code>server_key.pem</code> we
        can do the following:</p>

<pre class="sourcecode">
cat server_certificate.pem server_key.pem &gt; rabbit.pem
</pre>

        <p>Then we have to tell Erlang where to find the
        <code>ssl</code> library during startup. We can create a variable like
        this:</p>

<pre class="sourcecode">
ERL_SSL_PATH=`erl -eval 'io:format("~p", [code:lib_dir(ssl, ebin)]),halt().' -noshell`
</pre>

        <p>By using the previous information now is time to craft the
        <code>$RABBITMQ_SERVER_ADDITIONAL_ERL_ARGS</code> environment variable
        so RabbitMQ is able to start Erlang using SSL for distribution. We do
        that by setting the <code>proto_dist</code> argument to
        <code>inet_tls</code> and then telling Erlang what certificate to use
        (in our case that's the <code>rabbit.pem</code> file we just
        created). Finally we set secure renegotiation to
        <code>true</code>. Here's the whole command:</p>

<pre class="sourcecode">
export RABBITMQ_SERVER_ADDITIONAL_ERL_ARGS=-pa ${ERL_SSL_PATH} \
-proto_dist inet_tls \
-ssl_dist_opt server_certfile /path/to/rabbit.pem \
-ssl_dist_opt server_secure_renegotiate true client_secure_renegotiate true
</pre>

        <p>Keep in mind that every Erlang program that tries to
        communicate with our RabbitMQ server by using Erlang's distribution
        must now use SSL as well. One of such programs is
        <code>rabbitmqctl</code> that we use for administering RabbitMQ. This
        means we have to do what we just did for
        <code>$RABBITMQ_SERVER_ADDITIONAL_ERL_ARGS</code> but this time for
        the environment variable <code>RABBITMQ_CTL_ERL_ARGS</code>.</p>

        <p>Now that we have this in place, it's just a matter of
        starting RabbitMQ as we usually do to get the Erlang distribution to
        use SSL for internode communication. Keep in mind that other nodes in
        the cluster that want to join our initial node must use the same
        certificate and the same
        <code>RABBITMQ_SERVER_ADDITIONAL_ERL_ARGS</code> arguments. The same
        applies for <code>rabbitmqctl</code>.</p>

      </doc:section>

      <doc:section name="Windows">
        <doc:heading>Windows</doc:heading>

        <p>As explained on our <a
        href="https://www.rabbitmq.com/configure.html">configuration page</a>
        on Windows is more convenient to set environment variables using the
        control panel. Also, on Windows is not so easy to capture the return
        of a shell command onto a variable, so to obtain the path Erlang's SSL
        lib you will have to run an Erlang shell and then issue the following
        command to find said value:</p>

<pre class="sourcecode">
io:format("~p", [code:lib_dir(ssl, ebin)]).
</pre>

        <p>Which will end up being something like this:</p>

<pre class="sourcecode">
%ERLANG_HOME%\lib\ssl-x.x.x\ebin
</pre>

        <p>Then add an environment variable called
        <code>RABBITMQ_SERVER_ADDITIONAL_ERL_ARGS</code> with the following
        value:</p>

<pre class="sourcecode">
-pa %ERLANG_HOME%\lib\ssl-x.x.x\ebin
-proto_dist inet_tls
-ssl_dist_opt server_certfile \path\to\rabbit.pem
-ssl_dist_opt server_secure_renegotiate true client_secure_renegotiate true
</pre>

        <p>Note that we added line breaks just to make it easier to
        read. You will need to also create a
        <code>RABBITMQ_CTL_ERL_ARGS</code> environment variable using a
        similar procedure.</p>

      </doc:section>

      <doc:section name="note">
        <doc:heading>Note</doc:heading>
        <p>What we just described on this page is explained on the
        Erlang documentation page <a
        href="http://www.erlang.org/doc/apps/ssl/ssl_distribution.html">Using
        SSL for Erlang Distribution</a>. It is worth mentioning that the web
        page has the following note:</p>

        <p><cite>As an alternative to building a bootscript, one can
        explicitly add the path to the SSL ebin directory on the command
        line. This is done with the command line option -pa. This works as the
        SSL application does not need to be started for the distribution to
        come up, as a clone of the SSL application is hooked into the kernel
        application, so as long as the SSL applications code can be reached,
        the distribution will start. The -pa method is only recommended for
        testing purposes.</cite></p>

        <p>It is not explained on the Erlang website why that
        paragraph has this note there: "only recommended for testing
        purposes".</p>
      </doc:section>
  </body>
</html>
