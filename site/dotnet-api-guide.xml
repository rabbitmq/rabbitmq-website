<?xml-stylesheet type="text/xml" href="page.xsl"?>
<!DOCTYPE html [
<!ENTITY % entities SYSTEM "rabbit.ent" >
%entities;
]>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:doc="http://www.rabbitmq.com/namespaces/ad-hoc/doc">
    <head>
        <title>.NET/C# Client API Guide</title>
    </head>
    <body show-in-this-page="true">
        <p class="intro">
            This page gives an overview of the RabbitMQ .NET/C# client API.
        </p>
        <p class="intro">
            The code samples given here demonstrate connecting to RabbitMQ and
            performing several common operations with the client.
        </p>

        <p class="intro">
            The library is open-source, and is dual-licensed under <a
            href="http://www.apache.org/licenses/LICENSE-2.0">the Apache
            License v2</a> and <a href="mpl.html">the Mozilla Public License
            v1.1</a>.
        </p>

        <p class="intro">
            The client is dual-licensed under

            <ul>
                <li><a href="http://www.apache.org/licenses/LICENSE-2.0.html">Apache Public License 2.0</a></li>
                <li><a href="https://www.mozilla.org/MPL/1.1/">Mozilla Public License</a></li>
            </ul>
        </p>

        <p>
          The client API is closely modelled on the AMQP 0-9-1 protocol specification,
          with additional abstractions for ease of use.
        </p>

        <p>
          This section gives an overview of the RabbitMQ .NET client API.

          Only the basics of using the library are covered: for full detail,
          please see the javadoc-like API documentation generated from the
          source code.
        </p>

        <doc:section name="classoverview">
          <doc:heading>Major namespaces, interfaces and classes</doc:heading>
          <p>
            The core API interfaces and classes are defined in the <code>RabbitMQ.Client</code> namespace:

<pre class="sourcecode">
    using RabbitMQ.Client;
</pre>

            The core API interfaces and classes are

            <ul>
              <li><code>IModel</code>: represents an AMQP 0-9-1 data channel, and provides most
              of the operations (protocol methods).</li>

              <li><code>IConnection</code>: represents an AMQP connection</li>

              <li><code>ConnectionFactory</code>: constructs <code>IConnection</code> instances</li>
            </ul>

            Other useful interfaces and classes include:

            <ul>
              <li><code>QueueingBasicConsumer</code> receives messages delivered from the server</li>
            </ul>

            Public namespaces other than <code>RabbitMQ.Client</code> include:

            <ul>
              <li>
                <code>RabbitMQ.Client.Events</code>: various events and event handlers
                nthat are part of the client library.
              </li>
              <li>
                <code>RabbitMQ.Client.Exceptions</code>: exceptions visible to the user
                of the AMQP client library.
              </li>
            </ul>
          </p>

          <p>
            All other namespaces are reserved for private implementation detail of
            the library, although members of private namespaces are usually made
            available to applications using the library in order to permit
            developers to implement workarounds for faults or design mistakes they
            discover in the library implementation. Applications cannot rely on
            any classes, interfaces, member variables etc. that appear within
            private namespaces remaining stable across releases of the library.
          </p>
        </doc:section>


        <doc:section name="connecting">
          <doc:heading>Connecting to a Broker</doc:heading>
          <p>
            The following two code snippets connect to an AMQP broker:

<pre>
ConnectionFactory factory = new ConnectionFactory();
factory.UserName = user;
factory.Password = pass;
factory.VirtualHost = vhost;
factory.HostName = hostName;

IConnection conn = factory.CreateConnection();
</pre>

<pre class="sourcecode">
ConnectionFactory factory = new ConnectionFactory();
factory.Uri = "amqp://user:pass@hostName:port/vhost";

IConnection conn = factory.CreateConnection();
</pre>
          </p>

          <p>
            Since the .NET client uses a stricter interpretation of the AMQP 0-9-1 URI
            spec than the other clients, care must be taken when using URIs.  In
            particular, the host part must not be omitted and virtual hosts with
            empty names are not addressable.

            All factory properties have default values. The default value for a property will be used if the property remains unassigned prior to creating a connection:

            <dl>
              <dt>Username</dt>
              <dd><code>"guest"</code></dd>

              <dt>Password</dt>
              <dd><code>"guest"</code></dd>

              <dt>Virtual host</dt>
              <dd><code>"/"</code></dd>

              <dt>Hostname</dt>
              <dd><code>"localhost"</code></dd>

              <dt>port</dt>
              <dd>
                <code>5672</code> for regular connections,
                <code>5671</code> for connections that use TLS
              </dd>
            </dl>
          </p>

          <p>
            The <code>IConnection</code> interface can then be used to open a channel:

<pre class="sourcecode">
IModel channel = conn.CreateModel();
</pre>

            The channel can now be used to send and receive messages,
            as described in subsequent sections.
          </p>
        </doc:section>

        <doc:section name="using-exchanges-and-queues">
          <doc:heading>Using Exchanges and Queues</doc:heading>

          <p>
            Client applications work with exchanges and queues, the high-level
            building blocks of AMQP 0-9-1. These must be "declared" before they can be
            used. Declaring either type of object simply ensures that one of that
            name exists, creating it if necessary.

            Continuing the previous example, the following code declares an
            exchange and a queue, then binds them together.

<pre class="sourcecode">
model.ExchangeDeclare(exchangeName, ExchangeType.Direct);
model.QueueDeclare(queueName, false, false, false, null);
model.QueueBind(queueName, exchangeName, routingKey, null);
</pre>

            This will actively declare the following objects:

            <ul>
              <li>a non-durable, non-autodelete exchange of "direct" type</li>
              <li>a non-durable, non-exclusive, non-autodelete queue</li>
            </ul>

            The exchange can be customised by using additional parameters.
            The above code then binds the queue to the exchange with the given
            routing key.

            Note that many Channel API methods are overloaded. The convenient
            short form of <code>ExchangeDeclare</code> uses sensible defaults. There are
            also longer forms with more parameters, to let you override these
            defaults as necessary, giving full control where needed.

            This "short version, long version" pattern is used throughout the API.
          </p>
        </doc:section>

        <doc:section name="publishing">
          <doc:heading>Publishing Messages</doc:heading>

          <p>
            To publish a message to an exchange, use <code>IModel.BasicPublish</code> as
            follows:

<pre class="sourcecode">
byte[] messageBodyBytes = System.Text.Encoding.UTF8.GetBytes("Hello, world!");
model.BasicPublish(exchangeName, routingKey, null, messageBodyBytes);
</pre>

            For fine control, you can use overloaded variants to specify the
            mandatory flag, or send messages with basic-class header properties:

<pre class="sourcecode">
byte[] messageBodyBytes = System.Text.Encoding.UTF8.GetBytes("Hello, world!");
IBasicProperties props = model.CreateBasicProperties();
props.ContentType = "text/plain";
props.DeliveryMode = 2;
mode.BasicPublish(exchangeName,
                     routingKey, props,
                     messageBodyBytes);
</pre>

            This sends a message with delivery mode 2 (persistent) and
            content-type "text/plain". See the definition of the <code>
            IBasicProperties</code> interface for more information about the available
            header properties.
          </p>
        </doc:section>

        <doc:section name="basic-get">
          <doc:heading>Retrieving Individual Messages</doc:heading>

          <p>
            To retrieve individual messages, use <code>IModel.BasicGet</code>. The
            returned value is an instance of BasicGetResult, from which the header
            information (properties) and message body can be extracted:

<pre class="sourcecode">
bool noAck = false;
BasicGetResult result = channel.BasicGet(queueName, noAck);
if (result == null) {
    // No message available at this time.
} else {
    IBasicProperties props = result.BasicProperties;
    byte[] body = result.Body;
    ...
</pre>

            Since <code>noAck = false</code> above, you must also call <code>
            IModel.BasicAck</code> to acknowledge that you have successfully received
            and processed the message:

<pre class="sourcecode">
    ...
    // acknowledge receipt of the message
    channel.BasicAck(result.DeliveryTag, false);
}
</pre>
          </p>
        </doc:section>


        <doc:section name="basic-consume">
          <doc:heading>Retrieving Messages By Subscription</doc:heading>

          <p>
            Another way to receive messages is to set up a subscription using the
            <code>IBasicConsumer</code> interface. The messages will then be delivered
            automatically as they arrive, rather than having to be requested
            proactively.

            The easiest and safest way to implement a consumer is to use the
            convenience class <code>QueueingBasicConsumer</code>, and retrieve
            deliveries from the <code>SharedQueue</code> instance contained therein:

@code java
 QueueingBasicConsumer consumer = new QueueingBasicConsumer(channel);
 String consumerTag = channel.BasicConsume(queueName, false, consumer);
 while (true) {
     try {
         RabbitMQ.Client.Events.BasicDeliverEventArgs e =
           (RabbitMQ.Client.Events.BasicDeliverEventArgs)
           consumer.Queue.Dequeue();
         IBasicProperties props = e.BasicProperties;
         byte[] body = e.Body;
         // ... process the message
         channel.BasicAck(e.DeliveryTag, false);
     } catch (OperationInterruptedException ex) {
         // The consumer was removed, either through
         // channel or connection closure, or through the
         // action of IModel.BasicCancel().
         break;
     }
 }

Another alternative is to subclass <code>DefaultBasicConsumer</code>,
overriding methods as necessary, or implement <code>IBasicConsumer</code>
directly. You will generally want to implement the core method <code>IBasicConsumer.HandleBasicDeliver</code>.

More sophisticated consumers will need to implement further
methods. In particular, <code>HandleModelShutdown</code> traps
channel/connection closure. Consumers can also implement <code>
HandleBasicCancelOk</code> to be notified of cancellations.

The <code>ConsumerTag</code> property of <code>DefaultBasicConsumer</code> can be
used to retrieve the server-generated consumer tag, in cases where
none was supplied to the original <code>IModel.BasicConsume</code> call.

You can cancel an active consumer with <code>IModel.BasicCancel</code>:

@code java
 channel.BasicCancel(consumerTag);

When calling the API methods, you always refer to consumers by their
consumer tags, which can be either client- or server-generated as
explained in the AMQP 0-9-1 specification document.
          </p>
        </doc:section>


        <doc:section name="disconnecting">
          <doc:heading>Disconnecting from a Broker</doc:heading>

          <p>
            To publish a message to an exchange, use <code>IModel.BasicPublish</code> as
            follows:

<pre class="sourcecode">
byte[] messageBodyBytes = System.Text.Encoding.UTF8.GetBytes("Hello, world!");
model.BasicPublish(exchangeName, routingKey, null, messageBodyBytes);
</pre>

            For fine control, you can use overloaded variants to specify the
            mandatory flag, or send messages with basic-class header properties:

<pre class="sourcecode">
byte[] messageBodyBytes = System.Text.Encoding.UTF8.GetBytes("Hello, world!");
IBasicProperties props = channel.CreateBasicProperties();
props.ContentType = "text/plain";
props.DeliveryMode = 2;
model.BasicPublish(exchangeName,
                   routingKey, props,
                   messageBodyBytes);
</pre>

            This sends a message with delivery mode 2 (persistent) and
            content-type "text/plain". See the definition of the <code>
            IBasicProperties</code> interface for more information about the available
            header properties.
          </p>
        </doc:section>


        <doc:section name="concurrency">
          <doc:heading>Concurrency Consideration for consumers</doc:heading>

          <p>
            Each <code>IConnection</code> instance is, in the current implementation,
            backed by a single background thread that reads from the socket and
            dispatches the resulting events to the application.
            Additionally there are two threads responsible for <code>Heartbeat</code> support,
            if connection negotiation turned it on.

            Usually, therefore, there will be four threads active in an application
            using this library:

            <dl>
              <dt>the application thread</dt>
              <dd>
                contains the application logic, and makes
                calls on <code>IModel</code> methods to perform protocol operations.
              </dd>

              <dt>the connection thread</dt>
              <dd>
                hidden away and completely managed by the
               <code>IConnection</code> instance.
              </dd>

              <dt>the heartbeat read thread</dt>
              <dd>
               continuously checking if <code>IConnection</code>
               instance has not missed too many <code>Heartbeat</code> frames from the broker
              </dd>

              <dt>the heartbeat write thread</dt>
              <dd>
               continuosuly checking if <code>IConnection</code>
               instance should send <code>Heartbeat</code> frame to the broker
              </dd>
            </dl>

            The one place where the nature of the threading model is visible to
            the application is in any callback the application registers with the
            library. Such callbacks include:

            <ul>
             <li>any <code>IBasicConsumer</code> method</li>
             <li>the <code>BasicReturn</code> event on <code>IModel</code></li>
             <li>any of the various shutdown events on <code>IConnection</code>, <code>IModel</code> etc.</li>
            </ul>

            Application callback handlers <strong>must not</strong> invoke blocking
            operations (such as <code>IModel.QueueDeclare</code> or <code>
            IModel.BasicCancel</code>). If they do, the
            channel will deadlock. The underlying implementation reason
            is that the <code>IBasicConsumer</code> callbacks are invoked in the connection's
            thread rather than in the application's thread.

            Only asynchronous operations without content are safe for use
            within callbacks, such as <code>IModel.BasicAck</code>. It is not safe to
            use <code>IModel.BasicPublish</code> in callbacks, because flow control
            could block publication.

            For this reason, <code>QueueingBasicConsumer</code> is the safest way of
            subscribing to a queue, because its implementation uses <code>
            RabbitMQ.Util.SharedQueue</code> to pass deliveries over to the application
            thread, where all processing of received deliveries is done, and where
            any <code>IModel</code> operation is safe.

            <doc:subsection name="model-sharing">
              <doc:heading></doc:heading>

              <p>
                In general, <code>IModel</code> instances should not be used by more than
                one thread simultaneously: application code should maintain a clear
                notion of thread ownership for <code>IModel</code> instances.

                If more than one thread needs to access a particular <code>IModel</code>
                instances, the application should enforce mutual exclusion itself. One
                way of achieving this is for all users of an <code>IModel</code> to <code>
                lock</code> the instance itself:

<pre class="sourcecode">
IModel ch = RetrieveSomeSharedIModelInstance();
lock (ch) {
  ch.BasicPublish(...);
}
</pre>

                Symptoms of incorrect serialisation of <code>IModel</code> operations
                include, but are not limited to,

                <ul>
                  <li>invalid frame sequences being sent on the wire (which occurs, for
                  example, if more than one <code>BasicPublish</code> operation is run
                  simultaneously), and/or
                  </li>

                  <li>
                    <code>NotSupportedException</code>s being thrown from a method in class
                    <code>RpcContinuationQueue</code> complaining about <code>"Pipelining of
                    requests forbidden"</code> (which occurs in situations where more than
                    one AMQP 0-9-1 synchronous operation, such as <code>ExchangeDeclare</code>, is run
                    simultaneously).
                  </li>
                </ul>
              </p>
            </doc:subsection>
            </p>
          </doc:section>


        <doc:section name="basic-return">
          <doc:heading>Handling Unroutable Messages</doc:heading>
          <p>
            If a message is published with the "mandatory" flag
            set, but cannot be delivered, the broker will return it to the sending
            client (via a <code>basic.return</code> AMQP 0-9-1 command).

            To be notified of such returns, clients can subscribe to the <code>
            IModel.BasicReturn</code> event. If there are no listeners attached to the
            event, then returned messages will be silently dropped.

<pre class="sourcecode">
model.BasicReturn +=
  new RabbitMQ.Client.Events.BasicReturnEventHandler(...);
</pre>

            The <code>BasicReturn</code> event will fire, for example, if the client
            publishes a message with the "mandatory" flag set to an exchange of
            "direct" type which is not bound to a queue.
          </p>
        </doc:section>

        <doc:section name="disconnecting">
          <doc:heading>Disconnecting from a Broker</doc:heading>
          <p>
            To disconnect, simply close the channel and the connection:

<pre class="sourcecode">
 channel.Close(200, "Goodbye");
 conn.Close();
</pre>

            Note that closing the channel is considered good practice, but isn't
            strictly necessary - it will be done automatically anyway when the
            underlying connection is closed.

            In some situations, you may want the connection to close automatically
            once the last open channel on the connection closes. To achieve this,
            set the <code>IConnection.AutoClose</code> property to true, but only
            <strong>after</strong> creating the first channel:

<pre class="sourcecode">
IConnection conn = factory.CreateConnection(...);
IModel channel = conn.CreateModel();
conn.AutoClose = true;
</pre>

            When <code>AutoClose</code> is true, the last channel to close will also
            cause the connection to close. If it is set to true before any
            channel is created, the connection will close then and there.
          </p>
        </doc:section>

        <doc:section name="connection-recovery">
          <doc:heading>Automatic Recovery From Network Failures</doc:heading>

          <doc:subsection name="connection-recovery">
            <doc:heading>Connection Recovery</doc:heading>

            <p>
              Network connection between clients and RabbitMQ nodes can fail.
              RabbitMQ Java client supports automatic recovery of connections
              and topology (queues, exchanges, bindings, and consumers).

              The automatic recovery process for many applications follows the following steps:

              <ol>
                <li>Reconnect</li>
                <li>Restore connection listeners</li>
                <li>Re-open channels</li>
                <li>Restore channel listeners</li>
                <li>Restore channel <code>basic.qos</code> setting, publisher confirms and transaction settings</li>
              </ol>

              Topology recovery includes the following actions, performed for every channel

              <ol>
                <li>Re-declare exchanges (except for predefined ones)</li>
                <li>Re-declare queues</li>
                <li>Recover all bindings</li>
                <li>Recover all consumers</li>
              </ol>

              To enable automatic connection recovery, set
              <code>ConnectionFactory.AutomaticRecoveryEnabled</code> to true:

<pre class="sourcecode">
ConnectionFactory factory = new ConnectionFactory();
factory.AutomaticRecoveryEnabled = true;
// connection that will recover automatically
IConnection conn = factory.CreateConnection();
</pre>

              If recovery fails due to an exception (e.g. RabbitMQ node is
              still not reachable), it will be retried after a fixed time interval (default
              is 5 seconds). The interval can be configured:

<pre class="sourcecode">
ConnectionFactory factory = new ConnectionFactory();
// attempt recovery every 10 seconds
factory.NetworkRecoveryInterval = TimeSpan.FromSeconds(10);
</pre>
            </p>
          </doc:subsection>

          <doc:subsection name="topology-recovery">
            <doc:heading>Topology Recovery</doc:heading>

            <p>
              Topology recovery involves recovery of exchanges, queues, bindings
              and consumers. It is enabled by default but can be disabled:

<pre class="sourcecode">
ConnectionFactory factory = new ConnectionFactory();

Connection conn = factory.CreateConnection();
factory.AutomaticRecoveryEnabled = true;
factory.TopologyRecoveryEnabled  = false;
</pre>
            </p>
          </doc:subsection>

          <doc:subsection name="basic-ack-and-recovery">
            <doc:heading>Manual Acknowledgements and Automatic Recovery</doc:heading>

            <p>
              When manual acknowledgements are used, it is possible that
              network connection to RabbitMQ node fails between message
              delivery and acknowledgement. After connection recovery,
              RabbitMQ will reset delivery tags on all channels.

              This means that <code>basic.ack</code>, <code>basic.nack</code>, and <code>basic.reject</code>
              with old delivery tags will cause a channel exception. To avoid this,
              RabbitMQ .NET client keeps track of and updates delivery tags to make them monotonically
              growing between recoveries.

              <code>IModel.BasicAck</code>,
              <code>IModel.BasicNack</code>, and
              <code>IModel.BasicReject</code> then translate adjusted
              delivery tags into those used by RabbitMQ.

              Acknowledgements with stale delivery tags will not be
              sent. Applications that use manual acknowledgements and automatic
              recovery must be capable of handling redeliveries.

            </p>
          </doc:subsection>
        </doc:section>

        <doc:subsection name="common-patterns">
          <doc:heading>Common ways of working with AMQP 0-9-1</doc:heading>

          <p>
            When building distributed systems with RabbitMQ, there are a number of
            different messaging patterns that crop up over and over again. In this
            section, we cover some of the most common coding patterns and
            interaction styles:

            <ul>
              <li>Point-to-point messaging: both remote procedure call (RPC), and
              asynchronous messages directed toward a particular receiver.
              </li>

              <li>
                Event broadcasting: one-to-many interactions; transmission of
                messages directed implicitly to a set of interested receivers, with
                collection of zero or more possible responses.
              </li>

              <li>
                Responsibility transfer: choosing which piece of the network is
                responsible for any given message.
              </li>

              <li>
                Reliable message transfer: at-least-once and at-most-once message delivery.
              </li>

              <li>
                Preserving atomicity and idempotence when interacting with external resources.
              </li>
            </ul>

            Limited library support is also available for working with these
            patterns, in the <code>RabbitMQ.Client.MessagePatterns</code> namespace:

            <ul>
              <li>
                <code>Subscription</code> provides a high-level interface to receiving
                messages from the server.
              </li>

              <li>
                <code>SimpleRpcServer</code> builds on <code>Subscription</code> to implement
                an RPC or one-way service.
              </li>

              <li>
                <code>SimpleRpcClient</code> builds on <code>Subscription</code> to interact
                with remote services.
              </li>
            </ul>

            Future releases of the RabbitMQ .NET client library will include
            improved high-level support for the most common messaging patterns and
            their variations.
          </p>
        </doc:subsection>

        <doc:subsection name="point-to-point-messaging">
          <doc:heading>Point-to-point Messaging</doc:heading>

          <p>
            The point-to-point messaging pattern occurs when the publisher of a
            message has a particular receiving application in mind - for instance,
            when a RPC-style service is made available via the AMQP server, or
            when an application in a workflow chain receives a work item from its
            predecessor and sends the transformed work item to its successor.
          </p>

          <h3>Synchronous, Client-Server Remote Procedure Call (RPC)</h3>

          In order to perform request/response RPC,
          <ul>
            <li>some means of addressing the service must be available</li>
            <li>some means of receiving a reply must be available</li>
            <li>some means of correlating the request message to the reply message
            must be available</li>

            <h4>Addressing the service</h4>

            Since AMQP messages are published using a pair of an exchange name and
            a routing key, this is sufficient for addressing a service. Using a
            simple exchange-name/routing-key combination permits a number of
            different ways to implement the service while presenting the same
            interface to clients. For instance, the service could be implemented
            as a single process consuming from a queue, and load-balancing
            internally, or it could be multiple processes consuming from a single
            queue, being handed requests round-robin style, thereby load balancing
            without special coding in the service logic.

            Messages can be addressed to the service request queue either

            <ul>
              <li>directly, using the AMQP default exchange (""); or</li>

              <li>
                indirectly, by using a service-specific exchange, which leaves the
                routing-key free for such purposes as method selection or
                additional service-specific addressing information; or
              </li>

              <li>
                indirectly, by using an exchange shared by multiple services, with
                the service name encoded in the routing key.
              </li>
            </ul>

            Using an exchange other than the default exchange permits other
            applications to receive copies of each request message, which can be
            useful for monitoring, auditing, logging and debugging.

            <h4>Ensuring a service instance is listening</h4>

            AMQP 0-9-1 publish operation (<code>IModel.BasicPublish</code>)
            provides a delivery flag, "mandatory", which can be
            used to ensure service availability at the time a
            request is sent by a client.
            
            Setting the "mandatory" flag causes a request to be returned if it
            cannot be routed to a queue. Returned messages appear as <code>basic.return</code>
            commands, which are made visible to the application via the <code>IModel.BasicReturn</code>
            event on the <code>IModel</code> that was used to publish the message.

            Since published messages are returned to clients via <code>
            basic.return</code> method, and <code>basic.return</code> is an asynchronous
            negative-acknowledgement event, the <em>absence</em> of a <code>basic.return</code>
            for a particular message cannot be taken as a
            confirmation of delivery: the use of delivery flags only provides a
            way of raising the bar, rather than eliminating failure entirely.

            When using delivery flags it is important to be aware that different
            AMQP servers implement the flags in different ways. For example, the
            RabbitMQ server does not support the "immediate" flag. Furthermore,
            depending on the degree of internal asynchrony and distribution that
            those servers exhibit. In particular, the interpretation of
            "mandatory" and "immediate" in situations where <code>Tx</code>-class
            transactions are active is underspecified in both versions 0-8 and 0-9
            of the AMQP specification, and different server implementations behave
            in different ways.

            Additionally, the fact that a message was flagged "mandatory", and
            successfully enqueued on one or more queues, is no guarantee of its
            eventual receipt: most trivially, the queue could be deleted before
            the message is processed, but other situations, like the use of the
            <code>noAck</code> flag by a message consumer, can also make the guarantee
            provided by "mandatory" conditional.

            Alternatively, one could use Publisher Confirms. Setting a channel
            into <em>confirm mode</em> by calling <code>IModel.ConfirmSelect</code> causes
            the broker to send a <code>Basic.Ack</code> after each message is processed
            by delivering to a ready consumer or by persisting to disk.

            Once a successfully processed message has been confirmed via the <code>IModel.BasicAcks</code>
            event handler, the broker has assumed responsibility
            for the message and the client may consider the message <em>handled</em>.

            Note that the broker may also <em>negatively acknowledge</em> a message by
            sending back a <code>Basic.Nack</code>. In this case, if a message is
            rejected via the <code>IModel.BasicNacks</code> event handler, the client
            should assume that the message was lost or otherwise
            undeliverable. Also, note that unroutable messages - messages published as mandatory to non-existing queues -
            are both <code>Basic.Return'ed</code> and <code>Basic.Ack'ed</code>.

            <h4>Receiving Replies</h4>

            AMQP 0-9-1 content header (<code>IBasicProperties</code>) contains a
            field called <code>ReplyTo</code>, which can be used to tell the service where to post
            a reply to a received RPC request. Across current RabbitMQ client
            libraries, there are two widely-used formats for the string in the
            <code>ReplyTo</code> header:

            <ul>
              <li>a simple queue name; or</li>

              <li>
                a URI-like string (take care - it is <em>not</em> a URI, it merely
                shares certain superficial characteristics with URIs) of the form
              </li>
            </ul>

   @pre
     [i exchangeType]://[i exchangeName]/[i routingKey]

   where [i <code>exchangeType</code>] is one of <code>fanout</code>, <code>
   direct</code> or <code>topic</code>, and both [i <code>exchangeName</code>] and [i
   <code>routingKey</code>] may be empty strings.

The service instance will post its reply to the named destination, and
the requesting client should arrange to receive messages so addressed,
using either <code>BasicGet</code> or <code>BasicConsume</code> on an
appropriately-bound queue.

**** Correlating a received reply to a transmitted request

AMQP's Basic-class content header (<code>IBasicProperties</code>) contains a
field called <code>CorrelationId</code>, which in AMQP 0-8 and 0-9 is an
unstructured string that can be used to match a request to a reply. A
reply message should have the same <code>CorrelationId</code> as the one
that was attached to the request message.

*** Asynchronous, one-way messaging

In some situations, a simple request-reply interaction pattern is
inappropriate for your application. In these cases, the interaction
pattern of interest can be constructed from asynchronous, one-way,
point-to-point messages.

If an application is to respond to both synchronous, RPC-style
requests, and asynchronous one-way requests, it should use the value
of <code>ReplyTo</code> to decide which interaction style is being requested
of it: if <code>ReplyTo</code> is present and non-empty, the request can be
assumed to be an RPC-style call; otherwise, it should be assumed to be
a one-way message.

The <code>CorrelationId</code> field can be used to group together a number
of related messages, just as for the RPC-style case, but more
generally tying together an arbitrary number of messages.

*** Acknowledgment modes for point-to-point

AMQP can operate in one of two modes, when receiving messages from the
server: auto-acknowledgement mode (when the <code>noAck</code> flag has been
set on <code>BasicGet</code>, <code>BasicConsume</code>, or the <code>
Subscription</code> constructor), or manual-acknowledgement mode. Choosing
the right acknowledgement mode is important for your application:

 - auto-acknowledgement mode means that the server will internally
   mark a message as successfully delivered as it transmits it across
   the network. Messages delivered in auto-acknowledgement mode will
   not generally be redelivered to any other receiver.

 - manual-acknowledgement mode means that the server will wait for
   positive confirmation of receipt before marking a message as
   successfully delivered. Messages delivered in
   manual-acknowledgement mode may be redelivered arbitrarily
   often[footnote Within limits - please see the AMQP specification
   for precise details of when redelivery is permitted and when and
   how it is mandated.</code> until a receiver takes responsibility for a
   message by sending an acknowledgement for it.

In general,

 - if a service is in manual-acknowledgement mode, it should not
   acknowledge the request message until it has replied to it; see the
   section below on interaction with external resources.

 - a client may use auto-acknowledgement mode, depending on the
   consequences of a retransmission of the request message.

*** Library support for point-to-point messaging

The RabbitMQ .NET client library includes basic support for common
tasks involving point-to-point messaging.

**** SimpleRpcServer

The class <code>RabbitMQ.Client.MessagePatterns.SimpleRpcServer</code>
implements synchronous RPC-style request handling as well as
asynchronous message handling. Users should subclass <code>
SimpleRpcServer</code>, overriding one or more of the methods with names
beginning with "<code>Handle</code>".

<code>SimpleRpcServer</code> instances have a request-dispatching loop,
<code>MainLoop</code>, which interprets a request as an RPC-style request
needing a reply if the <code>ReplyTo</code> field of the request's <code>
IBasicProperties</code> is non-null and non-empty. Requests with absent or
empty <code>ReplyTo</code> fields are treated as one-way.

When an RPC-style request has been processed, the reply is sent to the
<code>ReplyTo</code> address. The reply address is first matched against a
regular-expression describing the URI-like syntax given above; if it
matches, the components of the URI-like syntax are used as the reply
address, and if it does not, the whole string is used as a simple
queue name, and the reply is sent to the default exchange ("") with a
routing-key equal to the <code>ReplyTo</code> string.

After a reply message, including possible <code>IBasicProperties</code>
headers, is produced by the service logic, the reply's <code>
CorrelationId</code> is set to be equal to the <code>CorrelationId</code> of the
request, if any, before transmission.

For very basic or unusual asynchronous point-to-point messaging tasks,
a <code>Subscription</code> may be used instead of <code>SimpleRpcServer</code> -
please see the section below on <code>Subscription</code>s.

The basic pattern for implementing a service using <code>
SimpleRpcServer</code> is as follows (assuming a class <code>
MySimpleRpcServerSubclass</code> extending <code>SimpleRpcServer</code>):

@code java
  using (IConnection conn = new ConnectionFactory()
                                  .CreateConnection(serverAddress)) {
      using (IModel ch = conn.CreateModel()) {

          Subscription subscription =
              new Subscription(ch, /* ... */);
          // in the line above, the "..." indicates the parameters
          // used to specify the address to use to route messages
          // to the subscription. This subscription will be used
          // to read service request messages, so the "..." effectively
          // specifies the service address.

          new MySimpleRpcServerSubclass(subscription).MainLoop();
      }
  }

The service logic would be implemented in an override of one of the
<code>HandleCall</code> or <code>HandleCast</code> overloads on <code>
MySimpleRpcServerSubclass</code>. For full details, please see the code
documentation for <code>SimpleRpcServer</code>.

**** SimpleRpcClient

The class <code>RabbitMQ.Client.MessagePatterns.SimpleRpcClient</code>
implements code for interacting with <code>SimpleRpcServer</code>s or
similar.

RPC-style interactions are performed with the <code>Call</code> methods. A
(private) <code>Subscription</code> is set up to receive replies from the
service, and the <code>ReplyTo</code> field is set to point to the
subscription. The <code>CorrelationId</code> field of the request is
initialised to a fresh GUID. Asynchronous/one-way interactions are
simply passed on to <code>IModel.BasicPublish</code> without modification:
it is up to the caller to set <code>CorrelationId</code> in the asynchronous
case.

The class currently has no support for setting the "mandatory" or
"immediate" flags on a published request message, nor for handling any
<code>BasicReturn</code> events that might arise from setting either flag.

The code that retrieves replies from the internal <code>Subscription</code>
currently cannot deal with multiple simultaneously outstanding RPC
requests, because it requires that replies arrive in the same order as
the requests were sent out. Do not attempt to pipeline requests sent
through a single instance of <code>SimpleRpcClient</code> until this
restriction has been lifted. See also the overridable protected method
<code>SimpleRpcClient.RetrieveReply</code>.

The basic pattern for using <code>SimpleRpcClient</code> is as follows:

@code java
  using (IConnection conn = new ConnectionFactory()
                                  .CreateConnection(args[0])) {
      using (IModel ch = conn.CreateModel()) {

          SimpleRpcClient client = new SimpleRpcClient(ch, /* ... */);
          // in the line above, the "..." indicates the parameters
          // used to specify the address to use to route messages
          // to the service.

          // The next three lines are optional:
          client.TimeoutMilliseconds = 5000; // defaults to infinity
          client.TimedOut += new EventHandler(TimedOutHandler);
          client.Disconnected += new EventHandler(DisconnectedHandler);

          byte[] replyMessageBytes = client.Call(requestMessageBytes);
          // other useful overloads of Call() and Cast() are
          // available. See the code documentation of SimpleRpcClient
          // for full details.
      }
  }

Note that a single <code>SimpleRpcClient</code> instance can perform many
(sequential) <code>Call()</code> and <code>Cast()</code> requests! It is
recommended that a single <code>SimpleRpcClient</code> be reused for
multiple service requests, so long as the requests are strictly
sequential.
        </doc:subsection>

        <doc:subsection name="">
          <doc:heading>Event Broadcasting</doc:heading>

The event broadcasting pattern occurs when an application wishes to
indicate a state change or other notification to a pool of
applications without knowing precisely the addresses of each
interested party. Applications interested in a certain subset of
events use AMQP's exchanges and queue-bindings to configure which
events are routed to their own private queues.

Generally, events will be broadcast through <code>topic</code> exchanges,
although <code>direct</code> exchanges, while less flexible, can sometimes
perform better for applications where their limited pattern-matching
capability is sufficient.

*** Publishing events

To publish an event,

 # ensure the exchange exists

 # determine an appropriate routing key (for stocks, a key such as
   STOCK.IBM.NYSE might be appropriate; for other applications, other
   topic hierarchies will naturally arise. See the definition of the
   <code>topic</code> and <code>direct</code> exchange types in the AMQP
   specification)

 # publish the message

For example:

@code java
  using (IConnection conn = new ConnectionFactory()
                                  .CreateConnection(args[0])) {
      using (IModel ch = conn.CreateModel()) {

	  IBasicProperties props = ch.CreateBasicProperties();
          FillInHeaders(props); // or similar
          byte[] body = ComputeBody(props); // or similar

          ch.BasicPublish("exchangeName",
                          "chosen.routing.key",
                          props,
                          body);
      }
  }

See the documentation for the various overloads of <code>BasicPublish</code>
on class <code>RabbitMQ.Client.IModel</code>.

*** Subscription

The class <code>RabbitMQ.Client.MessagePatterns.Subscription</code>
implements most of the boilerplate of receiving messages (including,
in particular, broadcast events) for you, including consumer
declaration and management, but excluding queue and exchange
declaration and queue binding. For example,

@code java
  // "IModel ch" in scope.
  Subscription sub = new Subscription(ch, "STOCK.IBM.#");
  foreach (BasicDeliverEventArgs e in sub) {
    // handle the message contained in e ...
    // ... and finally acknowledge it
    sub.Ack(e);
  }

will start a consumer on the queue using <code>IModel.BasicConsume</code>.
It is assumed that the queue and any bindings have been previously
declared.

<code>Subscription.Ack()</code> should be called for each received event,
whether or not auto-acknowledgement mode is used, because <code>
Subscription</code> internally knows whether an actual network message for
acknowledgement is required, and will take care of it for you in an
efficient way so long as <code>Ack()</code> is always called in your code.

For full details, please see the code documentation for the <code>
Subscription</code> class.

*** Retrieving events - low-level approach

Usually, the high-level approach using <code>Subscription</code> is
sufficient. Occasionally, however, there is a need to use the
low-level AMQP primitives. The low-level approach to retrieving events
is to bind a queue to the exchange concerned with an appropriate
routing-key pattern specification. For instance, assuming that our
application wanted to retrieve all prices regarding IBM on queue
"MyApplicationQueue":

@code java
  // "IModel ch" in scope.
  ch.ExchangeDeclare("prices", "topic");
  ch.QueueDeclare("MyApplicationQueue", false, true, true, null);
  ch.QueueBind("MyApplicationQueue", "prices",
               "STOCK.IBM.#", false, null);

... followed by consumption of messages from "MyApplicationQueue"
using <code>BasicGet</code> or <code>BasicConsume</code>. A more full example is
given in the ApiOverview chapter.

*** Acknowledgment modes for event broadcasting

The same auto-acknowledgement/manual-acknowledgement decision as for
point-to-point messaging is available for consumers of broadcast
events, but the pattern of interaction introduces different tradeoffs:

 - for high-volume messaging where it is occasionally acceptable to
   not receive one of the messages one is interested in,
   auto-acknowledgement mode makes sense

 - for scenarios where every message matching our subscription needs
   to be delivered, manual-acknowledgement is appropriate

For more information, see the section on reliable message transfer
below.

Note also that class <code>Subscription</code> takes care of acknowledgement
and the various acknowledgement modes for you, so long as <code>
Subscription.Ack()</code> is called for each received message.
        </doc:subsection>

        <doc:subsection name="">
          <doc:heading></doc:heading>

          <p>
          </p>
        </doc:subsection>


** Responsibility transfer

In cases where either

 - a non durable exchange and/or queue is used[footnote See the AMQP
   specification for full details of the meaning of "durable" here],
   or

 - a message is published with its <code>
   IBasicProperties.DeliveryMode</code> set to any value other than 2

the message is considered [i transient], and will not (usually) be
written to disk as part of the interaction between the AMQP server and
the various AMQP clients publishing and consuming messages.

When a message is transient, it means that the responsibility for
ultimate processing of the message resides with the endpoints - the
two AMQP clients involved: the publisher, and the consumer.

Responsibility can be partially transferred to the broker by using
durable queues, durable exchanges, persistent-mode delivered messages
(with <code>DeliveryMode</code> set equal to 2), and Publisher Confirms:

- ensure (ahead of time) that the target queue is durable,

- select <code>Confirm</code> mode using <code>IModel.ConfirmSelect</code>,

- publish the message with "mandatory" flag set and <code>
  DeliveryMode</code> set equal to 2,

- listen for acknowledgements and negative acknowledgments by setting
  the <code>IModel.BasicAcks</code> and <code>BasicNacks</code> event handlers.

Once a broker acknowledges a message via the <code>BasicAcks</code> handler,
it has taken responsibility for keeping the message on disk and on the
target queue until some other application retrieves and acknowledges
the message.

If a broker rejects a message via the <code>BasicNacks</code> handler, the
publisher may assume that the message was lost or otherwise
undeliverable.

Note that for unroutable messages are not considered failures and are
both <code>Basic.Return'ed</code> and <code>Basic.Ack'ed</code>.  So, if the
"mandatory" or "immediate" are used, the client must also listen for
returns by setting the <code>IModel.BasicReturn</code> handler.

Responsibility can also be placed with an external database, even
further along the chain - see the section on interaction with external
resources below.

** Reliable message transfer

Messages can be transported between endpoints with different
quality-of-service (QoS) levels. In general, failure cannot be
completely ruled out, but it is important to understand the various
delivery failure modes to understand the kinds of recovery from
failure that are required, and the kinds of situation for which
recovery is possible.

To reiterate: it is not possible to completely rule out failure. The
best that can be done is to narrow the conditions in which failure can
occur, and to notify a system operator when failure is detected.

*** At-least-once delivery

This QoS level assures that a message is delivered to its ultimate
destination at least once. That is, a receiver may receive multiple
copies of the message. If it is important that a side-effect only
occur once for a given message, either at-most-once or exactly-once
QoS levels should be used instead.

To implement at-least-once delivery:

 - publish the message as usual, with some correlation identifier and
   reply-to address on it so that the receiver can acknowledge receipt
   to the sender

 - when receiving a message, send an acknowledgement message back to
   the sender. If the message is an RPC request, then the RPC reply
   message is implicitly an acknowledgement of receipt of the request.

To reduce the need for resends of a message when publishing using an
at-least-once QoS level, it can sometimes be appropriate to use <code>
Confirm</code>-class, as described above in the section on responsibility
transfer. Of course, if a confirmation from the broker is lost, then a
resend will have to be done, since the sending client doesn't know
whether the server actually saw the message or not unless the
<code>Basic.Nack</code> arrives.

Alternatively, rather than implement the round-trip logic manually, a
client may use Publisher Confirms.  By enabling Confirm mode on a
channel, a client is requesting that the broker acknowledge or
negatively acknowledge all messages sent on the channel from that
point on.  See the instructions from Responsibility Transfer on how to
use confirms.

Deciding on a message-resend policy can be difficult. Some simple
resend strategies are:

 - resend if your connection is lost or some other crash occurs before
   you receive confirmation of receipt

 - timeout and resend if you do not receive a confirmation within a
   few seconds. Make sure to double the timeout for each resend, to
   help avoid retry-related denial-of-service and network congestion.

*** At-most-once delivery

For at-most-once delivery, simply

 - publish the message, once, as usual. No correlation identifier is
   required.

 - receive the message in the consuming application, paying attention
   to the <code>Redelivered</code> flag on the delivery. The <code>
   Redelivered</code> flag will only be clear when the server believes that
   it is offering a message for consumption for the very first
   time. If any attempt at delivery has been made before, the <code>Redelivered</code> flag will be set.

The <code>Redelivered</code> flag is a very limited piece of information,
giving only at-most-once QoS. In particular, it cannot be used for
exactly-once QoS.


** Coding with high-availability AMQP server pairs

In situations where continuous AMQP service is desired, the
possibility of a server failure can be hedged against with some
careful programming and the availability of a warm-standby AMQP server
for failover.

The main concerns when failing over are

 - atomicity of published/acknowledged work units, and

 - availability of configured resources on the backup server

Message producers should take care to use transactions in order to
receive positive confirmation of receipt of a group of messages from a
server, and should keep a record of the exchanges, queues and bindings
they need to have available in order to perform their work, so that on
failover, the appropriate resources can be declared before replaying
the most recent transactions to recover.

Message consumers should be aware of the possibility of missing or
duplicate messages when failing over: a publisher may decide to resend
a transaction whose outcome is in doubt, or a transaction the
publisher considered complete could disappear entirely due to failure
of the primary AMQP server.

** Interacting with external resources

A common pattern for an AMQP-connected service is to

 # receive a service request via an AMQP queue

 # update some external resource, such as a file or database

 # reply via AMQP, or at a minimum, acknowledge to the AMQP server
   that the message triggering the action has been completed

Often elements of the at-least-once or exactly-once patterns appear in
conjunction with the external-resource pattern - specifically, the
side-effects discussed in the section on reliable message transfer
above are often effects on an external resource.

In cases where the exactly-once pattern appears in conjunction with an
external resource, it's important to write code that is able at each
step to determine whether the step has already been taken in some
previous attempt at completing the whole transaction, and if it has,
to be able to omit it in this attempt and proceed to the next
step. For example:

 - If a work-triggering request went missing, another copy will
   (eventually) arrive from the ultimate requestor.

 - If the work was already performed, for instance a database table
   was updated, in a previous receipt of the work item in question,
   the service needs to keep a record of completion of the external
   work that is atomic with respect to the atomic work itself: for
   instance, within the same database transaction, some log of
   honoured requests could be updated, or the row being modified could
   be updated to include the ID of the request that caused the
   modification, as well as previous request-IDs that modified the row
   in question.

   This makes it important to be able to compress request IDs so that
   they do not take unbounded space in the log of performed work, and
   so that we do not need to introduce a full distributed
   garbage-collection protocol with the ultimate requestor. One way of
   doing this is to choose to use request IDs that are strictly
   increasing, so that a "high water mark" can be used; see also the
   section on exactly-once delivery above.

 - Once the work is known to have been performed, and a reply has been
   produced (if there is one), the reply can be sent back to the
   requestor as many times as necessary. The requestor knows which
   replies it is expecting, and can discard unwanted duplicates. So
   long as duplicates of the same request always receive identical
   reply messages, the replier need not be careful about sending too
   many copies of the reply.

 - Once the reply has been sent to the AMQP server, the request
   message can be acknowledged as received and processed with the AMQP
   server. In cases where there is no reply to a request, the
   acknowledgement is still useful to ensure that requests are not
   lost.
    </body>
</html>
