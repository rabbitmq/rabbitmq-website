<?xml-stylesheet type="text/xml" href="page.xsl"?>
<!DOCTYPE html [
<!ENTITY % entities SYSTEM "rabbit.ent" >
%entities;
]>
<html  xmlns="http://www.w3.org/1999/xhtml" xmlns:doc="http://www.rabbitmq.com/namespaces/ad-hoc/doc">
  <head>
    <title>RabbitMQ - API Guide</title>
  </head>
  <body>
    <doc:div>
      <p class="intro">
	This page gives an overview of the RabbitMQ Java client	API. 
      </p>
      <p class="intro">
	The code samples given here demonstrate connecting to AMQP brokers and 
	using RPC services exposed via AMQP.
      </p>
      <p class="intro">
	For more details, please see the relevant Javadoc <a
	href="&dir-current-javadoc;">documentation</a>.
      </p>

      <doc:toc class="compact">
	<doc:heading>Table of Contents</doc:heading>
      </doc:toc>

      <doc:section name="core">
	<doc:heading>Core API Guide</doc:heading>
	<doc:subsection name="connecting">
	<doc:heading>Connections and channels</doc:heading>

	<p>
	  The client API is closely modelled on the AMQP protocol specification,
	  with little additional abstraction.
	</p>

	<p>
	  For more detail on the classes used in this document, please
	  see the <a href="&dir-current-javadoc;">Javadoc
	  documentation</a>.
	</p>

	<p>
	  The core API classes are <code>Connection</code>
	  and <code>Channel</code>, representing an AMQP connection and an 
	  AMQP data channel, respectively: 
	</p>
	<pre class="sourcecode"><b>import</b> com.rabbitmq.client.Connection;
<b>import</b> com.rabbitmq.client.Channel;</pre>

	<p>
	  The holder class <code>AMQP</code> stores all the code
	  generated automatically from the AMQP XML protocol
	  definition specification. It contains all required
	  content-class-specific content header definitions (such
	  as <code>AMQP.BasicProperties</code>) and all the
	  method request and response descriptors (such
	  as <code>AMQP.Basic.Publish</code>
	  and <code>AMQP.Queue.BindOk</code>), as well as useful
	  protocol-specific constants and other values.
	</p>
	  
	<p>
	  For details and exact definitions,
	  please see <a href="http://www.amqp.org/">the AMQP specification document</a>.
	</p>

	<pre class="sourcecode"><b>import</b> com.rabbitmq.client.AMQP;</pre>

	  <doc:heading>Connecting to a broker</doc:heading>

	  <p>
	    The following code connects to an AMQP broker using the given parameters (host name, port number, etc) : 
	  </p>

<pre class="sourcecode">
ConnectionFactory factory = <b>new</b> ConnectionFactory();
factory.setUsername(<b>userName</b>);
factory.setPassword(<b>password</b>);
factory.setVirtualHost(<b>virtualHost</b>);
factory.setHost(<b>hostName</b>);
factory.setPort(<b>portNumber</b>);
Connection conn = factory.newConnection();
</pre>	  

    <p>
      All of these parameters have sensible defaults for a stock RabbitMQ server running locally. 
    </p>

	  <p>
	    The Connection interface can then be used to open a channel:
	  </p>
	  
<pre class="sourcecode">
Channel channel = conn.createChannel();
</pre>	  
	  <p>
	    The channel can now be used to send and receive messages, as described in subsequent sections.
	  </p>

	  <p>
	    To disconnect, simply close the channel and the connection:
	  </p>

	  <pre class="sourcecode">channel.close();
conn.close();</pre>

	  <p>
	    Note that closing the channel may be considered good practice, but isn't strictly necessary here - it will be done
	    automatically anyway when the underlying connection is closed.
	  </p>

	</doc:subsection>

	<doc:subsection name="declaring">
	  <doc:heading>Using exchanges and queues</doc:heading>

	  <p>
	   Client applications work with exchanges and queues, the high-level building blocks of AMQP.
	   These must be "declared" before they can be used. Declaring either type of object
	   simply ensures that one of that name exists, creating it if necessary.
	  </p>
	  
	  <p>
	   Continuing the previous example, the following code declares an exchange and a queue, 
	   then binds them together.
	  </p>

	  <pre class="sourcecode">channel.exchangeDeclare(<b>exchangeName</b>, <b>"direct"</b>, <b>true</b>);
String <b>queueName</b> = channel.queueDeclare().getQueue();
channel.queueBind(<b>queueName</b>, <b>exchangeName</b>, <b>routingKey</b>);</pre>

	  <p>
	    This will actively declare the following objects,
	    both of which can be customised by using additional parameters.
	    Here neither of them have any special arguments.
	  </p>

	  <ol>
	    <li>a durable, non-autodelete exchange of "direct" type</li>
	    <li>a non-durable, exclusive, autodelete queue with a generated name</li>
	  </ol>

	  <p>
	    The above function calls then bind the queue to the exchange with the
        given routing key.
	  </p>
	  <p>
        Note that this would be a typical way to declare a queue when only one
        client wants to work with it: it doesn't need a well-known name, no
        other client can use it (exclusive) and will be cleaned up
        automatically (autodelete). If several clients want to share a queue
        with a well-known name, this code would be appropriate:
	  </p>

	  <pre class="sourcecode">channel.exchangeDeclare(<b>exchangeName</b>, <b>"direct"</b>, <b>true</b>);
channel.queueDeclare(<b>queueName</b>, <b>true</b>, <b>false</b>, <b>false</b>, <b>null</b>);
channel.queueBind(<b>queueName</b>, <b>exchangeName</b>, <b>routingKey</b>);</pre>

	  <p>
	    This will actively declare:
	  </p>

	  <ol>
	    <li>a durable, non-autodelete exchange of "direct" type</li>
	    <li>a durable, non-exclusive, non-autodelete queue with a well-known name</li>
	  </ol>

	  <p>
	    Note that all of these <code>Channel</code> API methods are overloaded.
	    These convenient short forms of <code>exchangeDeclare</code>, <code>queueDeclare</code> and <code>queueBind</code> 
	    use sensible defaults. There are also longer forms with more parameters, to let you override these defaults
	    as necessary, giving full control where needed. 
	  </p>
	  <p>
	    This "short version, long version" pattern is used throughout the client API uses.
	  </p>
	</doc:subsection>

	<doc:subsection name="publishing">
	  <doc:heading>Publishing messages</doc:heading>

	  <p>
	    To publish a message to an exchange, use <code>Channel.basicPublish</code> as follows:
	  </p>

	  <pre class="sourcecode"><b>byte</b>[] messageBodyBytes = <b>&quot;Hello, world!&quot;</b>.getBytes();
channel.basicPublish(<b>exchangeName</b>, <b>routingKey</b>, <b>null</b>, messageBodyBytes);</pre>

	  <p>
	    For fine control, you can use overloaded variants to specify the <code>mandatory</code> and <code>immediate</code>
	    flags, or send messages with <code>basic</code>-class header properties :
	  </p>

	  <pre class="sourcecode">channel.basicPublish(<b>exchangeName</b>, <b>routingKey</b>,
                     MessageProperties.PERSISTENT_TEXT_PLAIN,
                     messageBodyBytes);</pre>

	  <p>
	    This sends a message with delivery mode 2 (persistent) and content-type "text/plain". You can specify as many
	    parameters as you like :
	  </p>

	  <pre class="sourcecode">channel.basicPublish(<b>exchangeName</b>, <b>routingKey</b>,
                     <b>new</b> AMQP.BasicProperties
                       (contentType, contentEncoding, headers, deliveryMode,
                        priority, correlationId, replyTo, expiration,
                        messageId, timestamp, type, userId,
                        appId, clusterId),
                     messageBodyBytes);</pre>

	  <p>
	    Here any or all of the parameters to the <code>BasicProperties</code> constructor may be null.
	  </p>
	  <p>
	    Note also that <code>BasicProperties</code> is an inner class of the autogenerated
	    holder class <code>AMQP</code>.
	  </p>
	</doc:subsection>

	<doc:subsection name="channel-threads">
	  <doc:heading>Channel thread-safety</doc:heading>

        <p>In general, Channel instances should not be used by more than one thread simultaneously: application
        code should maintain a clear notion of thread ownership for Channel instances.
        If more than one thread needs to access a particular Channel instance, the application should enforce
        mutual exclusion itself, for example by synchronising on the Channel.</p>

        <p>Symptoms of incorrect serialisation of Channel operations include, but are not limited to,
        <code>IllegalStateException</code>s with the message "cannot execute more than one synchronous AMQP command at a time", and <code>UnexpectedFrameError</code>s.</p>
	</doc:subsection>

	<doc:subsection name="consuming">
	  <doc:heading>Retrieving messages by subscription</doc:heading>

	  <pre class="sourcecode"><b>import</b> com.rabbitmq.client.Consumer;
<b>import</b> com.rabbitmq.client.QueueingConsumer;</pre>

	  <p>
	    The most efficient way to receive messages is to set up a
	    subscription using the <code>Consumer</code>
	    interface. The messages will then be delivered
	    automatically as they arrive, rather than having to be
	    requested proactively.
	  </p>
	  <p>
	    The easiest and safest supplied implementation of
	    <code>Consumer</code> is the <code>QueueingConsumer</code>
	    convenience class:
	  </p>

	  <pre class="sourcecode"><b>boolean</b> autoAck = <b>false</b>;
QueueingConsumer consumer = <b>new</b> QueueingConsumer(channel);
channel.basicConsume(queueName, autoAck, consumer);
<b>while</b> (<i>/* decide whether to continue reading */</i>) {
    QueueingConsumer.Delivery delivery;
    <b>try</b> {
        delivery = consumer.nextDelivery();
    } <b>catch</b> (InterruptedException ie) {
        <b>continue</b>;
    }
    <i>// (process the message components ...)
</i>    channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <b>false</b>);
}</pre>

	  <p>
        If, instead, you decide to implement the
        <code>Consumer</code> interface yourself, be warned that
        its methods will be called from within the connection's
        thread, and so they must not in turn invoke any blocking
        AMQP operation (such as <code>queueDeclare</code>,
        <code>basicCancel</code> or
        <code>basicPublish</code>). If they do, the channel will
        deadlock. Only asynchronous AMQP operations without content
        are safe for use within callbacks, such as <code>basicAck</code>.
	  </p>

	  <p>
	    It's partly because of this complication that using
	    <code>QueueingConsumer</code> is the safest way of
	    receiving messages by subscription.
	  </p>

	  <p>
	    If, with the above caveats in mind, you do decide to
	    implement the <code>Consumer</code> interface yourself,
	    one good option is to subclass the convenience class
	    <code>DefaultConsumer</code>, overriding methods as
	    necessary. You will generally want to override the core
	    interface method <code>handleDelivery</code>:
	  </p>

	  <pre class="sourcecode"><b>boolean</b> autoAck = <b>false</b>;
channel.basicConsume(ticket, queueName, autoAck,
     <b>new</b> DefaultConsumer(channel) {
         @Override <b>public</b> <b>void</b> handleDelivery(String consumerTag,
                                              Envelope envelope,
                                              AMQP.BasicProperties properties,
                                              <b>byte</b>[] body)
             <b>throws</b> IOException
         {
             String routingKey = envelope.getRoutingKey();
             String contentType = properties.contentType;
             <b>long</b> deliveryTag = envelope.getDeliveryTag();
             <i>// (process the message components ...) 
</i>
             channel.basicAck(deliveryTag, <b>false</b>); <i>// asynchronous, thus safe!
</i>         }
     });</pre>

	  <p>
	    More sophisticated consumers will need to override further
	    methods.  In particular, <code>handleShutdownSignal</code>
	    traps channel / connection closure, and
	    <code>handleConsumeOk</code> is passed a server-generated
	    consumer tag when none is supplied to the initial
	    <code>basicConsume</code> call.
	  </p>

	  <p>
	    Consumers can also implement the
	    <code>handleCancelOk</code> method to be notified of
	    cancellations.
	  </p>

	  <p>
	    You can cancel an active consumer with
	    <code>Channel.basicCancel</code>:
	  </p>

	  <pre class="sourcecode">channel.basicCancel(consumerTag);</pre>

	  <p>
	    When calling the API methods relating to
	    <code>Consumer</code>s, individual subscriptions are
	    always referred to by their consumer tags, which can be
	    either client- or server-generated as explained in <a
	    href="http://www.amqp.org/">the AMQP specification
	    document</a>.
	  </p>
	</doc:subsection>

	<doc:subsection name="getting">
	  <doc:heading>Retrieving individual messages</doc:heading>

	  <p>
	    To retrieve individual messages, use
	    <code>Channel.basicGet</code>.  The returned value is an
	    instance of <code>GetResponse</code>, from which the
	    header information (properties) and message body can be
	    extracted :
	  </p>

	  <pre class="sourcecode"><b>boolean</b> autoAck = <b>false</b>;
GetResponse response = channel.basicGet(<b>queueName</b>, autoAck);
<b>if</b> (response == <b>null</b>) {
    <i>// No message retrieved.
</i>} <b>else</b> {
    AMQP.BasicProperties props = response.getProps();
    <b>byte</b>[] body = response.getBody();
    long deliveryTag = response.getEnvelope().getDeliveryTag();
    ...</pre>

	  <p>
	    Since the <code>autoAck</code> = <code>false</code> above,
	    you must also call <code>Channel.basicAck</code> to
	    acknowledge that you have successfully received and
	    processed the message :
	  </p>

	  <pre class="sourcecode">    ...
    channel.basicAck(method.deliveryTag, <b>false</b>); <i>// acknowledge receipt of the message</i>
}</pre>

	</doc:subsection>

	<doc:subsection name="returning">
	  <doc:heading>Handling unroutable or undelivered messages</doc:heading>

	  <p>
	    If a message is published with the "mandatory" or "immediate" flags set, but cannot be 
	    delivered, the broker will return it to the sending client 
	    (via a <code>AMQP.Basic.Return</code> command).
	  </p>
	  <p>
	    To be notified of such returns, clients can implement the <code>ReturnListener</code>
	    interface and calling <code>Channel.setReturnListener</code>. 
	    If the client has not configured a return listener for a particular channel,
	    then the associated returned messages will be silently dropped.
	  </p>

	  <pre class="sourcecode">channel.setReturnListener(<b>new</b> ReturnListener() {
        <b>public</b> <b>void</b> handleBasicReturn(int replyCode, 
					String replyText, 
					String exchange, 
					String routingKey, 
					AMQP.BasicProperties properties, 
					byte[] body) 
            <b>throws</b> IOException {
            ...
        }
    });</pre>
	  <p>
	    This return listener will be called, for example, if the client publishes a message with
	    the "mandatory" flag set to an exchange of "direct" type which is not bound to a queue.
	  </p>
	</doc:subsection>

      </doc:section>

      <doc:section name="rpc">
	<doc:heading>Basic RPC</doc:heading>

	<p>
	  As a programming convenience, the Java client API offers a
	  class <code>RpcClient</code> which uses a temporary reply
	  queue to provide simple RPC-style communication facilities via AMQP.
	</p>
	<p>
	  The class doesn't impose any particular format on the RPC arguments and return values.
	  It simply provides a mechanism for sending a message to a given exchange with a particular 
	  routing key, and waiting for a response on a reply queue.
	</p>

	<pre class="sourcecode">
<b>import</b> com.rabbitmq.client.RpcClient;

RpcClient rpc = <b>new</b> RpcClient(<b>channel</b>, <b>exchangeName</b>, <b>routingKey</b>);</pre>

	<p>
	  (The implementation details of how this class uses AMQP are as follows: request messages are sent with the 
	  <code>basic.correlation_id</code> field set to a value unique for this <code>RpcClient</code> instance, 
	  and with <code>basic.reply_to</code> set to the name of the reply queue.)
	</p>

	<p>
	  Once you have created an instance of this class, you can use it to send RPC requests by using any of the following methods:
	</p>

	<pre class="sourcecode"><b>byte</b>[] primitiveCall(<b>byte</b>[] message);
String stringCall(String message)
Map mapCall(Map message)
Map mapCall(Object[] keyValuePairs)</pre>

	<p>
	  The <code>primitiveCall</code> method transfers raw byte arrays as the request and response
	  bodies. The method <code>stringCall</code> is a thin
	  convenience wrapper around <code>primitiveCall</code>,
	  treating the message bodies as <code>String</code> instances
	  in the default character encoding.
	</p>
	<p>
	  The <code>mapCall</code> variants are a little more sophisticated: they encode
	  a <code>java.util.Map</code> containing ordinary Java values
	  into an AMQP binary table representation, and decode the
	  response in the same way. (Note that there are some restrictions on what value
	  types can be used here - see the javadoc for details.)
	</p>

	<p>
	  All the marshalling/unmarshalling convenience methods use <code>primitiveCall</code> as a 
	  transport mechanism, and just provide a wrapping layer on top of it.
	</p>
      </doc:section>
      <doc:section name="shutdown">
        <doc:heading>Shutdown Protocol</doc:heading>
          <doc:subsection name="shutdown-overview">
	    <doc:heading>Overview of the AMQP client shutdown</doc:heading>
	    <p>
	      The AMQP connection and channel share the same general
	      approach to managing network failure, internal failure,
	      and explicit local shutdown.
	    </p>
	    <p>
	      The AMQP connection and channel have the following lifecycle states:
	    </p>
	    <ul>
	      <li>
		<code>open</code>: the object is ready to use
	      </li>
	      <li>
		<code>closing</code>: the object has been explicitly
		notified to shut down locally, has issued a shutdown
		request to any supporting lower-layer objects, and is
		waiting for their shutdown procedures to complete
	      </li>
	      <li>
		<code>closed</code>: the object has received all
		shutdown-complete notification(s) from any lower-layer
		objects, and as a consequence has shut itself down
	      </li>
	    </ul>
	    <p>
	      Those objects always end up in the closed state,
	      regardless of the reason that casued the closure, like
	      an application request, an internal client library
	      failure, a remote network request or network failure.
	    </p>
	    <p>
	      The AMQP connection and channel objects possess the
	      following shutdown-related methods:
	    </p>
	    <ul>
	      <li>
		<code>addShutdownListener(ShutdownListener
		listener)</code> and
		<code>removeShutdownListener(ShutdownListener
		listener)</code>, to manage any listeners, which will
		be fired when the object transitions to
		<code>closed</code> state. Note that, adding a
		ShutdownListener to an object that is already closed
		will fire the listener immediately
	      </li>
	      <li>
		<code>getCloseReason()</code>, to allow the
		investigation of what was the reason of the object's
		shutdown
	      </li>
	      <li>
		<code>isOpen()</code>, useful for testing whether the
		object is in an open state
	      </li>
	      <li>
		<code>close(int closeCode, String
		closeMessage)</code>, to explictly notify the object
		to shut down
	      </li>
	    </ul>
	    <p>
	      Simple usage of listeners would look like:
	    </p>
            <pre class="sourcecode"><b>import</b> com.rabbitmq.client.ShutdownSignalException;
<b>import</b> com.rabbitmq.client.ShutdownListener;

connection.addShutdownListener(<b>new</b> ShutdownListener() {
    <b>public void</b> shutdownCompleted(ShutdownSignalException cause)
    {
        ...
    }
});</pre>
	  </doc:subsection>
	  <doc:subsection name="shutdown-cause">
	    <doc:heading>Information about the circumstances of a shutdown</doc:heading>
	    <p>
	      One can retrieve the
	      <code>ShutdownSignalException</code>, which contains all
	      the information available about the close reason, either
	      by explictly calling the <code>getCloseReason()</code>
	      method or by using the <code>cause</code> parameter in
	      the <code>service(ShutdownSignalException cause)</code>
	      method of the <code>ShutdownListener</code> class.
	    </p>
	    <p>
	      The <code>ShutdownSignalException</code> class provides
	      methods to analyze the reason of the shutdown. By
	      calling the <code>isHardError()</code> method we get
	      information whether it was a connection or a channel
	      error.
	    </p>
            <pre class="sourcecode"><b>public void</b> shutdownCompleted(ShutdownSignalException cause)
{
  <b>if</b> (cause.isHardError())
  {
    Connection conn = (Connection)cause.getReference();
    <b>if</b> (!cause.isInitiatedByApplication())
    {
      Object reason = cause.getReason();
      ...
    }
    ...
  } <b>else</b> {
    Channel ch = (Channel)cause.getReference();
    ...
  }
}</pre>
          </doc:subsection>
          <doc:subsection name="shutdown-atomicity">
            <doc:heading>Atomicity and use of the isOpen() method</doc:heading>
            <p>
             Use of the <code>isOpen()</code> method of channel and
             connection objects is not recommended for production
             code, because the value returned by the method is
             dependent on the existence of the shutdown cause.  The
             following code illustrates the possibility of race
             conditions:
	    </p>
	    <pre class="sourcecode"><b>public void</b> brokenMethod(Channel channel)
{
    <b>if</b> (channel.isOpen())
    {
        // The following code depends on the channel being in open state.
        // However there is a possibility of the change in the channel state
        // between isOpen() and basicQos(1) call
        ...
        channel.basicQos(1);
    }
}</pre>
	    <p>
	      Instead, we should normally ignore such checking, and
	      simply attempt the action desired. If during the
	      execution of the code the channel of the connection is
	      closed, a <code>ShutdownSignalException</code> will be
	      thrown indicating that the object is in an invalid
	      state. We should also catch for <code>IOException</code>
	      caused either by <code>SocketException</code>, when
	      broker closes the connection unexpectedly, or
	      <code>ShutdownSignalException</code>, when broker
	      initiated clean close.
	    </p>
	    <pre class="sourcecode"><b>public void</b> validMethod(Channel channel)
{
    <b>try</b> {
        ...
        channel.basicQos(1);
    } <b>catch</b> (ShutdownSignalException sse) {
        // possibly check if channel was closed
        // by the time we started action and reasons for
        // closing it
        ...
    } <b>catch</b> (IOException ioe) {
        // check why connection was closed
        ...
    } 
}</pre>
          </doc:subsection>
      </doc:section>

<!-- Removed because we decided to exclude these libs from the release.
     See bug 16391.

      <doc:section name="jsonrpc">
	<doc:heading>JSON-RPC over AMQP</doc:heading>

	<p>
	  <a
	  href="http://json-rpc.org/wd/JSON-RPC-1-1-WD-20060807.html">JSON-RPC</a>
	  is a lightweight RPC mechanism using <a
	  href="http://www.json.org/">JSON</a> as a data language for
	  request and reply messages. It is rapidly becoming a
	  standard in web development, where it is used to make RPC
	  requests over HTTP. RabbitMQ provides an AMQP transport
	  binding for JSON-RPC in the form of
	  the <code>JsonRpcClient</code> class.
	</p>

	<pre class="sourcecode"><b>import</b> com.rabbitmq.tools.JsonRpcClient;</pre>

	<p>
	  <code>JsonRpcClient</code> inherits
	  from <code>RpcClient</code>, extending it with
	</p>

	<pre class="sourcecode">Object call(String method, Object[] params) <b>throws</b> IOException, JsonRpcException;
Object call(String[] args) <b>throws</b> NumberFormatException, IOException, JsonRpcException;</pre>

	<p>
	  The first variant encodes the <code>params</code> using
	  JSON, and sends a JSON-RPC request to the exchange that was
	  configured in the <code>JsonRpcClient</code>
	  constructor. The second variant is useful for simple
	  command-line or scripting use: the first of
	  the <code>args</code> is assumed to be the method name, and
	  the remainder are coerced to the expected types before being
	  sent.
	</p>

	<p>
	  JSON-RPC services are self-describing - each service is able
	  to list its supported procedures, and each procedure
	  describes its parameters and types. An instance of
	  JsonRpcClient retrieves its service description using the
	  standard <code>system.describe</code> procedure when it is
	  constructed, and uses the information to coerce parameter
	  types appropriately. A JSON service description is parsed
	  into instances
	  of <code>JsonRpcClient.ServiceDescription</code>. Client
	  code can access the service description by reading
	  the <code>serviceDescription</code> field
	  of <code>JsonRpcClient</code> instances.
	</p>

	<p>
	  To illustrate, the following is an excerpt from the RabbitMQ
	  management JSON-RPC service:
	</p>

	<pre class="sourcecode">{
    <b>&quot;sdversion&quot;</b>: <b>&quot;1.0&quot;</b>,
    <b>&quot;name&quot;</b>: <b>&quot;amq.rabbitmq.management&quot;</b>,
    <b>&quot;id&quot;</b>: <b>&quot;urn:uuid:ce13b1c6-bb5d-4532-9156-8ad5a498c256&quot;</b>,
    <b>&quot;version&quot;</b>: <b>&quot;1.0&quot;</b>,
    <b>&quot;address&quot;</b>: <b>&quot;amq.rabbitmq.management&quot;</b>,
    <b>&quot;procs&quot;</b>: [{
                  <b>&quot;name&quot;</b>: <b>&quot;add_user&quot;</b>,
                  <b>&quot;idempotent&quot;</b>: <b>false</b>,
                  <b>&quot;params&quot;</b>: [{<b>&quot;name&quot;</b>: <b>&quot;username&quot;</b>, <b>&quot;type&quot;</b>: <b>&quot;str&quot;</b>},
                             {<b>&quot;name&quot;</b>: <b>&quot;password&quot;</b>, <b>&quot;type&quot;</b>: <b>&quot;str&quot;</b>}]
              },
              {
                  <b>&quot;name&quot;</b>: <b>&quot;delete_user&quot;</b>,
                  <b>&quot;idempotent&quot;</b>: <b>false</b>,
                  <b>&quot;params&quot;</b>: [{<b>&quot;name&quot;</b>: <b>&quot;username&quot;</b>, <b>&quot;type&quot;</b>: <b>&quot;str&quot;</b>}]
              },
              ...
              ]
}</pre>

	<p>
	  One might create a new user by calling
	</p>

	<pre class="sourcecode">rpcProxy.call(<b>&quot;add_user&quot;</b>, <b>new</b> Object[] { <b>&quot;user name&quot;</b>, <b>&quot;password&quot;</b> });</pre>
      </doc:section>
-->
    </doc:div>
  </body>
</html>
