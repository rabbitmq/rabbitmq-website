<?xml-stylesheet type="text/xml" href="page.xsl"?>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:doc="http://www.rabbitmq.com/namespaces/ad-hoc/doc"
      xmlns:x="http://www.rabbitmq.com/2011/extensions">
  <head>
    <title>Broker Semantics</title>
  </head>
  <body>
      <p class="intro">
        Here we describe the broker semantics. This should be read together
        with the specification.
      </p>
      <doc:section name="tx">
        <doc:heading>Semantics of tx</doc:heading>
        <p>
          The semantics of AMQP's <code>tx</code> class, as defined in
          AMQP 0-9-1, and its implementation in different versions of
          the RabbitMQ server, is often misunderstood. Here is a
          summary of the behaviour:
        </p>
        <table>
	  <tr>
            <th>Feature</th>
	    <th>AMQP 0-9-1</th>
	    <th>RabbitMQ &lt; 2.6.0</th>
	    <th>RabbitMQ &gt;= 2.6.0</th>
	  </tr>
          <tr>
            <td>transactional <code>basic.publish</code></td>
            <td>yes</td>
            <td>yes</td>
            <td>yes</td>
          </tr>
          <tr>
            <td>transactional <code>basic.ack</code></td>
            <td>yes</td>
            <td>yes</td>
            <td>yes</td>
          </tr>
          <tr>
            <td>transactional <code>basic.reject</code></td>
            <td>no</td>
            <td>no</td>
            <td>no</td>
          </tr>
          <tr>
            <td>transactional exchange/queue/binding creation/deletion</td>
            <td>no</td>
            <td>no</td>
            <td>no</td>
          </tr>
          <tr>
            <td>transactional consuming/getting of messages</td>
            <td>no</td>
            <td>no</td>
            <td>no</td>
          </tr>
          <tr>
            <td>atomicity in single queue</td>
            <td>yes</td>
            <td>no</td>
            <td>no</td>
          </tr>
          <tr>
            <td>atomicity across multiple queues</td>
            <td>no</td>
            <td>no</td>
            <td>no</td>
          </tr>
          <tr>
            <td>error detection (e.g. invalid exchange)</td>
            <td>undefined</td>
            <td>immediate</td>
            <td>immediate</td>
          </tr>
          <tr>
            <td>sending of 'no_route' <code>basic.return</code></td>
            <td>undefined</td>
            <td>immediate</td>
            <td>on <code>tx.commit</code></td>
          </tr>
          <tr>
            <td>sending of 'no_consumers' <code>basic.return</code></td>
            <td>undefined</td>
            <td>never</td>
            <td>on <code>tx.commit</code></td>
          </tr>
          <tr>
            <td>effect visibility / responsibility transfer / durability</td>
            <td>undefined</td>
            <td>on <code>tx.commit</code></td>
            <td>on <code>tx.commit</code></td>
          </tr>
        </table>
        <p>
          Overall the behaviour of the AMQP <code>tx</code> class, and
          more so its implementation on RabbitMQ, is closer to
          providing a 'batching' feature than ACID capabilities known
          from the database world.
        </p>
        <p>
          AMQP transactions only apply to publishes and acks. Other
          operations, such as message rejection, are not
          transactional. Neither is resource creation/deletion, and
          consequently <em>the behaviour of transactions when any of
          the involved exchanges, queues or bindings are altered is
          undefined</em>.
        </p>
        <p>
          On the consuming side, the <em>acknowledgements</em> are
          transactional, not the consuming of the messages
          themselves. Hence no requeuing of consumed messages takes
          place on rollback; the client can still ack/reject these
          messages in subsequent transactions.
        </p>
        <p>
          AMQP guarantees atomicity only when transactions involve a
          single queue, i.e. all the publishes inside the tx get
          routed to a single queue and all acks relate to messages
          consumed from the same queue. When multiple queues are
          involved it is possible that in the event of a broker
          failure during <code>tx.commit</code> the effects of the
          transaction are only visible in some of the
          queues. Furthermore, RabbitMQ provides no atomicity
          guarantees even in case of transactions involving just a
          single queue, e.g. a fault during <code>tx.commit</code> can
          result in a sub-set of the transaction's publishes appearing
          in the queue after a broker restart.
        </p>
        <p>
          AMQP does not specify when errors (e.g. lack of permissions,
          references to unknown exchanges) in
          transactional <code>basic.publish</code>
          and <code>basic.ack</code> commands should be
          detected. RabbitMQ performs the necessary checks immediately
          (rather than, say, at the time of commit), but note that
          both <code>basic.publish</code> and <code>basic.ack</code>
          are asynchronous commands so any errors will be reported
          back to the client asynchronously. The situation is similar
          with <code>basic.return</code>s, though note the slight
          change in behaviour between earlier and recent versions of
          RabbitMQ.
        </p>
        <p>
          AMQP does not specify when the effects of transactions
          should become visible following a <code>tx.commit</code>,
          e.g. when published messages will appear in queues and can
          be consumed from other clients, when persistent messages
          will be written to disk, etc. In RabbitMQ
          the <code>tx.confirm-ok</code> indicates that all
          transaction effects are visible and that the broker has
          accepted responsibility for all the messages published in
          the transaction.
        </p>
      </doc:section>
      <doc:section name="ordering">
        <doc:heading>Message ordering guarantees</doc:heading>
        <p>
          Section 4.7 of the AMQP 0-9-1 core specification explains the
          conditions under which ordering is guaranteed: messages
          published in one channel, passing through one exchange and
          one queue and one outgoing channel will be received in the
          same order that they were sent. RabbitMQ offers stronger
          guarantees since release 2.7.0 .
        </p>
        <p>
          Messages can be returned to the queue using
          AMQP methods that feature a requeue parameter
          (<code>basic.recover</code>, <code>basic.reject</code> and
          <code>basic.nack</code>), or due to a channel closing while
          holding unacknowledged messages.  Any of these scenarios
          caused messages to be requeued at the back of the queue
          for RabbitMQ releases earlier than 2.7.0. From RabbitMQ
          release 2.7.0, messages are always held in the queue in
          publication order, even in the presence of requeueing or
          channel closure.
        </p>
        <p>
          With release 2.7.0 and later it is still possible for
          individual consumers to observe messages out of order if
          the queue has multiple subscribers.  This is due to the
          actions of other subscribers who may requeue messages. From
          the perspective of the queue the messages are always held
          in the publication order.
        </p>
      </doc:section>
  </body>
</html>
