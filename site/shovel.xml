<?xml-stylesheet type="text/xml" href="page.xsl"?>
<!DOCTYPE html [
<!ENTITY % entities SYSTEM "rabbit.ent" >
%entities;
]>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:doc="http://www.rabbitmq.com/namespaces/ad-hoc/doc"
      xmlns:x="http://www.rabbitmq.com/2011/extensions">
  <head>
    <title>Shovel plugin</title>
  </head>
  <body show-in-this-page="true">
    <p>
      The <em>Shovel plugin</em> allows you to configure a number of
      <em>shovel</em>s, which start automatically when the broker
      starts.
    </p>
    <p>
      The high level goal of a <em>shovel</em> is to reliably and
      continually take messages from a queue (a <em>source</em>) in one
      broker and publish them to exchanges in another broker (a
      <em>destination</em>).
    </p>
    <p>
      The source queue and destination exchanges can be on the same
      broker or distinct brokers.
    </p>
    <p>
      A shovel behaves like a well-written client application, which
      connects to its source and destination, reads and writes messages,
      and copes with connection failures.
    </p>

    <p>
      The primary advantages of a shovel are:
    </p>
    <dl class="plain">
      <dt><strong>Loose coupling</strong></dt>
      <dd>
        A shovel can move messages between brokers (or clusters) in
        different administrative domains:
        <ul class="plain">
          <li>
            they may have different users and virtual hosts;
          </li>
          <li>
            they may run on different versions of RabbitMQ and Erlang.
          </li>
        </ul>
      </dd>
      <dt><strong>WAN-friendly</strong></dt>
      <dd>
        The Shovel plugin uses AMQP to communicate between brokers, and
        is designed to tolerate intermittent connectivity without
        message loss.
      </dd>
      <dt><strong>Non-invasive</strong></dt>
      <dd>
        To define and start a shovel, you do not have to reconfigure
        either the source or the destination resources. You do not even
        have to restart the broker(s) upon which they reside: the shovels
        can run in a separate broker altogether.
      </dd>
      <dt><strong>Highly tailorable</strong></dt>
      <dd>
        When a shovel connects (either to the source or the
        destination) it can be configured to perform any number of
        explicit methods. For example, the source queue need not exist
        initially, and can be <em>declared</em> on connect.
      </dd>
    </dl>

    <p>
      A comparison between <em>clustering</em>, <em>federated
      exchanges</em> and <em>shovels</em> is given on the
      <a href="distributed.html">Distributed Messaging</a> page.
    </p>

    <doc:section name="what-it-do">
      <doc:heading>What does it do?</doc:heading>
      <p>
        The Shovel plugin defines (and runs) an Erlang client
        application for each shovel defined in its configuration.
      </p>
      <p>
        In essence, a shovel is a simple pump. Each shovel:
        <ul class="plain">
          <li>
            <strong><em>connects</em></strong> to the source broker and
            the destination broker,
          </li>
          <li>
            <strong><em>consumes</em></strong> messages from the queue,
          </li>
          <li>
            <strong><em>re-publishes</em></strong> each message to the
            destination broker (using, by default, the original exchange
            name and routing_key).
          </li>
        </ul>
      </p>
      <p>
        The shovel configuration allows each of these processes to be
        tailored.
      </p>
      <dl class="plain">
        <dt><strong><em>connects</em></strong></dt>
        <dd>
          <p>
            After connection to a source or a destination broker a
            series of configured AMQP <em>declarations</em> can be
            issued. Queues, exchanges and bindings can be declared.
          </p>
        </dd>
        <dd>
          <p>
            A shovel will attempt to reconnect to a broker if a failure
            occurs and multiple brokers can be specified for the source and
            destination so that another broker may be selected (at
            random) to reconnect to. A reconnection delay can be
            specified to avoid flooding the network with reconnection
            attempts, or to prevent reconnection on failure altogether.
          </p>
          <p>
            All configured <em>declarations</em> (for that source or
            destination) are re-issued upon re-connect.
          </p>
        </dd>
        <dt><strong><em>consumes</em></strong></dt>
        <dd>
          <p>
            The shovel's consumer can acknowledge messages
            automatically on receipt, after (re-)publication, or after
            confirmation of its publication.
          </p>
        </dd>
        <dt><strong><em>re-publishes</em></strong></dt>
        <dd>
          <p>
            Both the publish method and the message properties can be
            modified with explicit parameter values.
          </p>
        </dd>
      </dl>
      <p>
        Full details are given in the
        <a href="#configuration">configuration</a> section, below.
      </p>

    </doc:section>

    <doc:section name="getting-started">
      <doc:heading>Getting Started</doc:heading>
      <p>
        The <em>Shovel plugin</em> is included in the RabbitMQ
        distribution. To enable it, use
        <a href="man/rabbitmq-plugins.1.man.html">rabbitmq-plugins</a>:
      </p>
<pre class="example">
  rabbitmq-plugins enable rabbitmq_shovel
</pre>
      <p>
        You may also wish to enable the
        <code>rabbitmq_shovel_management</code> plugin (see
        <a href="#management-status">below</a>).
      </p>
    </doc:section>

    <doc:section name="status">
      <doc:heading>Shovel status</doc:heading>
      <p>
        There are two ways of discovering the status of configured shovels.
      </p>
      <doc:subsection name="management-status">
        <doc:heading>Use shovel management</doc:heading>
        <p>
          Shovel status can be reported on the
          <a href="management.html">Management plugin</a> user interface
          by enabling the <code>rabbitmq_shovel_management</code> plugin
          wherever you have the management plugin enabled.
        </p>
        <p>
          Information about configured shovels will automatically appear
          in the management API and UI.
        </p>
      </doc:subsection>

      <doc:subsection name="direct-status">
        <doc:heading>Direct query</doc:heading>
        <p>
          Shovel status can be obtained by direct query of the Shovel
          plugin app. Issue the following <code>rabbitmqctl</code>
          command:
        </p>
<pre class="example">
  $ rabbitmqctl eval 'rabbit_shovel_status:status().'
</pre>
        <p>
          This calls the <code>status</code> method in a module of the
          <code>rabbitmq_shovel</code> plugin, which will return an
          Erlang list, with one element for each configured shovel.
        </p>
        <p>
          Each element of the list is a tuple with three fields:
          <code>{<em><strong>Name</strong></em>,
          <em><strong>Status</strong></em>,
          <em><strong>Timestamp</strong></em>}</code>.
        </p>
        <sl>
          <li>
            <code><strong><em>Name</em></strong></code>
            is the shovel name (an Erlang atom),
          </li>
          <li>
            <code><strong><em>Status</em></strong></code>
            is the current shovel state,
          </li>
          <li>
            and <code><strong><em>Timestamp</em></strong></code> is the
            time when the shovel <em>entered</em> this state.
          </li>
        </sl>
        <p>
          <code><strong><em>Timestamp</em></strong></code> is a local
          calendar time of the form
          <code>{{YYYY, MM, DD}, {HH, MM, SS}}</code>.
        </p>
        <p>
          <code><strong><em>Status</em></strong></code> takes one of
          three forms:
        </p>
        <ul>
          <li>
            The shovel is starting up, connecting and creating
            resources:
<pre class="example">
  'starting'
</pre>
          </li>
          <li>
            The shovel is running normally:
<pre class="example">
  { 'running' | 'blocked', {'source', <em>Source</em>},
                           {'destination', <em>Destination</em>}}:
</pre>
            <p>
              where <code><em>Source</em></code> and
              <code><em>Destination</em></code> terms give the
              respective connection parameters.
            </p>
          </li>
          <li>
            The shovel has terminated:
<pre class="example">
  {'terminated', <em>Reason</em>}
</pre>
              <p>
                where <code><em>Reason</em></code> is an Erlang term that
                indicates the reason for the termination.
              </p>
            </li>
          </ul>
          <p>
            The first term of a normal status can be <code>'running'</code> or
            <code>'blocked'</code>:
            <ul class="plain">
              <li>
                <code><strong>'running'</strong></code>: the shovel
                is up and running, shovelling messages;
              </li>
              <li>
                <code><strong>'blocked'</strong></code>: the
                destination has raised <code>channel.flow</code>,
                preventing the shovel from sending messages to the
                destination.
              </li>
            </ul>
          </p>
          <p>
            When <code><strong>'blocked'</strong></code>, the
            shovel will raise <code>channel.flow</code> to the
            source, asking the source to stop sending further
            messages to the shovel. Any messages that are received
            by the shovel before the source observes the
            <code>channel.flow</code> are correctly buffered and
            maintained in order, and are published to the
            destination as soon as the destination drops the
            <code>channel.flow</code> block.
          </p>
      </doc:subsection>

    </doc:section>

    <doc:section name="configuration">
      <doc:heading>Configuration</doc:heading>

      <p>
        The configuration for the Shovel plugin in the 
        <a href="configure.html#configuration-file">broker configuration
        file</a> is an Erlang term (as usual) and consists of a single
        <code>shovels</code> clause:
      </p>
<pre class="example">
  {rabbitmq_shovel, [ {shovels, [ {<em>shovel_name</em>, [ <em>...</em> ]}, <em>...</em> ]} ]}
</pre>
      <p>
        A (deliberately verbose)
        <a href="#example-config">example configuration</a> is given
        below.
      </p>
      <p>
        Each element of the list in the <code>shovels</code> clause is a
        named shovel. The <code><em>shovel_name</em></code>s in the list
        must be distinct.
      </p>
      <p>
        Each shovel definition looks like this:
      </p>
<pre class="example">
  {<em>shovel_name</em>, [ {sources, [ <em>...</em> ]}
                , {destinations, [ <em>...</em> ]}
                , {queue, <em>queue_name</em>}
                , {prefetch_count, <em>count</em>}
                , {ack_mode, <em>a_mode</em>}
                , {publish_properties, [ <em>...</em> ]}
                , {publish_fields, [ <em>...</em> ]}
                , {reconnect_delay, <em>reconn_delay</em>}
                ]}
</pre>
      <p>
        where <code><em>shovel_name</em></code> is the name of the
        shovel (an Erlang atom) and the clauses for
        <code>sources</code>, <code>destinations</code> and
        <code>queue</code> are mandatory. All the other clauses are
        optional.
      </p>
      <p>
        Each clause is fully described below.
      </p>

      <dl>
        <dt><a id="sources"/><strong>sources</strong></dt>
        <dt><a id="destinations"/><strong>destinations</strong></dt>
        <dd>
          <p>
            Both of these clauses are mandatory. They take the form:
          </p>
<pre class="example">
  {sources, [ {brokers, <em>broker_list</em>}
            , {declarations, <em>declaration_list</em>}
            ]}
</pre>
          <p>
            (or <code>{destinations, <em>...</em>}</code>). The
            <code>brokers</code> clause is mandatory and the
            <code>declarations</code> clause optional.
          </p>
          <dl>
            <dt><strong>brokers</strong></dt>
            <dd>
              <p>
                This clause (or its variant <code>broker</code> clause,
                see note below) is mandatory. In
              </p>
<pre class="example">
  {brokers, <em>broker_list</em>}
</pre>
              <p>
                <code><em>broker_list</em></code> is a list of URI
                broker <em>connections</em> (for the basic syntax, see
                <a href="uri-spec.html">AMQP URI</a>), for example:
<pre class="example">
  [ "amqp://fred:secret@host1.domain/my_vhost"
  , "amqp://john:secret@host2.domain/my_vhost"
  ]
</pre>
                If the <code>host</code> is omitted (not valid in a
                general AMQP URI), the shovel uses a <em>direct</em>
                connection to the broker in which it is running. This
                avoids using the network stack.
              </p>
              <p>
                The syntax is extended to include a query part to permit
                the configuration of additional connection parameters.
                <em>heartbeat</em>, <em>channel_max</em>, and
                <em>frame_max</em> can be specified, in any order.
                Omitted fields assume default values. For example:
<pre class="example">
  "amqp://myhost?heartbeat=5&amp;frame_max=8192"
</pre>
                specifies a (non-encrypted) network connection to the
                host <code>myhost</code>, using default username,
                password, port, vhost and channel_max. The heartbeat
                interval is set to 5 seconds, and the maximum frame size
                to 8192 bytes.
              </p>
              <p>
                It is possible to specify an encrypted SSL connection,
                the general form of which is:
<pre class="example">
  "amqps://username:password@host:port/vhost?
      cacertfile=/path/to/cacert.pem
     &amp;certfile=/path/to/certfile.pem
     &amp;keyfile=/path/to/keyfile.pem
     &amp;verify=verifyOption
     &amp;fail_if_no_peer_cert=failOption"
</pre>
                (This URI has been split across several lines only for
                readbility. There must be no white-space in the URI.)
              </p>
              <p>
                All five parameters (3 paths: <em>cacertfile</em>,
                <em>certfile</em> and <em>keyfile</em>; and 2 options:
                <em>verify</em>, <em>fail_if_no_peer_cert</em>) must be
                specified as well as the <code>amqps</code> scheme.
                See the <a href="ssl.html">SSL guide</a> for
                details of SSL in RabbitMQ in general and specifically
                the <a href="ssl.html#configure-erlang">Erlang
                client</a> section.
              </p>
              <p>
                It is also possible to
                specify <em>&amp;auth_mechanism=external</em> to use
                the <a href="http://hg.rabbitmq.com/rabbitmq-auth-mechanism-ssl/file/&version-server-hg;/README">SASL
                EXTERNAL</a> authentication mechanism.
              </p>
              <p>
                <strong>Note</strong>: If the broker list consists of a
                single connection URI, the variant form:
              </p>
<pre class="example">
  {broker, <em>amqp_uri_string</em>}
</pre>
              <p>
                is equivalent to a <code>brokers</code> clause with a
                single-element list.
              </p>
            </dd>

            <dt><a id="declarations"/><code><em>declaration_list</em></code></dt>
            <dd>
              <p>
                This clause is optional. In
              </p>
<pre class="example">
  {declarations, <em>declaration_list</em>}
</pre>
              <p>
                the <code><em>declaration_list</em></code> is a list of
                AMQP methods (in the style of the Erlang client) which
                can be sent to the broker after connection and before
                shovelling.
              </p>
              <p>
                This allows any resources that may need to be set up to
                be configured, including the source queue and the
                destination exchanges. For example:
              </p>
<pre class="example">
  {declarations, [ 'queue.declare'
                 , {'queue.bind', [ {exchange, &lt;&lt;"my_exchange"&gt;&gt;}
                                  , {queue,    &lt;&lt;&gt;&gt;}
                                  ]}
                 ]}
</pre>
              <p>
                will first declare an anonymous queue, and then bind it
                to the exchange called "<code>my_exchange</code>". (The
                queue parameter <code>&lt;&lt;&gt;&gt;</code> on <code>queue.bind</code>
                means 'use the queue last declared on this channel'.)
              </p>
              <p>
                Each element of the list is either an atom, being the
                name of an AMQP method, or a tuple with first element
                the method atom, and second element a property-list of
                parameter settings.
              </p>
              <p>
                If just the AMQP method atom is supplied all the
                parameters take their defaults (as illustrated with
                <code>'queue.declare'</code> above).
              </p>
              <p>
                If a tuple and property-list is supplied, then the
                properties in the list specify some or all of the
                parameters explicitly.
              </p>
              <p>
                Here is another example:
              </p>
<pre class="example">
  {'exchange.declare', [ {exchange, &lt;&lt;"my_exchange"&gt;&gt;}
                       , {type, &lt;&lt;"direct"&gt;&gt;}
                       , durable
                       ]}
</pre>
              <p>
                will declare a durable, direct exchange called
                "<code>my_exchange</code>".
              </p>
              <p>
                For full details, consult the <a
                href="erlang-client-user-guide.html">Erlang Client</a>
                documentation.
              </p>
            </dd>
          </dl>
        </dd>

        <dt><strong>queue</strong></dt>
        <dd>
          <p>
            This clause is mandatory. In
          </p>
<pre class="example">
  {queue, <em>queue_name</em>}
</pre>
          <p>
            <code><em>queue_name</em></code> is the name of the queue
            (as a binary string) to shovel messages from. For example:
          </p>
<pre class="example">
  {queue, &lt;&lt;"my_work_queue"&gt;&gt;}
</pre>
          <p>
            This queue must exist. Use the resource
            <a href="#declarations"><code>declarations</code></a> to
            create the queue (or ensure it exists) first. If
            <code><em>queue_name</em></code> is
            <code>&lt;&lt;&gt;&gt;</code> (the empty binary string) the
            <em>most recently declared queue</em> in
            <code>declarations</code> is used. This allows anonymous
            queues to be declared and used.
          </p>
        </dd>

        <dt><strong>prefetch_count</strong></dt>
        <dd>
          <p>
            This clause is optional. In
          </p>
<pre class="example">
  {prefetch_count, <em>count</em>}
</pre>
          <p>
            <code><em>count</em></code> is the maximum number of
            unacknowledged messages the shovel may hold at a time (a
            non-negative integer). For example:
          </p>
<pre class="example">
  {prefetch_count, 1}
</pre>
          <p>
            If this number is zero (the default), there is no limit.
          </p>
        </dd>

        <dt><strong>ack_mode</strong></dt>
        <dd>
          <p>
            This clause is optional. In
          </p>
<pre class="example">
  {ack_mode, <em>a_mode</em>}
</pre>
          <p>
            <code><em>a_mode</em></code> is one of
            <code>'no_ack'</code>, <code>'on_publish'</code> or
            <code>'on_confirm'</code>.
          </p>
          <dl>
            <dt><code>'no_ack'</code></dt>
            <dd>
              <p>
                indicates that no message acknowledgements are to be
                generated by the shovel (the broker automatically
                acknowledges all delivered messages);
              </p>
            </dd>
            <dt><code>'on_publish'</code></dt>
            <dd>
              <p>
                indicates that a message acknowledgement is to be sent
                (to the source broker) after each message is
                re-published to the destination;
              </p>
            </dd>
            <dt><code>'on_confirm'</code></dt>
            <dd>
              <p>
                indicates that publish confirmations are sought and that
                a message acknowledgement is to be sent (to the source
                broker) after each message publication is confirmed by
                the destination broker.
              </p>
            </dd>
          </dl>
          <p>
            The default is <code>'on_confirm'</code>, which is highly
            recommended. If other options are chosen performance may
            improve slightly, but messages are more likely to be lost in
            the event of failures.
          </p>
        </dd>

        <dt><strong>publish_properties</strong></dt>
        <dd>
          <p>
            This clause is optional. It takes the form:
          </p>
<pre class="example">
  {publish_properties, <em>property_list</em>}
</pre>
          <p>
            where the properties in the list are set on the
            basic.properties of each message before it is re-published.
          </p>
          <p>
            For example:
          </p>
<pre class="example">
  {publish_properties, [ {delivery_mode, 2} ]}
</pre>
          <p>
            would mark all re-published messages persistent.
          </p>
          <p>
            By default the properties of the message are preserved, but
            this clause can be used to change, or set any property,
            including <code>content_type</code>,
            <code>content_encoding</code>, <code>headers</code>,
            <code>delivery_mode</code>, <code>priority</code>,
            <code>correlation_id</code>, <code>reply_to</code>,
            <code>expiration</code>, <code>message_id</code>,
            <code>timestamp</code>, <code>type</code>,
            <code>user_id</code>, <code>app_id</code> and
            <code>cluster_id</code>.
          </p>
        </dd>

        <dt><strong>publish_fields</strong></dt>
        <dd>
          <p>
            This clause is optional. It takes the form:
          </p>
<pre class="example">
  {publish_fields, <em>property_list</em>}
</pre>
          <p>
            where the properties in the list are used to set the
            <em>fields</em> on the <code>basic.publish</code> method
            used to re-publish messages.
          </p>
          <p>
           By default the messages are re-published using the original
           exchange name and routing key, for example.  By specifying:
         </p>
<pre class="example">
  {publish_fields, [ {exchange, &lt;&lt;"my_exchange"&gt;&gt;}
                   , {routing_key, &lt;&lt;"from_shovel"&gt;&gt;}
                   ]}
</pre>
          <p>
            messages would be re-published to an explicit exchange name
            with an explicit, fixed routing key.
          </p>
        </dd>

        <dt><strong>reconnect_delay</strong></dt>
        <dd>
          <p>
            This clause is optional. In
          </p>
<pre class="example">
  {reconnect_delay, <em>reconn_delay</em>}
</pre>
          <p>
            <code><em>reconn_delay</em></code> is the number of
            seconds to wait before reconnecting in the event of
            connection failure (a non-negative number). For example:
          </p>
<pre class="example">
  {reconnect_delay, 1.5}
</pre>
          <p>
            would delay for one and a half seconds before reconnecting
            after failure.
          </p>
          <p>
            If <code><em>reconn_delay</em></code> is <code>0</code>,
            then no reconnections occur: the shovel will stop after the
            first failure.
          </p>
          <p>
            The default <code><em>reconn_delay</em></code> is 5
            (seconds).
          </p>
        </dd>
      </dl>

    </doc:section>

    <doc:section name="example-config">
      <doc:heading>Example Configuration</doc:heading>
      <p>
        A verbose shovel configuration might look like this:
      </p>
<pre class="example">
  {rabbitmq_shovel,
    [ {shovels, [ {my_first_shovel,
                    [ {sources,
                        [ {brokers, [ "amqp://fred:secret@host1.domain/my_vhost"
                                    , "amqp://john:secret@host2.domain/my_vhost"
                                    ]}
                        , {declarations, [ {'exchange.declare',
                                              [ {exchange, &lt;&lt;"my_fanout"&gt;&gt;}
                                              , {type, &lt;&lt;"fanout"&gt;&gt;}
                                              , durable
                                              ]}
                                         , {'queue.declare',
                                              [{arguments,
                                                 [{&lt;&lt;"x-message-ttl"&gt;&gt;, long, 60000}]}]}
                                         , {'queue.bind',
                                              [ {exchange, &lt;&lt;"my_direct"&gt;&gt;}
                                              , {queue,    &lt;&lt;&gt;&gt;}
                                              ]}
                                         ]}
                        ]}
                    , {destinations,
                        [ {broker, "amqp://"}
                        , {declarations, [ {'exchange.declare',
                                              [ {exchange, &lt;&lt;"my_direct"&gt;&gt;}
                                              , {type, &lt;&lt;"direct"&gt;&gt;}
                                              , durable
                                              ]}
                                         ]}
                        ]}
                    , {queue, &lt;&lt;&gt;&gt;}
                    , {prefetch_count, 10}
                    , {ack_mode, on_confirm}
                    , {publish_properties, [ {delivery_mode, 2} ]}
                    , {publish_fields, [ {exchange, &lt;&lt;"my_direct"&gt;&gt;}
                                       , {routing_key, &lt;&lt;"from_shovel"&gt;&gt;}
                                       ]}
                    , {reconnect_delay, 5}
                    ]}
                ]}
    ]}
</pre>
      <p>
        The configuration above defines a single shovel called
        '<code>my_first_shovel</code>'.
      </p>
      <p>
        '<code>my_first_shovel</code>' will connect to a broker on
        either <code>host1</code> or <code>host2</code> (as source), and
        directly to the local broker (as destination). It will reconnect
        to the other source broker on failure, after a delay of 5
        seconds.
      </p>
      <p>
        When connected to the source it will declare a a direct, fanout exchange
        called "<code>my_fanout</code>", an anonymous queue with a <a
        href="ttl.html#per-queue-message-ttl">per-queue message ttl</a>, and
        bind the queue to the exchange.
      </p>
      <p>
        When connected to the destination (the local broker) it will declare a
        durable, direct exchange called "<code>my_direct</code>".
      </p>
      <p>
        This shovel will re-publish messages sent to the anonymous queue on the
        source to the local exchange with the fixed routing key
        "<code>from_shovel</code>". The messages will be persistent and only
        acknowledged after receiving a publish confirm from the local broker.
      </p>
      <p>
        The shovel consumer will not be allowed to hold more than ten
        unacknowledged messages at a time.
      </p>
    </doc:section>

  </body>
</html>
