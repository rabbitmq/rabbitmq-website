<?xml-stylesheet type="text/xml" href="page.xsl"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns:doc="http://www.rabbitmq.com/namespaces/ad-hoc/doc">
  <head>
    <title>RabbitMQ - API Guide</title>
  </head>
  <body>
    <doc:div>
      <p class="intro">
	This page gives an overview of the RabbitMQ Java client	API. 
      </p>
      <p class="intro">
	The code samples given here demonstrate connecting to AMQP brokers and 
	using RPC services exposed via AMQP.
      </p>
      <p class="intro">
	For more details, please see the relevant Javadoc <a href="javadoc/">documentation</a>.
      </p>

      <doc:toc class="compact">
	<doc:heading>Table of Contents</doc:heading>
      </doc:toc>

      <doc:section name="core">
	<doc:heading>Core API Guide</doc:heading>
	<doc:subsection name="connecting">
	<doc:heading>Connections and channels</doc:heading>

	<p>
	  The client API is closely modelled on the AMQP protocol specification,
	  with little additional abstraction. (Future releases
	  will provide increased type-safety by encapsulating AMQP
	  entities more thoroughly; please see the <a
	  href="roadmap.html">roadmap</a> for more detail.)
	</p>

	<p>
	  For more detail on the classes used in this document, please
	  see the <a href="javadoc/">Javadoc documentation</a>.
	</p>

	<p>
	  The core API classes are <code>Connection</code>
	  and <code>Channel</code>, representing an AMQP connection and an 
	  AMQP data channel, respectively: 
	</p>
	<pre class="sourcecode"><b>import</b> com.rabbitmq.client.Connection;
<b>import</b> com.rabbitmq.client.Channel;</pre>

	<p>
	  The holder class <code>AMQP</code> stores all the code
	  generated automatically from the AMQP XML protocol
	  definition specification. It contains all required
	  content-class-specific content header definitions (such
	  as <code>AMQP.BasicProperties</code>) and all the
	  method request and response descriptors (such
	  as <code>AMQP.Basic.Publish</code>
	  and <code>AMQP.Queue.BindOk</code>), as well as useful
	  protocol-specific constants and other values.
	</p>
	  
	<p>
	  For details and exact definitions,
	  please see <a href="http://www.amqp.org/">the AMQP specification document</a>.
	</p>

	<pre class="sourcecode"><b>import</b> com.rabbitmq.client.AMQP;</pre>

	  <doc:heading>Connecting to a broker</doc:heading>

	  <p>
	    The following code connects to an AMQP broker using the given parameters (host name, port number, etc) : 
	  </p>

<pre class="sourcecode">
ConnectionParameters params = <b>new</b> ConnectionParameters();
params.setUsername(<b>userName</b>);
params.setPassword(<b>password</b>);
params.setVirtualHost(<b>virtualHost</b>);
params.setRequestedHeartbeat(<b>0</b>);
ConnectionFactory factory = <b>new</b> ConnectionFactory(<b>params</b>);
Connection conn = factory.newConnection(<b>hostName</b>, <b>portNumber</b>);
</pre>	  
	  <p>
	    The Connection interface can then be used to open a channel and request an access ticket to a realm: 
	  </p>
	  
<pre class="sourcecode">
Channel channel = conn.createChannel();
int ticket = channel.accessRequest(<b>realm</b>);
</pre>	  
	  <p>
	    The channel and access ticket can now be used to send and receive messages, as described in subsequent sections.
	  </p>

	  <p>
	    To disconnect, simply close the channel and the connection:
	  </p>

	  <pre class="sourcecode">channel.close(AMQP.REPLY_SUCCESS, <b>&quot;Goodbye&quot;</b>);
conn.close(AMQP.REPLY_SUCCESS, <b>&quot;Goodbye&quot;</b>);</pre>

	  <p>
	    Note that closing the channel may be considered good practice, but isn't strictly necessary here - it will be done
	    automatically anyway when the underlying connection is closed.
	  </p>

	</doc:subsection>

	<doc:subsection name="declaring">
	  <doc:heading>Using exchanges and queues</doc:heading>

	  <p>
	   Client applications work with exchanges and queues, the high-level building blocks of AMQP.
	   These must be "declared" before they can be used. Declaring either type of object
	   simply ensures that one of that name exists, creating it if necessary.
	  </p>
	  
	  <p>
	   Continuing the previous example, the following code declares an exchange and a queue, 
	   then binds them together.
	  </p>

	  <pre class="sourcecode">channel.exchangeDeclare(ticket, <b>exchangeName</b>, <b>"direct"</b>);
channel.queueDeclare(ticket, <b>queueName</b>);
channel.queueBind(ticket, <b>queueName</b>, <b>exchangeName</b>, <b>routingKey</b>);</pre>

	  <p>
	    This will actively declare the following objects:
	    <ol>
	      <li>a non-durable, non-autodelete exchange of "direct" type</li>
	      <li>a non-durable, non-exclusive, non-autodelete queue</li>
	    </ol>
	    
	    both of which can be customised by using additional parameters. 
	    Here neither of them have any special arguments.
	  </p>
	  <p>
	    The above function calls then bind the queue to the exchange with the given routing key.
	  </p>

	  <p>
	    Note that all three of these <code>Channel</code> API methods are overloaded.
	    These convenient short forms of <code>exchangeDeclare</code>, <code>queueDeclare</code> and <code>queueBind</code> 
	    use sensible defaults. There are also longer forms with more parameters, to let you override these defaults
	    as necessary, giving full control where needed. 
	  </p>
	  <p>
	    This "short version, long version" pattern is used throughout the client API uses.
	  </p>
	</doc:subsection>

	<doc:subsection name="publishing">
	  <doc:heading>Publishing messages</doc:heading>

	  <p>
	    To publish a message to an exchange, use <code>Channel.basicPublish</code> as follows:
	  </p>

	  <pre class="sourcecode"><b>byte</b>[] messageBodyBytes = <b>&quot;Hello, world!&quot;</b>.getBytes();
channel.basicPublish(ticket, <b>exchangeName</b>, <b>routingKey</b>, <b>null</b>, messageBodyBytes);</pre>

	  <p>
	    For fine control, you can use overloaded variants to specify the <code>mandatory</code> and <code>immediate</code>
	    flags, or send messages with <code>basic</code>-class header properties :
	  </p>

	  <pre class="sourcecode">channel.basicPublish(ticket, <b>exchangeName</b>, <b>routingKey</b>,
                     MessageProperties.PERSISTENT_TEXT_PLAIN,
                     messageBodyBytes);</pre>

	  <p>
	    This sends a message with delivery mode 2 (persistent) and content-type "text/plain". You can specify as many
	    parameters as you like :
	  </p>

	  <pre class="sourcecode">channel.basicPublish(ticket, <b>exchangeName</b>, <b>routingKey</b>,
                     <b>new</b> AMQP.BasicProperties
                       (contentType, contentEncoding, headers, deliveryMode,
                        priority, correlationId, replyTo, expiration,
                        messageId, timestamp, type, userId,
                        appId, clusterId),
                     messageBodyBytes);</pre>

	  <p>
	    Here any or all of the parameters to the <code>BasicProperties</code> constructor may be null.
	  </p>
	  <p>
	    Note also that <code>BasicProperties</code> is an inner class of the autogenerated
	    holder class <code>AMQP</code>.
	  </p>
	</doc:subsection>

	<doc:subsection name="channel-threads">
	  <doc:heading>Channel thread-safety</doc:heading>

        <p>In general, Channel instances should not be used by more than one thread simultaneously: application
        code should maintain a clear notion of thread ownership for Channel instances.
        If more than one thread needs to access a particular Channel instance, the application should enforce
        mutual exclusion itself, for example by synchronising on the Channel.</p>

        <p>Symptoms of incorrect serialisation of Channel operations include, but are not limited to,
        <code>IllegalStateException</code>s with the message "cannot execute more than one synchronous AMQP command at a time", and <code>UnexpectedFrameError</code>s.</p>
	</doc:subsection>

	<doc:subsection name="getting">
	  <doc:heading>Retrieving individual messages</doc:heading>

	  <p>
	    To retrieve individual messages, use <code>Channel.basicGet</code>. 
	    The returned value is an instance of <code>GetResponse</code>, from which
	    the header information (properties) and message body can be extracted : 
	  </p>

	  <pre class="sourcecode"><b>boolean</b> noAck = <b>false</b>;
GetResponse response = channel.basicGet(ticket, <b>queueName</b>, noAck);
<b>if</b> (response == <b>null</b>) {
    <i>// No message retrieved.
</i>} <b>else</b> {
    AMQP.BasicProperties props = response.getProps();
    <b>byte</b>[] body = response.getBody();
    long deliveryTag = response.getEnvelope().getDeliveryTag();
    ...</pre>
    
	  <p>
	    Since the <code>noAck</code> = <code>false</code> above, you must also call
	    <code>Channel.basicAck</code> to acknowledge that you
	    have successfully received and processed the message :
	  </p>

	  <pre class="sourcecode">    ...
    channel.basicAck(method.deliveryTag, <b>false</b>); <i>// acknowledge receipt of the message</i>
}</pre>

	</doc:subsection>

	<doc:subsection name="consuming">
	  <doc:heading>Retrieving messages by subscription</doc:heading>

	  <pre class="sourcecode"><b>import</b> com.rabbitmq.client.Consumer;
<b>import</b> com.rabbitmq.client.DefaultConsumer;</pre>

	  <p>
	    Another way to receive messages is to set up a subscription using the <code>Consumer</code>
	    interface. The messages will then be delivered automatically as they arrive, rather than
	    having to be requested proactively.
	  </p>
	  <p>
	    The easiest way to implement a <code>Consumer</code> object is to subclass the convenience class 
	    <code>DefaultConsumer</code>, then override methods as necessary. You will generally want to override
	    the core interface method <code>handleDelivery</code> :
	  </p>

	  <pre class="sourcecode"><b>boolean</b> noAck = <b>false</b>;
channel.basicConsume(ticket, <b>queueName</b>, noAck,
     <b>new</b> DefaultConsumer(<b>channel</b>) {
	 <b>@Override</b><b> public</b> <b>void</b> handleDelivery(String <b>consumerTag</b>,
				Envelope <b>envelope</b>,
				AMQP.BasicProperties <b>properties</b>,
				byte[] <b>body</b>)
	     <b>throws</b> IOException {
	     String routingKey = envelope.getRoutingKey();
	     String contentType = properties.contentType;
	     long deliveryTag = envelope.getDeliveryTag();
	     <i>// (process the message components ...) </i>

	     channel.basicAck(deliveryTag, false);
	 }
     });</pre>
		     
	  <p>
	    More sophisticated consumers will need to override further methods. 
	    In particular, <code>handleShutdownSignal</code> traps channel / connection
	    closure, and <code>handleConsumeOk</code> is passed a server-generated consumer
	    tag when none is supplied to the initial <code>basicConsume</code> call.
	  </p>

	  <p>
	    Consumers can also implement <code>handleCancelOk</code> method to be notified of cancellations. 
	  </p>
	  <p>
	    You can cancel an active consumer with <code>Channel.basicCancel</code> : 
	  </p>

	  <pre class="sourcecode">channel.basicCancel(consumerTag);</pre>

	  <p>
	    When calling the API methods, you always refer to consumers by their delivery tags, which can be either
	    client- or server-generated as explained in <a href="http://www.amqp.org/">the AMQP specification document</a>.
	  </p>

	</doc:subsection>

	<doc:subsection name="returning">
	  <doc:heading>Handling unroutable or undelivered messages</doc:heading>

	  <p>
	    If a message is published with the "mandatory" or "immediate" flags set, but cannot be 
	    delivered, the broker will return it to the sending client 
	    (via a <code>AMQP.Basic.Return</code> command).
	  </p>
	  <p>
	    To be notified of such returns, clients can implement the <code>ReturnListener</code>
	    interface and calling <code>Channel.setReturnListener</code>. 
	    If the client has not configured a return listener for a particular channel,
	    then the associated returned messages will be silently dropped.
	  </p>

	  <pre class="sourcecode">channel.setReturnListener(<b>new</b> ReturnListener() {
        <b>public</b> <b>void</b> handleBasicReturn(int replyCode, 
					String replyText, 
					String exchange, 
					String routingKey, 
					AMQP.BasicProperties properties, 
					byte[] body) 
            <b>throws</b> IOException {
            ...
        }
    });</pre>
	  <p>
	    This return listener will be called, for example, if the client publishes a message with
	    the "mandatory" flag set to an exchange of "direct" type which is not bound to a queue.
	  </p>
	</doc:subsection>

	<doc:subsection name="ssl">
	  <doc:heading>Tunnelling via SSL/TLS</doc:heading>

	  <img align="right" src="img/stunnel-setup.png" alt="Picture illustrating stunnel4 SSL proxy"/>
	  <p>
	    This release of the RabbitMQ Java client supports an
	    experimental method of tunnelling AMQP over SSL/TLS.
	  </p>

	  <p>
	    If your broker is available via a generic SSL tunnel -
	    provided by a program such as <a
	    href="http://www.stunnel.org/">stunnel</a>, for instance -
	    you can use an <code>SSLSocketFactory</code> to provide
	    secure communication with the broker.
	  </p>

	  <p>
	    In many cases, it is sufficient to do the following:
	  </p>

	  <pre class="sourcecode">ConnectionFactory factory = <b>new</b> ConnectionFactory(<b>params</b>);
factory.useSslProtocol();
Connection conn = factory.newConnection(<b>hostName</b>, <b>portNumber</b>);
</pre>

	  <p>
	    There are three variants of <code>ConnectionFactory.useSslProtocol</code>:
	    <ul>
	      <li>
		<code>useSslProtocol()</code> - uses the default SSL
		protocol (SSLv3) with a blindly-trusting
		<code>TrustManager</code>;
	      </li>
	      <li>
		<code>useSslProtocol(String protocol)</code> - uses
		the supplied SSL protocol name with a blindly-trusting
		<code>TrustManager</code>; or
	      </li>
	      <li>
		<code>useSslProtocol(String protocol, TrustManager
		tm)</code> - uses the supplied SSL protocol name and
		<code>TrustManager</code>.
	      </li>
	    </ul>
	  </p>

	  <p>
	    Each of the three variants ends up calling
	    <code>SSLContext.getInstance</code> followed by
	    <code>SSLContext.init</code>, with no key managers, no
	    secure random source, and just the passed in trust
	    manager.
	  </p>

	  <p>
	    In cases where the convenience methods do not provide
	    enough control, such as when you have actual
	    authentication requirements rather than simply using SSL
	    for its encryption abilities, you will need to configure
	    an <code>SSLSocketFactory</code> instance yourself. The
	    following is a rough sketch of the steps required:
	  </p>

	  <pre class="sourcecode">ConnectionFactory factory = <b>new</b> ConnectionFactory(<b>params</b>);
javax.net.ssl.SSLContext sslContext = javax.net.ssl.SSLContext.getInstance(<b>&quot;SSLv3&quot;</b>);
javax.net.ssl.KeyManager km = <i>/* expression constructing your custom key manager */</i>;
javax.net.ssl.TrustManager tm = <i>/* expression constructing your custom trust manager */</i>;
java.security.SecureRandom random = <i>/* expression constructing your custom randomness source */</i>;
sslContext.init(<b>new</b> javax.net.ssl.KeyManager[] { km },
                <b>new</b> javax.net.ssl.TrustManager[] { tm },
                random);
factory.setSocketFactory(sslContext.getSocketFactory());
Connection conn = factory.newConnection(<b>hostName</b>, <b>portNumber</b>);
...
</pre>
	</doc:subsection>
      </doc:section>

      <doc:section name="rpc">
	<doc:heading>Basic RPC</doc:heading>

	<p>
	  As a programming convenience, the Java client API offers a
	  class <code>RpcClient</code> which uses a temporary reply
	  queue to provide simple RPC-style communication facilities via AMQP.
	</p>
	<p>
	  The class doesn't impose any particular format on the RPC arguments and return values.
	  It simply provides a mechanism for sending a message to a given exchange with a particular 
	  routing key, and waiting for a response on a reply queue.
	</p>

	<pre class="sourcecode">
<b>import</b> com.rabbitmq.client.RpcClient;

RpcClient rpc = <b>new</b> RpcClient(<b>channel</b>, <b>ticket</b>, <b>exchangeName</b>, <b>routingKey</b>);</pre>

	<p>
	  (The implementation details of how this class uses AMQP are as follows: request messages are sent with the 
	  <code>basic.correlation_id</code> field set to a value unique for this <code>RpcClient</code> instance, 
	  and with <code>basic.reply_to</code> set to the name of the reply queue.)
	</p>

	<p>
	  Once you have created an instance of this class, you can use it to send RPC requests by using any of the following methods:
	</p>

	<pre class="sourcecode"><b>byte</b>[] primitiveCall(<b>byte</b>[] message);
String stringCall(String message)
Map mapCall(Map message)
Map mapCall(Object[] keyValuePairs)</pre>

	<p>
	  The <code>primitiveCall</code> method transfers raw byte arrays as the request and response
	  bodies. The method <code>stringCall</code> is a thin
	  convenience wrapper around <code>primitiveCall</code>,
	  treating the message bodies as <code>String</code> instances
	  in the default character encoding.
	</p>
	<p>
	  The <code>mapCall</code> variants are a little more sophisticated: they encode
	  a <code>java.util.Map</code> containing ordinary Java values
	  into an AMQP binary table representation, and decode the
	  response in the same way. (Note that there are some restrictions on what value
	  types can be used here - see the javadoc for details.)
	</p>

	<p>
	  All the marshalling/unmarshalling convenience methods use <code>primitiveCall</code> as a 
	  transport mechanism, and just provide a wrapping layer on top of it.
	</p>
      </doc:section>
      <doc:section name="shutdown">
        <doc:heading>Shutdown Protocol</doc:heading>
          <doc:subsection name="shutdown-overview">
            <doc:heading>Overview of the AMQP client shutdown</doc:heading>
            <p>
             The AMQP connection and channel share the same general approach to managing network failure, internal failure,
             and explicit local shutdown.
            </p>
            <p>
             The AMQP connection and channel have the following lifecycle states:
              <ul>
                <li>
                 <code>open</code>: the object is ready to use
                </li>
                <li>
                 <code>closing</code>: the object has been explicitly notified to shut down locally, has issued a shutdown
                 request to any supporting lower-layer objects, and is waiting for their shutdown procedures to complete
                </li>
                <li>
                 <code>closed</code>: the object has received all shutdown-complete notification(s) from any lower-layer objects,
                 and as a consequence has shut itself down
                </li>
              </ul>
             Those objects always end up in the closed state, regardless of the reason that casued the closure, like an application
             request, an internal client library failure, a remote network request or network failure.
            </p>
            <p>
             The AMQP connection and channel objects posses the following shutdown-related methods:
              <ul>
                <li>
                 <code>addShutdownListener(ShutdownListener listener)</code> and <code>removeShutdownListener(ShutdownListener
                 listener)</code>, to manage any listeners, which will be fired when the object transitions to <code>closed</code>
                 state. Note that, adding a ShutdownListener to an object that is already closed will fire the listener immediately
                </li>
                <li>
                 <code>getCloseReason()</code>, to allow the investigation of what was the reason of the object's shutdown
                </li>
                <li>
                 <code>isOpen()</code>, useful for testing whether the object is in an open state
                </li>
                <li>
                 <code>close(int closeCode, String closeMessage)</code>, to explictly notify the object to shut down
                </li>
              </ul>
             Simply usage of listeners would look like:
            </p>
            <pre class="sourcecode"><b>import</b> com.rabbitmq.client.ShutdownSignalException
<b>import</b> com.rabbitmq.client.ShutdownListener

connection.addShutdownListener(<b>new</b> ShutdownListener() {
      <b>public void</b> service(new ShutdownSignalException cause)
      {
          ...
      }
    });</pre>
          </doc:subsection>
          <doc:subsection name="shutdown-cause">
            <doc:heading>Information about the circumstances of a shutdown</doc:heading>
            <p>
             One can retrieve the <code>ShutdownSignalException</code>, which contains all the information available about the close
             reason, either by explictly calling the <code>getCloseReason()</code> method or by using the <code>cause</code> parameter in the
             <code>service(ShutdownSignalException cause)</code> method of the <code>ShutdownListener</code> class.
            </p>
            <p>
             The <code>ShutdownSignalException</code> class provides methods to analyze the reason of the shutdown. By calling the
             <code>isHardError()</code> method we get information whether it was a connection or a channel error.
            </p>
            <pre class="sourcecode"><b>public void</b> service(ShutdownSignalException cause)
{
  <b>if</b> (cause.isHardError())
  {
    Connection conn = cause.getConnection();
    <b>if</b> (!cause.isInitiatedByApplication())
    {
      Object reason = cause.getReason();
      ...
    }
    ...
  } <b>else</b> {
    Channel ch = cause.getChannel();
    ...
  }
}</pre>
          </doc:subsection>
          <doc:subsection name="shutdown-atomicity">
            <doc:heading>Atomicity and use of the isOpen() method</doc:heading>
            <p>
             Use of the <code>isOpen()</code> method of channel and connection objects is not recommended for production code, because the
             value returned by the method is dependent on the existence of the shutdown cause.
             The following code illustrates the possibility of race conditions:
             <pre class="sourcecode"><b>public void</b> brokenMethod(Channel channel)
{
    <b>if</b> (channel.isOpen())
    {
        // The following code depends on the channel being in open state.
        // However there is a possibility of the change in the channel state
        // between isOpen() and txCommit() call
        ...
        channel.txCommit();
    }
}</pre>
             Instead, we should normally ignore such checking, and simply attempt the action desired. If during the execution of the code the
             channel of the connection is closed, a <code>ShutdownSignalException</code> will be thrown indicating that the object is 
             in an invalid state. We should also catch for <code>IOException</code> caused either by <code>SocketException</code>, when broker closes the connection unexpectedly, or <code>ShutdownSignalException</code>, when broker initiated clean close.

             <pre class="sourcecode"><b>public void</b> validMethod(Channel channel)
{
    <b>try</b> {
        ...
        channel.txCommit();
    } <b>catch</b> (ShutdownSignalException sse) {
        // possibly check if channel was closed
        // by the time we started action and reasons for
        // closing it
        ...
    } <b>catch</b> (IOException ioe) {
        // check why connection was closed
        ...
    } 
}</pre>
            </p>
          </doc:subsection>
      </doc:section>

<!-- Removed because we decided to exclude these libs from the release.
     See bug 16391.

      <doc:section name="jsonrpc">
	<doc:heading>JSON-RPC over AMQP</doc:heading>

	<p>
	  <a
	  href="http://json-rpc.org/wd/JSON-RPC-1-1-WD-20060807.html">JSON-RPC</a>
	  is a lightweight RPC mechanism using <a
	  href="http://www.json.org/">JSON</a> as a data language for
	  request and reply messages. It is rapidly becoming a
	  standard in web development, where it is used to make RPC
	  requests over HTTP. RabbitMQ provides an AMQP transport
	  binding for JSON-RPC in the form of
	  the <code>JsonRpcClient</code> class.
	</p>

	<pre class="sourcecode"><b>import</b> com.rabbitmq.tools.JsonRpcClient;</pre>

	<p>
	  <code>JsonRpcClient</code> inherits
	  from <code>RpcClient</code>, extending it with
	</p>

	<pre class="sourcecode">Object call(String method, Object[] params) <b>throws</b> IOException, JsonRpcException;
Object call(String[] args) <b>throws</b> NumberFormatException, IOException, JsonRpcException;</pre>

	<p>
	  The first variant encodes the <code>params</code> using
	  JSON, and sends a JSON-RPC request to the exchange that was
	  configured in the <code>JsonRpcClient</code>
	  constructor. The second variant is useful for simple
	  command-line or scripting use: the first of
	  the <code>args</code> is assumed to be the method name, and
	  the remainder are coerced to the expected types before being
	  sent.
	</p>

	<p>
	  JSON-RPC services are self-describing - each service is able
	  to list its supported procedures, and each procedure
	  describes its parameters and types. An instance of
	  JsonRpcClient retrieves its service description using the
	  standard <code>system.describe</code> procedure when it is
	  constructed, and uses the information to coerce parameter
	  types appropriately. A JSON service description is parsed
	  into instances
	  of <code>JsonRpcClient.ServiceDescription</code>. Client
	  code can access the service description by reading
	  the <code>serviceDescription</code> field
	  of <code>JsonRpcClient</code> instances.
	</p>

	<p>
	  To illustrate, the following is an excerpt from the RabbitMQ
	  management JSON-RPC service:
	</p>

	<pre class="sourcecode">{
    <b>&quot;sdversion&quot;</b>: <b>&quot;1.0&quot;</b>,
    <b>&quot;name&quot;</b>: <b>&quot;amq.rabbitmq.management&quot;</b>,
    <b>&quot;id&quot;</b>: <b>&quot;urn:uuid:ce13b1c6-bb5d-4532-9156-8ad5a498c256&quot;</b>,
    <b>&quot;version&quot;</b>: <b>&quot;1.0&quot;</b>,
    <b>&quot;address&quot;</b>: <b>&quot;amq.rabbitmq.management&quot;</b>,
    <b>&quot;procs&quot;</b>: [{
                  <b>&quot;name&quot;</b>: <b>&quot;add_user&quot;</b>,
                  <b>&quot;idempotent&quot;</b>: <b>false</b>,
                  <b>&quot;params&quot;</b>: [{<b>&quot;name&quot;</b>: <b>&quot;username&quot;</b>, <b>&quot;type&quot;</b>: <b>&quot;str&quot;</b>},
                             {<b>&quot;name&quot;</b>: <b>&quot;password&quot;</b>, <b>&quot;type&quot;</b>: <b>&quot;str&quot;</b>}]
              },
              {
                  <b>&quot;name&quot;</b>: <b>&quot;delete_user&quot;</b>,
                  <b>&quot;idempotent&quot;</b>: <b>false</b>,
                  <b>&quot;params&quot;</b>: [{<b>&quot;name&quot;</b>: <b>&quot;username&quot;</b>, <b>&quot;type&quot;</b>: <b>&quot;str&quot;</b>}]
              },
              ...
              ]
}</pre>

	<p>
	  One might create a new user by calling
	</p>

	<pre class="sourcecode">rpcProxy.call(<b>&quot;add_user&quot;</b>, <b>new</b> Object[] { <b>&quot;user name&quot;</b>, <b>&quot;password&quot;</b> });</pre>
      </doc:section>
-->
    </doc:div>
  </body>
</html>
