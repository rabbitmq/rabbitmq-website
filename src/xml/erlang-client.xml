<?xml-stylesheet type="text/xml" href="page.xsl"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns:doc="http://www.rabbitmq.com/namespaces/ad-hoc/doc">
  <head>
    <title>RabbitMQ - Erlang AMQP Client library</title>
  </head>
<body>
<doc:div>
 <p class="intro">
  This is the documentation for the Erlang AMQP client.
 </p>
      
 <doc:toc class="compact">
  <doc:heading>Table of Contents</doc:heading>
 </doc:toc>
 
 <doc:section name="introduction">
  <doc:heading>Introduction</doc:heading>
   <p>
    
    The AMQP client provides an Erlang interface to compliant AMQP brokers. The client follows the AMQP execution model and implements the wire level marshalling required to encode and decode AMQP commands in a protocol conformant fashion. AMQP is a connection orientated protocol and multiplexes parallel interactions via multiple channels within a connection.
  
  </p>
  <p>
  
  The basic usage of the client follows these broad steps:
    
    <ol>
     <li>Establish a connection to a broker</li>
     <li>Create a new channel within the open connection</li>
     <li>Execute AMQP commands such as sending and receiving messages, creating exchanges and queue or defining routing rules between exchanges and queues</li>
     <li>When no longer required, close the channel and the connection</li>
    </ol>
   </p>
   
   <p>
     This API guide documents the return values of each command for completeness' sake. It is of course up to the style of the programmer as to whether the result of each invocation is matched against the respective AMQP acknowledgement command, should the return value only contain an acknowledgement that the command was executed successfully.
   </p>
   
 </doc:section>
 <doc:section name="headers">
   <doc:heading>Including Header Files</doc:heading>
    <p>
     
     The Erlang client uses a number of record definitions which you will encounter in this guide. These records fall into two broad categories:
     
     <ol>
      <li>Autogenerated AQMP command definitions from the machine readable version of the specification</li>
      <li>Definitions of data structures that are commonly used throughout the client</li>
     </ol>
     
     To gain access to these records, you need to include the amqp_client.hrl in every module that uses the Erlang client:
     
     <pre class="sourcecode">
     -include("amqp_client.hrl").
     </pre>
    </p>
  </doc:section>
 <doc:section name="connections">
   <doc:heading>Connecting To A Broker</doc:heading>
   <p>
     
     The amqp_connection module can be used to start a connection to the broker:
     
     <pre class="sourcecode">
     Connection = amqp_connection:start_network(#amqp_params{})
     </pre>
     
     This function returns the pid of a process that maintains a permanent connection to the broker.
     
    </p>
    <p> 
     
     An AMQP broker contains objects that organized into groups called virtual hosts. The concept of virtual hosts gives an administrator the facility to partition a broker resource into separate domains and restrict access to the objects contained within these groups. AMQP connections require client authentication and the authorization to access specific virtual hosts. 
    </p>
    <p>     
     The #amqp_params{} record sets the following default values:
    </p> 
     <table>
      <tr><th>Parameter</th><th>Default Value</th></tr>
      <tr><td>username</td><td>guest</td></tr>
      <tr><td>password</td><td>guest</td></tr>
      <tr><td>virtual_host</td><td>/</td></tr>
      <tr><td>host</td><td>localhost</td></tr>
      <tr><td>port</td><td>5672</td></tr>
     </table>
   <p>
     These values are only the defaults that will work with an out of the box broker running on the same host. If the broker or the environment has been configured differently, these values can be overridden to match the actual deployment scenario.
   </p>
 </doc:section>
 <doc:section name="channels">
    <doc:heading>Creating Channels</doc:heading>
    <p>

      Once a connection to the broker has been established, the amqp_connection module can be used to create channels:

      <pre class="sourcecode">
      Channel = amqp_connection:open_channel(Connection)
      </pre>

      This function takes the pid of the connection process and returns a pid that encapsulates a server side channel.
    </p>
  </doc:section>

  <doc:section name="exchanges_queues">
     <doc:heading>Managing Exchanges And Queues</doc:heading>
     <p>

       Now that a channel has been established, the amqp_channel module can be used to manage the fundamental objects within AMQP, namely exchanges and queues. The following function creates an exchange called my_exchange, which by default, is the direct exchange:

       <pre class="sourcecode">
       Declare = #'exchange.declare'{exchange = &lt;&lt;"my_exchange"&gt;&gt;},
       #'exchange.declare_ok'{} = amqp_channel:call(Channel, Declare)
       </pre>
       
       Similarly, a queue called my_queue is created by this code:
       
       <pre class="sourcecode">
       Declare = #'queue.declare'{queue = &lt;&lt;"my_queue"&gt;&gt;},
       #'queue.declare_ok'{} = amqp_channel:call(Channel, Declare)
       </pre>
       
       In many scenarios, a client is not interested in the actual name of the queue it wishes to receive messages from. In this case, it is possible to let the broker generate a random name for a queue. To do this, send a #'queue.declare'{} command and leave the queue attribute undefined:
       
       <pre class="sourcecode">
        #'queue.declare_ok'{queue = Queue} = amqp_channel:call(Channel, #'queue.declare'{})
       </pre>
       
       The server will auto-generate a queue name and return this name as part of the acknowledgement.

     </p>
     <p>
       To create a routing rule from an exchange to a queue, the #'queue.bind'{} command is used:
       
       <pre class="sourcecode">
        Binding = #'queue.bind'{queue = Queue,
                                exchange = Exchange,
                                routing_key = RoutingKey},
        #'queue.bind_ok'{} = amqp_channel:call(Channel, Binding)
        </pre>
       
       When this routing rule is no longer required, this route can be deleted using the #'queue.unbind'{} command:

       <pre class="sourcecode">
        Binding = #'queue.unbind'{queue = Queue,
                                  exchange = Exchange,
                                  routing_key = RoutingKey},
        #'queue.unbind_ok'{} = amqp_channel:call(Channel, Binding)
        </pre>
       
       An exchange can be deleted by the #'exchange.delete'{} command:
       
       <pre class="sourcecode">
        Delete = #'exchange.delete'{exchange = &lt;&lt;"my_exchange"&gt;&gt;},
        #'exchange.delete_ok'{} = amqp_channel:call(Channel, Delete)
       </pre>
       
       Similarly, a queue is deleted using the #'queue.delete'{} command:
       
       <pre class="sourcecode">
         Delete = #'queue.delete'{queue = &lt;&lt;"my_queue"&gt;&gt;},
         #'queue.delete_ok'{} = amqp_channel:call(Channel, Delete)
        </pre>
     </p>
   </doc:section>

<!-- ..................................................................... -->

   <doc:section name="sending">
   <doc:heading>Sending Messages</doc:heading>
   
    <p>

      To send a message to an exchange with a particular routing key, the #'basic.publish'{} command in conjunction with the #amqp_msg{} record is used:

      <pre class="sourcecode">
        Publish = #'basic.publish'{exchange = X, routing_key = Key},
        amqp_channel:cast(Channel, Publish, #amqp_msg{payload = Payload})
      </pre>

      By default, the properties field of the #amqp_msg{} record contains a minimal implementation of the #'P_basic'{} properties structure. If an application needs to override any of the defaults, for example, to send persistent messages, the #amqp_msg{} needs to be constructed accordingly:

      <pre class="sourcecode">
        Publish = #'basic.publish'{exchange = X, routing_key = Key},
        Props = #'P_basic'{delivery_mode = 2}, # for persistent messaging
        Msg = #amqp_msg{props = Props, payload = Payload},
        amqp_channel:cast(Channel, Publish, Msg)
      </pre>
      
      The full list of message headers is explained in the AMQP protocol documentation.
      
    </p>
    <p>
      Note that messages can be published either using amqp_channel:call/3 or amqp_channel:cast/3. The difference is that call/3 will put the message onto the network stack before returning to the caller. In contrast, cast/3 performs this operation asynchronously. From a responsibility transfer perspective however, this makes makes little difference. The only way a client can know that the server has taken responsibility for a message is to either enforce mandatory routing or to use a transaction.
    </p>
   </doc:section>
   
<!-- ..................................................................... -->

   <doc:section name="closing">
  
   <doc:heading>Closing Channels And The Connection</doc:heading>
    <p>

      When a channel is no longer required, a client should close it. This is achieved using amqp_channel:close/1: 

      <pre class="sourcecode">
       amqp_channel:close(Channel)
      </pre>

      To close the connection, amqp_connection:close/1 is used:
      
      <pre class="sourcecode">
       amqp_connection:close(Connection)
      </pre>

    </p>
    <p>
    
    Both the #'channel.close'{} and #'connection.close'{} commands take the arguments reply_code (an integer) and reply_text (binary text), which can be set by the client depending on the reason why the channel or connection is being closed. In general, however, the reply_code is set to 200 to indicate a normal shutdown. The reply_text attribute is just an arbitrary string, that the server may or may not log. If a client wants to set to a different reply code and/or text, it can use the overloaded functions amqp_channel:close/3 and amqp_connection:close/3 respectively.
    
    </p>
  </doc:section>

<!-- ..................................................................... -->

  <doc:section name="example">
  <doc:heading>Complete Example</doc:heading>
   <p>

     This shows a complete example: 

     <pre class="sourcecode">
      Channel = amqp_connection:open_channel(Connection),
      amqp_channel:close(Channel),
     </pre>

   </p>
  </doc:section>


<!-- ..................................................................... -->

  <doc:section name="flow">
  <doc:heading>Flow Control</doc:heading>
  </doc:section>


<!-- ..................................................................... -->

  <doc:section name="tx">
  <doc:heading>Transactions</doc:heading>
  </doc:section>
  
<!-- ..................................................................... -->

  <doc:section name="multiple_channels">
  <doc:heading>Parallelism Through Multiple Channels</doc:heading>
   <p>
     The fundamental unit of parallelism in the AMQP model is the channel. Channels are designed to multiplex multiple interaction streams between the client and the broker. In general, each client process that sends or receives commands to the broker should have its own dedicated channel. As such, the client is free to create as many channels within a connection as is required by the application.
   </p>
  </doc:section>
</doc:div>
</body>
</html>