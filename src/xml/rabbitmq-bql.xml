<?xml-stylesheet type="text/xml" href="page.xsl"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns:doc="http://www.rabbitmq.com/namespaces/ad-hoc/doc">
  <head>
    <title>RabbitMQ - Broker Query Language Plugin</title>
  </head>
  <body>
    <doc:div>
      <p class="intro">
        This is the documentation for the rabbitmq-bql plugin. The Broker Query Language plugin provides
        a textual, SQL-like query language for interrogating and configuring the broker.
      </p>
      
      <doc:toc class="compact">
        <doc:heading>Table of Contents</doc:heading>
      </doc:toc>

      <doc:section name="installation">
        <doc:heading>Installation</doc:heading>
        <p>
          Please see the <a href="admin-guide.html#guide">plugin installation guide</a>
          for more detailed instructions on plugin installation.
        </p>
        <ul>
          <li>
            Download the latest version of the rabbitmq-bql plugin from TODO, and place
            it in the plugins/ subdirectory of your installed RabbitMQ instance.
          </li>
          <li>
            Execute:
            <pre class="sourcecode">rabbitmq-activate-plugins</pre>
            to complete the installation of the plugin. Restart RabbitMQ once this has
            completed.
          </li>
        </ul>
      </doc:section>
 
      <doc:section name="running">
        <doc:heading>Running the Console</doc:heading>
        <p>
          Once the plugin has been successfully activated, the bql launch script will be made
          available in priv/plugins/rabbitmq-bql/scripts. This script should be executed as
          the RabbitMQ user. (On Linux/UNIX platforms, this will generally be &quot;rabbitmq&quot;.).
          For example, to run this on a Linux platform running rabbitmq-server 1.6.0, you would execute:
          <pre class="sourcecode">$ cd /usr/lib/rabbitmq/lib/rabbitmq_server-1.6.0
$ su - rabbitmq -s /bin/sh -c priv/plugins/rabbitmq-bql/scripts/bql
BQL> </pre>
        </p>
        <p>
          To ensure that your console is able to connect to Rabbit, execute a simple command such as:
          <pre class="sourcecode">BQL> select * from exchanges</pre>
          You should see output similar to:
          <pre class="sourcecode">------------------------------------------------------------------
| name             | type    | durable | auto_delete | arguments |
------------------------------------------------------------------
| amq.rabbitmq.log | topic   | true    | false       |           |
| amq.match        | headers | true    | false       |           |
| amq.headers      | headers | true    | false       |           |
| amq.topic        | topic   | true    | false       |           |
| amq.direct       | direct  | true    | false       |           |
| amq.fanout       | fanout  | true    | false       |           |
|                  | direct  | true    | false       |           |
| bql.query        | direct  | true    | false       |           |</pre>
        </p>
      </doc:section>

      <doc:section name="commands">
        <doc:heading>Available Commands</doc:heading>

        <p>
          BQL supports many different commands, falling broadly into categories of:
        </p>
        <ul>
          <li>Exchange Management</li>
          <li>Queue Management</li>
          <li>Route Management</li>
          <li>Basic Messaging</li>
          <li>User Management</li>
          <li>VHost Management</li>
          <li>Permission Management</li>
        </ul>
        <p>
          The commands available in each category are described in detail below.
        </p>

        <doc:subsection name="general-command-details">
          <doc:heading>General Structure of Commands</doc:heading>
          
          <p>
            Broadly, BQL aims to provide a syntax very similar to SQL. However, it should be noted
            that it often departs from a pure SQL-92 syntax in order to provide a more relevant experience
            to the Broker data structure.
          </p>
          <p>
            Commands are generally in the form of:
            <pre class="sourcecode">BQL> create exchange myexchange;
ok
BQL> create durable queue 'myqueue'
ok
BQL> select name,messages from queues where 'durable'=true order by name
----------------------
| name    | messages |
----------------------
| myqueue | 0        |</pre>
            There are a number of points to note about these commands:
          </p>
          <ul>
            <li>
              Single line commands are optionally followed by a semicolon. In BQL scripts however, multiples lines
              must be deliniated by a semicolon
            </li>
            <li>
              Names (such as myqueue) are optionally quoted with single-quotes. Similarly for where and order by clauses.
            </li>
            <li>
              Where keywords are used as names (for example, durable in the where clause), they need to be quoted, otherwise
              a syntax error will be reported.
            </li>
            <li>
              Select queries support "where" and "order by" clauses. Group by and joins are not supported. Aggregation
              predicates are not currently supported (eg, max(messages)).
            </li>
          </ul>
        </doc:subsection>

        <doc:subsection name="exchange-management">
          <doc:heading>Exchange Management</doc:heading>

          <doc:subsection name="exchange-querying">
            <doc:heading>Querying</doc:heading>

            <p>
              Exchanges can be queried by selecting from the &quot;exchanges&quot; entity. For example,
              <pre class="sourcecode">BQL> select * from exchanges
------------------------------------------------------------------
| name             | type    | durable | auto_delete | arguments |
------------------------------------------------------------------
| amq.rabbitmq.log | topic   | true    | false       |           |
| amq.match        | headers | true    | false       |           |
| amq.headers      | headers | true    | false       |           |
| amq.topic        | topic   | true    | false       |           |
| amq.direct       | direct  | true    | false       |           |
| amq.fanout       | fanout  | true    | false       |           |
|                  | direct  | true    | false       |           |
| bql.query        | direct  | true    | false       |           |</pre>
            </p>
          </doc:subsection>

          <doc:subsection name="exchange-creation">
            <doc:heading>Creation</doc:heading>
            
            <p>
              Exchange creation follows the form:
              <pre>create [durable] [direct | topic | headers | fanout] exchange &lt;name></pre>
              A command in the form:
              <pre class="sourcecode">create exchange myX</pre>
              will create a non-durable direct exchange. To override any of these defaults, appropriate keywords
              should be added either to make the exchange durable or to change the exchange type.
            </p>
          </doc:subsection>
        </doc:subsection>
      </doc:section>

      <doc:section name="bql-scripts">
        <doc:heading>BQL Scripts</doc:heading>

        <p>
          Along with the interactive console, the BQL command line utility also supports an optional
          first parameter of a script to execute. For example:
          <pre class="sourcecode">$ echo "create durable exchange durableX;" >/tmp/change.bql
$ cd /usr/lib/rabbitmq/lib/rabbitmq_server-1.6.0
$ su - rabbitmq -s /bin/sh -c priv/plugins/rabbitmq-bql/scripts/bql /tmp/change.bql
ok
$ su - rabbitmq -s /bin/sh -c priv/plugins/rabbitmq-bql/scripts/bql
BQL> select * from exchanges where name='durableX';
---------------------------------------------------------
| name     | type   | durable | auto_delete | arguments |
---------------------------------------------------------
| durableX | direct | true    | false       |           |

BQL></pre>
        </p>
      </doc:section>

      <doc:section name="dumping">
        <doc:heading>Dumping Broker State</doc:heading>
        
        <p>
          Alongside the bql command, the plugin also provides a utility called bql_dump. This utility
          will transform current broker state into a replayable BQL script that can be re-applied at
          a later date.
        </p>
        <p>
          A sample invocation of this script might be along the lines of:
          <pre class="sourcecode">cd /usr/lib/rabbitmq/lib/rabbitmq_server-1.6.0
su - rabbitmq -s /bin/sh -c priv/plugins/rabbitmq-bql/scripts/bql_dump</pre>
          And would produce output like:
          <pre class="sourcecode">create durable exchange 'testexchange';
create durable queue 'testqueue';
create route from 'testexchange' to 'testqueue' where routing_key is 'key';</pre>
        </p>
      </doc:section>

      <doc:section name="managing-broker-change">
        <doc:heading>Managing Broker Change with BQL</doc:heading>
        
        <p>
          Many typical AMQP applications will declare their own exchanges, queues and bindings upon
          startup. In these cases, an application upgrade will result in any necessary changes occurring
          automatically. However, in some deployments, it may be desirable for routing to be managed
          externally to the applications. For example, you may have an environment where you want to gradually
          increase the number of sources that an individual queue is fed by. You could either configure your
          application to support modifying it's bindings; or you could manage this routing in an external manner,
          similarly to the way that database layouts are maintained externally to the applications with SQL.
        </p>
        <p>
          Utilising BQL, it is possible to perform the external management scenario in a controlled manner. Similarly
          to the way that SQL patch scripts are used in many organisational settings, BQL patch scripts can be 
          distributed and version controlled. Test environments can be used to test the application of these scripts,
          and "reverse patch" scripts can be maintained allowing a failed application installation to be reverted.
        </p>
      </doc:section>
    </doc:div>
  </body>
</html>
