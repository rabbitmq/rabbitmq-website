---
title: "AtomizeJS: Distributed Software Transactional Memory"
tags: ["Web Messaging", "Programming Languages", ]
authors: [matthew]
---

**[AtomizeJS](http://atomizejs.github.com/) is a JavaScript library for writing distributed programs, that run in the browser, without having to write any application specific logic on the server.**

Here at RabbitMQ HQ we spend quite a lot of time arguing. Occasionally, it's about important things, like what *messaging* really means, and the range of different APIs that can be used to achieve *messaging*. RabbitMQ and AMQP present a very explicit interface to messaging: you very much have verbs *send* and *receive* and you need to think about what your messaging patterns are. There's a lot (of often quite clever stuff) going on under the bonnet but nevertheless, the interface is quite low-level and explicit, which gives a good degree of flexibility. Sometimes though, that style of API is not the most natural fit for the problem you're trying to solve - do you really reach an impasse and think "What I need here is an AMQP-message broker", or do you, from pre-existing knowledge, realise that you could choose to use an AMQP-message broker to solve your current problem?

<!-- truncate -->

[AtomizeJS](http://atomizejs.github.com/getting_started.html) exists at the opposite end of the spectrum. There is lots of messaging involved, but you almost never get to see any of it. Instead, you write transactions in JavaScript that modify objects, and those objects are shared between all clients that are connected to the same AtomizeJS server. The [API](http://atomizejs.github.com/api.html) that you're given lets you do slightly more powerful things than you're used to from database transactions, in particular, `retry` allows you to abort a transaction but then restart it automatically once someone else has changed one of the variables you read. This means you have the observer-pattern, and from that you can then build any explicit messaging patterns you want. In most cases, I doubt you'll be building APIs that say *send* or *receive*, instead you'll be building richer data-structures - work queues, shared dictionaries etc. The question to pose then is: is it easier to build these things based on top of a transaction-like API such as offered by AtomizeJS, or on top of an explicit messaging API such as offered by RabbitMQ and AMQP brokers. There is no one solution and horses-for-courses etc, but please leave your thoughts below.

The gain that AtomizeJS provides is not so much in the use of STM from the browser, but the use of STM against a distributed object. This allows you to trivially share state between browsers, modify it safely in intuitive terms, and thus build your applications with little or no application-specific server-side code. Currently, it's a little clunky to use with browsers that don't support bleeding-edge JavaScript features (though I've provided some tooling to try and mitigate this), and everything does work with the latest versions of Chrome, Firefox, IE, Safari, and Opera. Please [have a go](http://atomizejs.github.com/getting_started.html) and [let us know](http://atomizejs.github.com/contact.html) what you think!
